diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/Makefile linux-2.6.29.2.new/arch/arm/mach-ep93xx/Makefile
--- linux-2.6.29.2/arch/arm/mach-ep93xx/Makefile	2009-04-27 17:37:11.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/Makefile	2009-05-06 06:52:19.000000000 +0000
@@ -1,7 +1,7 @@
 #
 # Makefile for the linux kernel.
 #
-obj-y			:= core.o clock.o gpio.o
+obj-y			:= core.o clock.o gpio.o ssp.o dma_ep93xx.o
 obj-m			:=
 obj-n			:=
 obj-			:=
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/core.c linux-2.6.29.2.new/arch/arm/mach-ep93xx/core.c
--- linux-2.6.29.2/arch/arm/mach-ep93xx/core.c	2009-04-27 17:37:11.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/core.c	2009-05-06 12:40:20.000000000 +0000
@@ -537,6 +537,32 @@
 	platform_device_register(&ep93xx_i2c_device);
 }
 
+static struct resource ep93xx_ac97_resources[] = {
+	[0] = {
+		.start		= EP93XX_AC97_PHY_BASE,
+		.end		= EP93XX_AC97_PHY_BASE + 0x6C,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= NO_IRQ,
+		.end		= NO_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ep93xx_ac97_dma_mask = 0xffffffffUL;
+
+static struct platform_device ep93xx_ac97_device = {
+	.name		= "ep93xx-ac97",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= ep93xx_ac97_resources,
+	.dev = {
+		.dma_mask		= &ep93xx_ac97_dma_mask,
+		.coherent_dma_mask	= 0xffffffffUL,
+	},
+};
+
 extern void ep93xx_gpio_init(void);
 
 void __init ep93xx_init_devices(void)
@@ -559,4 +585,5 @@
 
 	platform_device_register(&ep93xx_rtc_device);
 	platform_device_register(&ep93xx_ohci_device);
+	platform_device_register(&ep93xx_ac97_device);
 }
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/dma_ep93xx.c linux-2.6.29.2.new/arch/arm/mach-ep93xx/dma_ep93xx.c
--- linux-2.6.29.2/arch/arm/mach-ep93xx/dma_ep93xx.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/dma_ep93xx.c	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,2933 @@
+/******************************************************************************
+ * arch/arm/mach-ep9312/dma_ep93xx.c
+ *
+ * Support functions for the ep93xx internal DMA channels.
+ * (see also Documentation/arm/ep93xx/dma.txt)
+ *
+ * Copyright (C) 2003  Cirrus Logic
+ *
+ * A large portion of this file is based on the dma api implemented by
+ * Nicolas Pitre, dma-sa1100.c, copyrighted 2000.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <mach/dma.h>
+#include "dma_ep93xx.h"
+
+/*****************************************************************************
+ *
+ * Debugging macros
+ *
+ ****************************************************************************/
+#undef DEBUG
+//#define DEBUG   1
+#ifdef DEBUG
+#define DPRINTK( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DPRINTK( fmt, arg... )
+#endif
+
+/*****************************************************************************
+ *
+ * static global variables
+ *
+ ****************************************************************************/
+ep93xx_dma_t dma_chan[MAX_EP93XX_DMA_CHANNELS];
+
+/*
+ *  lock used to protect the list of dma channels while searching for a free
+ *  channel during dma_request.
+ */
+//static spinlock_t dma_list_lock;
+static spinlock_t dma_list_lock = SPIN_LOCK_UNLOCKED;
+
+/*****************************************************************************
+ *
+ *  Internal DMA processing functions.
+ *
+ ****************************************************************************/
+/*****************************************************************************
+ *
+ *  get_dma_channel_from_handle()
+ *
+ *  If Handle is valid, returns the DMA channel # (0 to 9 for channels 1-10)
+ *  If Handle is not valid, returns -1.
+ *
+ ****************************************************************************/
+static int
+dma_get_channel_from_handle(int handle)
+{
+	int channel;
+
+	/*
+	 *  Get the DMA channel # from the handle.
+	 */
+	channel = ((int)handle & DMA_HANDLE_SPECIFIER_MASK) >> 28;
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (dma_chan[channel].last_valid_handle != (int)handle) {
+		DPRINTK("DMA ERROR - invalid handle 0x%x \n", handle);
+		return(-1);
+	}
+
+	/*
+	 *  See if this instance is still open
+	 */
+	if (!dma_chan[channel].ref_count )
+		return(-1);
+
+	return(channel);
+}
+
+static void dma_m2m_transfer_done(ep93xx_dma_t *dma)
+{
+	unsigned int uiCONTROL;
+	unsigned int M2M_reg_base = dma->reg_base;
+	unsigned int read_back;
+
+	DPRINTK("1  ");
+
+	outl( 0, M2M_reg_base+M2M_OFFSET_INTERRUPT );
+
+	if (dma->total_buffers) {
+		/*
+		 * The current_buffer has already been tranfered, so add the
+		 * byte count to the total_bytes field.
+		 */
+		dma->total_bytes = dma->total_bytes +
+			dma->buffer_queue[dma->current_buffer].size;
+
+		/*
+		 * Mark the current_buffer as used.
+		 */
+		dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+		/*
+		 * Increment the used buffer counter
+		 */
+		dma->used_buffers++;
+
+		DPRINTK("#%d", dma->current_buffer);
+
+		/*
+		 * Increment the current_buffer
+		 */
+		dma->current_buffer = (dma->current_buffer + 1) %
+				      MAX_EP93XX_DMA_BUFFERS;
+
+		/*
+		 * check if there's a new buffer to transfer.
+		 */
+		if (dma->new_buffers && dma->xfer_enable) {
+			/*
+			 * We have a new buffer to transfer so program in the
+			 * buffer values.  Since a STALL interrupt was
+			 * triggered, we program the buffer descriptor 0
+			 *
+			 * Set the SAR_BASE/DAR_BASE/BCR registers with values
+			 * from the next buffer in the queue.
+			 */
+			outl( dma->buffer_queue[dma->current_buffer].source,
+			      M2M_reg_base + M2M_OFFSET_SAR_BASE0 );
+
+			outl( dma->buffer_queue[dma->current_buffer].dest,
+			      M2M_reg_base + M2M_OFFSET_DAR_BASE0 );
+
+			outl( dma->buffer_queue[dma->current_buffer].size,
+			      M2M_reg_base + M2M_OFFSET_BCR0 );
+
+			DPRINTK("SAR_BASE0 - 0x%x\n", dma->buffer_queue[dma->current_buffer].source);
+			DPRINTK("DAR_BASE0 - 0x%x\n", dma->buffer_queue[dma->current_buffer].dest);
+			DPRINTK("BCR0 - 0x%x\n", dma->buffer_queue[dma->current_buffer].size);
+
+			/*
+			 * Decrement the new buffer counter
+			 */
+			dma->new_buffers--;
+
+			/*
+			 * If there's a second new buffer, we program the
+			 * second buffer descriptor.
+			 */
+			if (dma->new_buffers) {
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].source,
+				      M2M_reg_base+M2M_OFFSET_SAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].dest,
+				      M2M_reg_base+M2M_OFFSET_DAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].size,
+				      M2M_reg_base+M2M_OFFSET_BCR1 );
+
+				uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+				uiCONTROL |= CONTROL_M2M_NFBINTEN;
+				outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+				dma->new_buffers--;
+			}
+		} else {
+			DPRINTK("2 \n");
+			/*
+			 * There's a chance we setup both buffer descriptors,
+			 * but didn't service the NFB quickly enough, causing
+			 * the channel to transfer both buffers, then enter the
+			 * stall state.  So, we need to be able to process the
+			 * second buffer.
+			 */
+			if ((dma->used_buffers + dma->new_buffers) < dma->total_buffers)
+			{
+				DPRINTK("3 ");
+
+				/*
+				 * The current_buffer has already been
+				 * tranferred, so add the byte count to the
+				 * total_bytes field.
+				 */
+				dma->total_bytes = dma->total_bytes +
+					dma->buffer_queue[dma->current_buffer].size;
+
+				/*
+				 * Mark the current_buffer as used.
+				 */
+				dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+				/*
+				 * Increment the used buffer counter
+				 */
+				dma->used_buffers++;
+
+				DPRINTK("#%d", dma->current_buffer);
+
+				/*
+				 * Increment the current buffer pointer.
+				 */
+				dma->current_buffer = (dma->current_buffer + 1) %
+						      MAX_EP93XX_DMA_BUFFERS;
+
+			}
+
+			/*
+			 * No new buffers to transfer, so disable the channel.
+			 */
+			uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2M_ENABLE;
+			outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+			/*
+			 * Indicate that this channel is in the pause by
+			 * starvation state by setting the pause bit to true.
+			 */
+			dma->pause = TRUE;
+		}
+	} else {
+		/*
+		 * No buffers to transfer, or old buffers to mark as used,
+		 * so disable the channel
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+		/*
+		 * Must read the control register back after a write.
+		 */
+		read_back = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+
+		/*
+		 * Indicate that this channel is in the pause by
+		 * starvation state by setting the pause bit to true.
+		 */
+		dma->pause = TRUE;
+	}
+}
+
+static void dma_m2m_next_frame_buffer(ep93xx_dma_t *dma)
+{
+	int loop;
+	unsigned int uiCONTROL;
+	unsigned int M2M_reg_base = dma->reg_base;
+
+	DPRINTK("5  ");
+
+	if (dma->total_buffers) {
+		DPRINTK("6  ");
+		/*
+		 * The iCurrentBuffer has already been transfered.  so add the
+		 * byte count from the current buffer to the total byte count.
+		 */
+		dma->total_bytes = dma->total_bytes +
+			dma->buffer_queue[dma->current_buffer].size;
+
+		/*
+		 * Mark the Current Buffer as used.
+		 */
+		dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+		/*
+		 * Increment the used buffer counter
+		 */
+		dma->used_buffers++;
+
+		DPRINTK("#%d", dma->current_buffer);
+
+		if ((dma->buffer_queue[
+		    (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].last) ||
+		    (dma->new_buffers == 0) || (dma->xfer_enable == FALSE)) {
+			DPRINTK("7  ");
+
+			/*
+			 * This is the last Buffer in this transaction, so
+			 * disable the NFB interrupt.  We shouldn't get an NFB
+			 * int when the FSM moves to the ON state where it
+			 * would typically get the NFB int indicating a new
+			 * buffer can be programmed.  Instead, once in the ON
+			 * state, the DMA will just proceed to complete the
+			 * transfer of the current buffer, move the FSB
+			 * directly to the STALL state where a STALL interrupt
+			 * will be generated.
+			 */
+			uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2M_NFBINTEN ;
+			outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+			/*
+			 * The current buffer has been transferred, so
+			 * increment the current buffer counter to reflect
+			 * this.
+			 */
+			dma->current_buffer = (dma->current_buffer + 1) %
+					      MAX_EP93XX_DMA_BUFFERS;
+
+			DPRINTK("End of NFB handling. \n");
+			DPRINTK("CONTROL - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_CONTROL) );
+			DPRINTK("STATUS - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_STATUS) );
+			DPRINTK("SAR_BASE0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_SAR_BASE0) );
+			DPRINTK("SAR_CUR0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_SAR_CURRENT0) );
+			DPRINTK("DAR_BASE0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_DAR_BASE0) );
+			DPRINTK("DAR_CUR0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_DAR_CURRENT0) );
+
+			DPRINTK("Buffer	buf_id	 source	   size	   last	   used \n");
+			for (loop = 0; loop < 32; loop ++)
+				DPRINTK("%d		0x%x		0x%x		 0x%x		%d		 %d \n",
+					loop, dma->buffer_queue[loop].buf_id,
+					dma->buffer_queue[loop].source,
+					dma->buffer_queue[loop].size,
+					dma->buffer_queue[loop].last,
+					dma->buffer_queue[loop].used);
+			DPRINTK("pause	 0x%x		0x%x		 0x%x		%d		 %d \n",
+				dma->pause_buf.buf_id, dma->pause_buf.source,
+				dma->pause_buf.size, dma->pause_buf.last,
+				dma->pause_buf.used);
+
+			DPRINTK("Pause - %d \n", dma->pause);
+			DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+			DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+			DPRINTK("total buffer - %d \n", dma->total_buffers);
+			DPRINTK("new buffers - %d \n", dma->new_buffers);
+			DPRINTK("current buffer - %d \n", dma->current_buffer);
+			DPRINTK("last buffer - %d \n", dma->last_buffer);
+			DPRINTK("used buffers - %d \n", dma->used_buffers);
+			DPRINTK("callback addr - 0x%p \n", dma->callback);
+
+		} else if (dma->new_buffers) {
+			DPRINTK("8  ");
+			/*
+			 * We have a new buffer, so increment the current
+			 * buffer to point to the next buffer, which is already
+			 * programmed into the DMA. Next time around, it'll be
+			 * pointing to the current buffer.
+			 */
+			dma->current_buffer = (dma->current_buffer + 1) %
+					      MAX_EP93XX_DMA_BUFFERS;
+
+			/*
+			 * We know we have a new buffer to program as the next
+			 * buffer, so check which set of SAR_BASE/DAR_BASE/BCR
+			 * registers to program.
+			 */
+			if ( inl(M2M_reg_base+M2M_OFFSET_STATUS) & STATUS_M2M_NB ) {
+				/*
+				 * Set the SAR_BASE1/DAR_BASE1/BCR1 registers
+				 * with values from the next buffer in the
+				 * queue.
+				 */
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].source,
+				      M2M_reg_base+M2M_OFFSET_SAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].dest,
+				      M2M_reg_base+M2M_OFFSET_DAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].size,
+				      M2M_reg_base+M2M_OFFSET_BCR1 );
+			} else {
+				/*
+				 * Set the SAR_BASE0/DAR_BASE0/BCR0 registers
+				 * with values from the next buffer in the
+				 * queue.
+				 */
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].source,
+				      M2M_reg_base+M2M_OFFSET_SAR_BASE0 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].dest,
+				      M2M_reg_base+M2M_OFFSET_DAR_BASE0 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].size,
+				      M2M_reg_base+M2M_OFFSET_BCR0 );
+			}
+
+			/*
+			 *  Decrement the new buffers counter
+			 */
+			dma->new_buffers--;
+		}
+	} else {
+		/*
+		 * Total number of buffers is 0 - really we should never get
+		 * here, but just in case.
+		 */
+		DPRINTK("9 \n");
+
+		/*
+		 *  No new buffers to transfer, so Disable the channel
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+		/*
+		 *  Indicate that the channel is paused by starvation.
+		 */
+		dma->pause = 1;
+	}
+}
+
+/*****************************************************************************
+ *
+ * dma_m2m_irq_handler
+ *
+ ****************************************************************************/
+static irqreturn_t
+dma_m2m_irq_handler(int irq, void *dev_id)
+{
+	ep93xx_dma_t *dma = (ep93xx_dma_t *)dev_id;
+	unsigned int M2M_reg_base = dma->reg_base;
+	ep93xx_dma_dev_t dma_int = UNDEF_INT;
+	int status;
+
+//	printk("+m2m irq=%d\n", irq);
+
+	/*
+	 *  Determine what kind of dma interrupt this is.
+	 */
+	status = inl(M2M_reg_base + M2M_OFFSET_INTERRUPT);
+	if ( status & INTERRUPT_M2M_DONEINT )
+		dma_int = DONE; // we're done with a requested dma
+	else if ( status & INTERRUPT_M2M_NFBINT )
+		dma_int = NFB;  // we're done with one dma buffer
+
+	DPRINTK("IRQ: b=%#x st=%#x\n", (int)dma->current_buffer, dma_int);
+
+	switch (dma_int) {
+	/*
+	 *  Next Frame Buffer Interrupt.  If there's a new buffer program it
+	 *  Check if this is the last buffer in the transfer,
+	 *  and if it is, disable the NFB int to prevent being
+	 *  interrupted for another buffer when we know there won't be
+	 *  another.
+	 */
+	case NFB:
+		dma_m2m_next_frame_buffer(dma);
+		break;
+	/*
+	 *  Done interrupt generated, indicating that the transfer is complete.
+	 */
+	case DONE:
+		dma_m2m_transfer_done(dma);
+		break;
+
+	default:
+		break;
+	}
+
+	if ((dma_int != UNDEF_INT) && dma->callback)
+		dma->callback(dma_int, dma->device, dma->user_data);
+
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************
+ *
+ * dma_m2p_irq_handler
+ *
+ *
+ *
+ ****************************************************************************/
+static irqreturn_t
+dma_m2p_irq_handler(int irq, void *dev_id)
+{
+	ep93xx_dma_t *dma = (ep93xx_dma_t *) dev_id;
+	unsigned int M2P_reg_base = dma->reg_base;
+	unsigned int read_back;
+	ep93xx_dma_dev_t dma_int = UNDEF_INT;
+	unsigned int loop, uiCONTROL, uiINTERRUPT;
+
+	/*
+	 *  Determine what kind of dma interrupt this is.
+	 */
+	if ( inl(M2P_reg_base+M2P_OFFSET_INTERRUPT) & INTERRUPT_M2P_STALLINT )
+		dma_int = STALL;
+	else if ( inl(M2P_reg_base+M2P_OFFSET_INTERRUPT) & INTERRUPT_M2P_NFBINT )
+		dma_int = NFB;
+	else if ( inl(M2P_reg_base+M2P_OFFSET_INTERRUPT) & INTERRUPT_M2P_CHERRORINT )
+		dma_int = CHERROR;
+
+	/*
+	 *  Stall Interrupt: The Channel is stalled, meaning nothing is
+	 *  programmed to transfer right now.  So, we're back to the
+	 *  beginnning.  If there's a buffer to transfer, program it into
+	 *  max and base 0 registers.
+	 */
+	if (dma_int == STALL) {
+		DPRINTK("1  ");
+
+		if (dma->total_buffers) {
+			/*
+			 * The current_buffer has already been tranfered, so
+			 * add the byte count to the total_bytes field.
+			 */
+			dma->total_bytes = dma->total_bytes +
+				dma->buffer_queue[dma->current_buffer].size;
+
+			/*
+			 *  Mark the current_buffer as used.
+			 */
+			dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+			/*
+			 *  Increment the used buffer counter
+			 */
+			dma->used_buffers++;
+
+			DPRINTK("#%d", dma->current_buffer);
+
+			/*
+			 *  Increment the current_buffer
+			 */
+			dma->current_buffer = (dma->current_buffer + 1) %
+					      MAX_EP93XX_DMA_BUFFERS;
+
+			/*
+			 *  check if there's a new buffer to transfer.
+			 */
+			if (dma->new_buffers && dma->xfer_enable) {
+				/*
+				 * We have a new buffer to transfer so program
+				 * in the buffer values.  Since a STALL
+				 * interrupt was triggered, we program the
+				 * base0 and maxcnt0
+				 *
+				 * Set the MAXCNT0 register with the buffer
+				 * size
+				 */
+				outl( dma->buffer_queue[dma->current_buffer].size,
+					  M2P_reg_base+M2P_OFFSET_MAXCNT0 );
+
+				/*
+				 * Set the BASE0 register with the buffer base
+				 * address
+				 */
+				outl( dma->buffer_queue[dma->current_buffer].source,
+					  M2P_reg_base+M2P_OFFSET_BASE0 );
+
+				/*
+				 *  Decrement the new buffer counter
+				 */
+				dma->new_buffers--;
+
+				if (dma->new_buffers) {
+					DPRINTK("A  ");
+					/*
+					 * Set the MAXCNT1 register with the
+					 * buffer size
+					 */
+					outl( dma->buffer_queue[(dma->current_buffer + 1) %
+											MAX_EP93XX_DMA_BUFFERS].size,
+						  M2P_reg_base+M2P_OFFSET_MAXCNT1 );
+
+					/*
+					 * Set the BASE1 register with the
+					 * buffer base address
+					 */
+					outl( dma->buffer_queue[dma->current_buffer + 1 %
+											MAX_EP93XX_DMA_BUFFERS].source,
+						  M2P_reg_base+M2P_OFFSET_BASE1 );
+
+					/*
+					 *  Decrement the new buffer counter
+					 */
+					dma->new_buffers--;
+
+					/*
+					 *  Enable the NFB Interrupt.
+					 */
+					uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+					uiCONTROL |= CONTROL_M2P_NFBINTEN;
+					outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+				}
+			} else {
+				/*
+				 *  No new buffers.
+				 */
+				DPRINTK("2 \n");
+
+				/*
+				 *  There's a chance we setup both buffer descriptors, but
+				 *  didn't service the NFB quickly enough, causing the channel
+				 *  to transfer both buffers, then enter the stall state.
+				 *  So, we need to be able to process the second buffer.
+				 */
+				if ((dma->used_buffers + dma->new_buffers) < dma->total_buffers) {
+					DPRINTK("3 ");
+
+					/*
+					 *  The current_buffer has already been tranfered, so add the
+					 *  byte count to the total_bytes field.
+					 */
+					dma->total_bytes = dma->total_bytes +
+						dma->buffer_queue[dma->current_buffer].size;
+
+					/*
+					 *  Mark the current_buffer as used.
+					 */
+					dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+					/*
+					 *  Increment the used buffer counter
+					 */
+					dma->used_buffers++;
+
+					DPRINTK("#%d", dma->current_buffer);
+
+					/*
+					 *  Increment the current buffer pointer.
+					 */
+					dma->current_buffer = (dma->current_buffer + 1) %
+						MAX_EP93XX_DMA_BUFFERS;
+
+				}
+
+				/*
+				 *  No new buffers to transfer, so disable the channel.
+				 */
+				uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+				uiCONTROL &= ~CONTROL_M2P_ENABLE;
+				outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+				/*
+				 *  Indicate that this channel is in the pause by starvation
+				 *  state by setting the pause bit to true.
+				 */
+				dma->pause = TRUE;
+
+				DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+				DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+				DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+				DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+				DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+				DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+				DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+				DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+				DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+				DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+				DPRINTK("Buffer	buf_id	 source	   size	   last	   used \n");
+				for (loop = 0; loop < 32; loop ++)
+					DPRINTK("%d		0x%x		0x%x		 0x%x		%d		 %d \n",
+							loop, dma->buffer_queue[loop].buf_id, dma->buffer_queue[loop].source,
+							dma->buffer_queue[loop].size,
+							dma->buffer_queue[loop].last, dma->buffer_queue[loop].used);
+				DPRINTK("pause	 0x%x		0x%x		 0x%x		%d		 %d \n",
+						dma->pause_buf.buf_id, dma->pause_buf.source, dma->pause_buf.size,
+						dma->pause_buf.last, dma->pause_buf.used);
+
+				DPRINTK("Pause - %d \n", dma->pause);
+				DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+				DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+				DPRINTK("total buffer - %d \n", dma->total_buffers);
+				DPRINTK("new buffers - %d \n", dma->new_buffers);
+				DPRINTK("current buffer - %d \n", dma->current_buffer);
+				DPRINTK("last buffer - %d \n", dma->last_buffer);
+				DPRINTK("used buffers - %d \n", dma->used_buffers);
+				DPRINTK("callback addr - 0x%p \n", dma->callback);
+			}
+		} else {
+			/*
+			 *  No buffers to transfer, or old buffers to mark as used,
+			 *  so Disable the channel
+			 */
+			uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2P_ENABLE;
+			outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+			/*
+			 *  Must read the control register back after a write.
+			 */
+			read_back = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+
+			/*
+			 *  Indicate that this channel is in the pause by
+			 *  starvation state by setting the pause bit to true.
+			 */
+			dma->pause = TRUE;
+		}
+	}
+
+	/*
+	 *  Next Frame Buffer Interrupt.  If there's a new buffer program it
+	 *  Check if this is the last buffer in the transfer,
+	 *  and if it is, disable the NFB int to prevent being
+	 *  interrupted for another buffer when we know there won't be
+	 *  another.
+	 */
+	if (dma_int == NFB) {
+		DPRINTK("5  ");
+
+		if (dma->total_buffers) {
+			DPRINTK("6  ");
+			/*
+			 *  The iCurrentBuffer has already been transfered.  so add the
+			 *  byte count from the current buffer to the total byte count.
+			 */
+			dma->total_bytes = dma->total_bytes +
+				dma->buffer_queue[dma->current_buffer].size;
+
+			/*
+			 *  Mark the Current Buffer as used.
+			 */
+			dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+			/*
+			 *  Increment the used buffer counter
+			 */
+			dma->used_buffers++;
+
+			DPRINTK("#%d", dma->current_buffer);
+
+			if ((dma->buffer_queue[
+			    (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].last) ||
+			    (dma->new_buffers == 0) || (dma->xfer_enable == FALSE)) {
+				DPRINTK("7  ");
+
+				/*
+				 *  This is the last Buffer in this transaction, so disable
+				 *  the NFB interrupt.  We shouldn't get an NFB int when the
+				 *  FSM moves to the ON state where it would typically get the
+				 *  NFB int indicating a new buffer can be programmed.
+				 *  Instead, once in the ON state, the DMA will just proceed
+				 *  to complet the transfer of the current buffer, move the
+				 *  FSB directly to the STALL state where a STALL interrupt
+				 *  will be generated.
+				 */
+				uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+				uiCONTROL &= ~CONTROL_M2P_NFBINTEN;
+				outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+				/*
+				 *  The current buffer has been transferred, so increment
+				 *  the current buffer counter to reflect this.
+				 */
+				dma->current_buffer = (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS;
+
+				DPRINTK("End of NFB handling. \n");
+				DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+				DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+				DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+				DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+				DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+				DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+				DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+				DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+				DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+				DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+				DPRINTK("Buffer	buf_id	 source	   size	   last	   used \n");
+				for (loop = 0; loop < 32; loop ++)
+					DPRINTK("%d		0x%x		0x%x		 0x%x		%d		 %d \n",
+							loop, dma->buffer_queue[loop].buf_id, dma->buffer_queue[loop].source,
+							dma->buffer_queue[loop].size,
+							dma->buffer_queue[loop].last, dma->buffer_queue[loop].used);
+				DPRINTK("pause	 0x%x		0x%x		 0x%x		%d		 %d \n",
+						dma->pause_buf.buf_id, dma->pause_buf.source, dma->pause_buf.size,
+						dma->pause_buf.last, dma->pause_buf.used);
+
+				DPRINTK("Pause - %d \n", dma->pause);
+				DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+				DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+				DPRINTK("total buffer - %d \n", dma->total_buffers);
+				DPRINTK("new buffers - %d \n", dma->new_buffers);
+				DPRINTK("current buffer - %d \n", dma->current_buffer);
+				DPRINTK("last buffer - %d \n", dma->last_buffer);
+				DPRINTK("used buffers - %d \n", dma->used_buffers);
+				DPRINTK("callback addr - 0x%p \n", dma->callback);
+
+			} else if (dma->new_buffers) {
+				DPRINTK("8  ");
+				/*
+				 *  we have a new buffer, so increment the current buffer to
+				 *  point to the next buffer, which is already programmed into
+				 *  the DMA. Next time around, it'll be pointing to the
+				 *  current buffer.
+				 */
+				dma->current_buffer = (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS;
+
+				/*
+				 *  we know we have a new buffer to program as the next
+				 *  buffer, so check which set of MAXCNT and BASE registers
+				 *  to program.
+				 */
+				if ( inl(M2P_reg_base+M2P_OFFSET_STATUS) & STATUS_M2P_NEXTBUFFER ) {
+					/*
+					 *  Set the MAXCNT1 register with the buffer size
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].size,
+					      M2P_reg_base+M2P_OFFSET_MAXCNT1 );
+
+					/*
+					 *  Set the BASE1 register with the buffer base address
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].source,
+					      M2P_reg_base+M2P_OFFSET_BASE1 );
+				} else {
+					/*
+					 *  Set the MAXCNT0 register with the buffer size
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].size,
+					       M2P_reg_base+M2P_OFFSET_MAXCNT0 );
+
+					/*
+					 *  Set the BASE0 register with the buffer base address
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].source,
+					      M2P_reg_base+M2P_OFFSET_BASE0 );
+				}
+
+				/*
+				 *  Decrement the new buffers counter
+				 */
+				dma->new_buffers--;
+			}
+		} else {
+			/*
+			 *  Total number of buffers is 0 - really we should never get here,
+			 *  but just in case.
+			 */
+			DPRINTK("9 \n");
+
+			/*
+			 *  No new buffers to transfer, so Disable the channel
+			 */
+			uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2P_ENABLE;
+			outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+		}
+	}
+
+	/*
+	 *  Channel Error Interrupt, or perhipheral interrupt, specific to the
+	 *  memory to/from peripheral channels.
+	 */
+	if (dma_int == CHERROR) {
+		/*
+		 *  just clear the interrupt, it's really up to the peripheral
+		 *  driver to determine if any further action is necessary.
+		 */
+		uiINTERRUPT = inl(M2P_reg_base+M2P_OFFSET_INTERRUPT);
+		uiINTERRUPT &= ~INTERRUPT_M2P_CHERRORINT;
+		outl( uiINTERRUPT, M2P_reg_base+M2P_OFFSET_INTERRUPT );
+	}
+
+	/*
+	 *  Make sure the interrupt was valid, and if it was, then check
+	 *  if a callback function was installed for this DMA channel.  If a
+	 *  callback was installed call it.
+	 */
+	if ((dma_int != UNDEF_INT) && dma->callback)
+		dma->callback(dma_int, dma->device, dma->user_data);
+
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************
+ *
+ * ep9312_dma_open_m2p(int device)
+ *
+ * Description: This function will attempt to open a M2P/P2M DMA channel.
+ *			  If the open is successful, the channel number is returned,
+ *			  otherwise a negative number is returned.
+ *
+ * Parameters:
+ *  device:	 device for which the dma channel is requested.
+ *
+ ****************************************************************************/
+static int
+dma_open_m2p(int device)
+{
+	int channel = -1;
+	unsigned int loop;
+	unsigned int M2P_reg_base;
+	unsigned int uiPWRCNT;
+	/*unsigned long flags;*/
+
+	DPRINTK("DMA Open M2P with hw dev %d\n", device);
+
+	/*
+	 *  Lock the dma channel list.
+	 */
+	//spin_lock_irqsave(&dma_list_lock, flags);
+	spin_lock(&dma_list_lock);
+
+	/*
+	 * Verify that the device requesting DMA isn't already using a DMA channel
+	 */
+	if (device >= 10)
+		loop = 1;		 // Rx transfer requested
+	else
+		loop = 0;		 // Tx transfer requested
+
+	for (; loop < 10; loop = loop + 2)
+		/*
+		 *  Before checking for a matching device, check that the
+		 *  channel is in use, otherwise the device field is
+		 *  invalid.
+		 */
+		if (dma_chan[loop].ref_count)
+			if (device == dma_chan[loop].device) {
+				DPRINTK("DMA Open M2P - Error\n");
+				return(-1);
+			}
+
+	/*
+	 *  Get a DMA channel instance for the given hardware device.
+	 *  If this is a TX look for even numbered channels, else look for
+	 *  odd numbered channels
+	 */
+	if (device >= 10)
+		loop = 1;		 /* Rx transfer requested */
+	else
+		loop = 0;		 /* Tx transfer requested */
+
+	for (; loop < 10; loop = loop + 2)
+		if (!dma_chan[loop].ref_count) {
+			/*
+			 *  Capture the channel and increment the reference count.
+			 */
+			channel = loop;
+			dma_chan[channel].ref_count++;
+			break;
+		}
+
+	/*
+	 *  Unlock the dma channel list.
+	 */
+	//spin_unlock_irqrestore(&dma_list_lock, flags);
+	spin_unlock(&dma_list_lock);
+	/*
+	 *  See if we got a valid channel.
+	 */
+	if (channel < 0)
+		return(-1);
+
+	/*
+	 *  Point regs to the correct dma channel register base.
+	 */
+	M2P_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  Turn on the clock for the specified DMA channel
+	 *  TODO: need to use the correct register name for the
+	 *  power control register.
+	 */
+	uiPWRCNT = inl(/*SYSCON_PWRCNT*/EP93XX_SYSCON_CLOCK_CONTROL);
+	switch (channel) {
+	case 0:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH0;
+		break;
+
+	case 1:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH1;
+		break;
+
+	case 2:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH2;
+		break;
+
+	case 3:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH3;
+		break;
+
+	case 4:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH4;
+		break;
+
+	case 5:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH5;
+		break;
+
+	case 6:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH6;
+		break;
+
+	case 7:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH7;
+		break;
+
+	case 8:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH8;
+		break;
+
+	case 9:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH9;
+		break;
+
+	default:
+		return(-1);
+	}
+	outl( uiPWRCNT, /*SYSCON_PWRCNT*/EP93XX_SYSCON_CLOCK_CONTROL );
+
+	/*
+	 *  Clear out the control register before any further setup.
+	 */
+	outl( 0, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	/*
+	 *  Setup the peripheral port value in the DMA channel registers.
+	 */
+	if (device < 10)
+		outl( (unsigned int)device, M2P_reg_base+M2P_OFFSET_PPALLOC );
+	else
+		outl( (unsigned int)(device - 10), M2P_reg_base+M2P_OFFSET_PPALLOC );
+
+	/*
+	 *  Let's hold on to the value of the Hw device for comparison later.
+	 */
+	dma_chan[channel].device = device;
+
+	/*
+	 *  Success.
+	 */
+	return(channel);
+}
+
+/*****************************************************************************
+ *
+ * dma_open_m2m(int device)
+ *
+ * Description: This function will attempt to open a M2M DMA channel.
+ *			  If the open is successful, the channel number is returned,
+ *			  otherwise a negative number is returned.
+ *
+ * Parameters:
+ *  device:	 device for which the dma channel is requested.
+ *
+ ****************************************************************************/
+static int
+dma_open_m2m(int device)
+{
+	int channel = -1;
+	unsigned int loop;
+	unsigned int M2M_reg_base;
+	unsigned int uiPWRCNT, uiCONTROL;
+	/*unsigned long flags;*/
+
+	DPRINTK("DMA Open M2M with hw dev %d\n", device);
+
+	/*
+	 *  Lock the dma channel list.
+	 */
+	//spin_lock_irqsave(&dma_list_lock, flags);
+	spin_lock(&dma_list_lock);
+
+
+	/*
+	 *  Check if this device is already allocated a channel.
+	 *  TODO: can one M2M device be allocated multiple channels?
+	 */
+	for (loop = DMA_MEMORY; loop < UNDEF; loop++)
+		/*
+		 *  Before checking for a matching device, check that the
+		 *  channel is in use, otherwise the device field is
+		 *  invalid.
+		 */
+		if (dma_chan[loop].ref_count)
+			if (device == dma_chan[loop].device) {
+				DPRINTK("Error - dma_open_m2m - already allocated channel\n");
+
+				/*
+				 *  Unlock the dma channel list.
+				 */
+				//spin_unlock_irqrestore(&dma_list_lock, flags);
+				spin_unlock(&dma_list_lock);
+				/*
+				 *  Fail.
+				 */
+				return(-1);
+			}
+
+	/*
+	 *  Get a DMA channel instance for the given hardware device.
+	 */
+	for (loop = 10; loop < 12; loop++)
+		if (!dma_chan[loop].ref_count) {
+			/*
+			 *  Capture the channel and increment the reference count.
+			 */
+			channel = loop;
+			dma_chan[channel].ref_count++;
+			break;
+		}
+
+	/*
+	 *  Unlock the dma channel list.
+	 */
+	//spin_unlock(dma_list_lock);
+	spin_unlock(&dma_list_lock);
+	//spin_unlock_irqrestore(&dma_list_lock, flags);
+
+	/*
+	 *  See if we got a valid channel.
+	 */
+	if (channel < 0)
+		return(-1);
+
+	/*
+	 *  Point regs to the correct dma channel register base.
+	 */
+	M2M_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  Turn on the clock for the specified DMA channel
+	 *  TODO: need to use the correct register name for the
+	 *  power control register.
+	 */
+	uiPWRCNT = inl(/*SYSCON_PWRCNT*/EP93XX_SYSCON_CLOCK_CONTROL);
+	switch (channel) {
+	case 10:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2MCH0;
+		break;
+
+	case 11:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2MCH1;
+		break;
+
+	default:
+		return(-1);
+	}
+	outl( uiPWRCNT, /*SYSCON_PWRCNT*/EP93XX_SYSCON_CLOCK_CONTROL);
+
+	DPRINTK("DMA Open - power control: 0x%x \n", inl(SYSCON_PWRCNT) );
+
+	/*
+	 *  Clear out the control register before any further setup.
+	 */
+	outl( 0, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  Setup the transfer mode and the request source selection within
+	 *  the DMA M2M channel registers.
+	 */
+	switch (device) {
+	case DMA_MEMORY:
+		/*
+		 * Clear TM field, set RSS field to 0
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_TM_MASK | CONTROL_M2M_RSS_MASK);
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMA_IDE:
+		/*
+		 * Set RSS field to 3, Set NO_HDSK, Set PW field to 1
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_PW_MASK);
+		uiCONTROL |= (3<<CONTROL_M2M_RSS_SHIFT) |
+			CONTROL_M2M_NO_HDSK |
+			(2<<CONTROL_M2M_PW_SHIFT);
+
+		uiCONTROL &= ~(CONTROL_M2M_ETDP_MASK);
+		uiCONTROL &= ~(CONTROL_M2M_DACKP);
+		uiCONTROL &= ~(CONTROL_M2M_DREQP_MASK);
+
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		break;
+
+	case DMARx_SSP:
+		/*
+		 * Set RSS field to 1, Set NO_HDSK, Set TM field to 2
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= (1<<CONTROL_M2M_RSS_SHIFT) |
+			CONTROL_M2M_NO_HDSK |
+			(2<<CONTROL_M2M_TM_SHIFT);
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMATx_SSP:
+		/*
+		 * Set RSS field to 2, Set NO_HDSK, Set TM field to 1
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= (2<<CONTROL_M2M_RSS_SHIFT) |
+			CONTROL_M2M_NO_HDSK |
+			(1<<CONTROL_M2M_TM_SHIFT);
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMATx_EXT_DREQ:
+		/*
+		 * Set TM field to 2, set RSS field to 0
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= 1<<CONTROL_M2M_TM_SHIFT;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMARx_EXT_DREQ:
+		/*
+		 * Set TM field to 2, set RSS field to 0
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= 2<<CONTROL_M2M_TM_SHIFT;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	default:
+		return -1;
+	}
+
+	/*
+	 *  Let's hold on to the value of the Hw device for comparison later.
+	 */
+	dma_chan[channel].device = device;
+
+	/*
+	 *  Success.
+	 */
+	return(channel);
+}
+
+/*****************************************************************************
+ *
+ *  int dma_config_m2m(ep93xx_dma_t * dma, unsigned int flags_m2m,
+ *			   dma_callback callback, unsigned int user_data)
+ *
+ *  Description: Configure the DMA channel and install a callback function.
+ *			   This function will have to be called for every transfer
+ *
+ *  dma:		Pointer to the dma instance data for the M2M channel to
+ *			  configure.
+ *  flags_m2m   Flags used to configure an M2M dma channel and determine
+ *			  if a callback function and user_data information are included
+ *			  in this call.
+ *  callback	function pointer which is called near the end of the
+ *			  dma channel's irq handler.
+ *  user_data   defined by the calling driver.
+ *
+ ****************************************************************************/
+static int
+dma_config_m2m(ep93xx_dma_t * dma, unsigned int flags_m2m,
+			   dma_callback callback, unsigned int user_data)
+{
+	unsigned long flags;
+	unsigned int M2M_reg_base, uiCONTROL;
+
+	/*
+	 *  Make sure the channel is disabled before configuring the channel.
+	 *
+	 *  TODO: Is this correct??   Making a big change here...
+	 */
+	/* if (!dma->pause || (!dma->pause && dma->xfer_enable)) */
+	if (dma->xfer_enable) {
+		/*
+		 *  DMA channel is not paused, so we can't configure it.
+		 */
+		DPRINTK("DMA channel not paused, so can't configure! \n");
+		return(-1);
+	}
+
+	/*
+	 *  Mask interrupts.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Setup a pointer into the dma channel's register set.
+	 */
+	M2M_reg_base = dma->reg_base;
+
+	uiCONTROL = inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+	outl(0, M2M_reg_base + M2M_OFFSET_CONTROL);
+	inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+	outl(uiCONTROL, M2M_reg_base + M2M_OFFSET_CONTROL);
+
+	/*
+	 *  By default we disable the stall interrupt.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL &= ~CONTROL_M2M_STALLINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  By default we disable the done interrupt.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL &= ~CONTROL_M2M_DONEINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  Set up the transfer control fields based on values passed in
+	 *  the flags_m2m field.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+
+	if ( flags_m2m & DESTINATION_HOLD )
+		uiCONTROL |= CONTROL_M2M_DAH;
+	else
+		uiCONTROL &= ~CONTROL_M2M_DAH;
+
+	if ( flags_m2m & SOURCE_HOLD )
+		uiCONTROL |= CONTROL_M2M_SAH;
+	else
+		uiCONTROL &= ~CONTROL_M2M_SAH;
+
+	uiCONTROL &= ~CONTROL_M2M_TM_MASK;
+	uiCONTROL |= (((flags_m2m & TRANSFER_MODE_MASK) >> TRANSFER_MODE_SHIFT) <<
+				  CONTROL_M2M_TM_SHIFT) & CONTROL_M2M_TM_MASK;
+
+	uiCONTROL &= ~CONTROL_M2M_PWSC_MASK;
+	uiCONTROL |= (((flags_m2m & WAIT_STATES_MASK) >> WAIT_STATES_SHIFT) <<
+				  CONTROL_M2M_PWSC_SHIFT) & CONTROL_M2M_PWSC_MASK;
+
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+
+	/*
+	 *  Save the callback function in the dma instance for this channel.
+	 */
+	dma->callback = callback;
+
+	/*
+	 *  Save the user data in the the dma instance for this channel.
+	 */
+	dma->user_data = user_data;
+
+	/*
+	 *  Put the dma instance into the pause state by setting the
+	 *  pause bit to true.
+	 */
+	dma->pause = TRUE;
+
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int dma_start(int handle, unsigned int channels, unsigned int * handles)
+ *
+ *  Description: Initiate a transfer on up to 3 channels.
+ *
+ *  handle:	 handle for the channel to initiate transfer on.
+ *  channels:   number of channels to initiate transfers on.
+ *  handles:	pointer to an array of handles, one for each channel which
+ *			   is to be started.
+ *
+ ****************************************************************************/
+static int
+dma_start_m2m(int channel, ep93xx_dma_t * dma)
+{
+	unsigned long flags;
+	unsigned int M2M_reg_base = dma->reg_base;
+	unsigned int uiCONTROL;
+
+	/*
+	 *  Mask interrupts while we get this started.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Make sure the channel has at least one buffer in the queue.
+	 */
+	if (dma->new_buffers < 1) {
+		/*
+		 *  Unmask irqs
+		 */
+		local_irq_restore(flags);
+
+		DPRINTK("DMA Start: Channel starved.\n");
+
+		/*
+		 *  This channel does not have enough buffers queued up,
+		 *  so enter the pause by starvation state.
+		 */
+		dma->xfer_enable = TRUE;
+		dma->pause = TRUE;
+
+		/*
+		 *  Success.
+		 */
+		return(0);
+	}
+
+	/*
+	 *  Clear any pending interrupts.
+	 */
+	outl(0x0, M2M_reg_base+M2M_OFFSET_INTERRUPT);
+
+	/*
+	 *  Set up one or both buffer descriptors with values from the next one or
+	 *  two buffers in the queue.  By default disable the next frame buffer
+	 *  interrupt on the channel.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL &= ~CONTROL_M2M_NFBINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 * enable the done interrupt.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL |= CONTROL_M2M_DONEINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  Update the dma channel instance transfer state.
+	 */
+	dma->xfer_enable = TRUE;
+	dma->pause = FALSE;
+
+	/*
+	 *  Program up the first buffer descriptor with a source and destination
+	 *  and a byte count.
+	 */
+	outl( dma->buffer_queue[dma->current_buffer].source,
+	      M2M_reg_base+M2M_OFFSET_SAR_BASE0 );
+
+	outl( dma->buffer_queue[dma->current_buffer].dest,
+	      M2M_reg_base+M2M_OFFSET_DAR_BASE0 );
+
+	outl( dma->buffer_queue[dma->current_buffer].size,
+	      M2M_reg_base+M2M_OFFSET_BCR0 );
+
+	/*
+	 *  Decrement the new buffers counter.
+	 */
+	dma->new_buffers--;
+
+	/*
+	 * Set up the second buffer descriptor with a second buffer if we have
+	 * a second buffer.
+	 */
+	if (dma->new_buffers) {
+		outl( dma->buffer_queue[(dma->current_buffer + 1) %
+					MAX_EP93XX_DMA_BUFFERS].source,
+		      M2M_reg_base+M2M_OFFSET_SAR_BASE1 );
+
+		outl( dma->buffer_queue[(dma->current_buffer + 1) %
+					MAX_EP93XX_DMA_BUFFERS].dest,
+		      M2M_reg_base+M2M_OFFSET_DAR_BASE1 );
+
+		outl( dma->buffer_queue[(dma->current_buffer + 1) %
+					MAX_EP93XX_DMA_BUFFERS].size,
+		      M2M_reg_base+M2M_OFFSET_BCR1 );
+
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL |= CONTROL_M2M_NFBINTEN;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+		dma->new_buffers--;
+	}
+
+	/*
+	 *  Now we enable the channel.  This initiates the transfer.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL |= CONTROL_M2M_ENABLE;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+
+	/*
+	 *  If this is a memory to memory transfer, we need to s/w trigger the
+	 *  transfer by setting the start bit within the control register.
+	 */
+	if (dma->device == DMA_MEMORY) {
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL |= CONTROL_M2M_START;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	}
+
+	DPRINTK("DMA - It's been started!!");
+	DPRINTK("CONTROL - 0x%x \n",	inl(M2M_reg_base+M2M_OFFSET_CONTROL) );
+	DPRINTK("STATUS - 0x%x \n",	 inl(M2M_reg_base+M2M_OFFSET_STATUS) );
+	DPRINTK("BCR0 - 0x%x \n",	   dma->buffer_queue[dma->current_buffer].size);
+	DPRINTK("SAR_BASE0 - 0x%x \n",  inl(M2M_reg_base+M2M_OFFSET_SAR_BASE0) );
+	DPRINTK("SAR_CUR0 - 0x%x \n",   inl(M2M_reg_base+M2M_OFFSET_SAR_CURRENT0) );
+	DPRINTK("DAR_BASE0 - 0x%x \n",  inl(M2M_reg_base+M2M_OFFSET_DAR_BASE0) );
+	DPRINTK("DAR_CUR0 - 0x%x \n",   inl(M2M_reg_base+M2M_OFFSET_DAR_CURRENT0) );
+
+	/*
+	 *  Unmask irqs
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  DMA interface functions
+ *
+ ****************************************************************************/
+
+/*****************************************************************************
+ *
+ *  int dma_init(int handle, unsigned int flags_m2p, unsigned int flags_m2m,
+ *			   dma_callback callback, unsigned int user_data)
+ *
+ *  Description: Configure the DMA channel and install a callback function.
+ *
+ *  handle:	 Handle unique the each instance of the dma interface, used
+ *			  to verify this call.
+ *  flags_m2p   Flags used to configure an M2P/P2M dma channel and determine
+ *			  if a callback function and user_data information are included
+ *			  in this call. This field should be NULL if handle represents
+ *			  an M2M channel.
+ *  flags_m2m   Flags used to configure an M2M dma channel and determine
+ *			  if a callback function and user_data information are included
+ *			  in this call. This field should be NULL if handle represents
+ *			  an M2P/P2M channel.
+ *  callback	function pointer which is called near the end of the
+ *			  dma channel's irq handler.
+ *  user_data   defined by the calling driver.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_config(int handle, unsigned int flags_m2p, unsigned int flags_m2m,
+		  dma_callback callback, unsigned int user_data)
+{
+	int  channel;
+	ep93xx_dma_t * dma;
+	unsigned long flags;
+	unsigned int M2P_reg_base, uiCONTROL;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR
+			   "DMA Config: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA Config \n");
+
+	dma = &dma_chan[channel];
+
+	local_irq_save(flags);
+
+	/*
+	 *  Check if the channel is currently transferring.
+	 */
+	if (dma->xfer_enable) {
+		local_irq_restore(flags);
+		return(-EINVAL);
+	}
+
+	/*
+	 *  Check if this is an m2m function.
+	 */
+	if (channel >= 10) {
+		local_irq_restore(flags);
+
+		/*
+		 *  Call another function to handle m2m config.
+		 */
+		return(dma_config_m2m(dma, flags_m2m, callback, user_data));
+	}
+
+	/*
+	 *  Setup a pointer into the dma channel's register set.
+	 */
+	M2P_reg_base = dma->reg_base;
+
+	/*
+	 *  By default we enable the stall interrupt.
+	 */
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	uiCONTROL |= CONTROL_M2P_STALLINTEN;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	/*
+	 *  Configure the channel for an error from the peripheral.
+	 */
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	if ( flags_m2p && CHANNEL_ERROR_INT_ENABLE )
+		uiCONTROL |= CONTROL_M2P_CHERRORINTEN;
+	else
+		uiCONTROL &= ~CONTROL_M2P_CHERRORINTEN;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	if ( flags_m2p && CHANNEL_ABORT )
+		uiCONTROL |= CONTROL_M2P_ABRT;
+	else
+		uiCONTROL &= ~CONTROL_M2P_ABRT;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	if ( flags_m2p && IGNORE_CHANNEL_ERROR )
+		uiCONTROL |= CONTROL_M2P_ICE;
+	else
+		uiCONTROL &= ~CONTROL_M2P_ICE;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	/*
+	 *  Save the callback function in the dma instance for this channel.
+	 */
+	dma->callback = callback;
+
+	/*
+	 *  Save the user data in the the dma instance for this channel.
+	 */
+	dma->user_data = user_data;
+
+	/*
+	 *  Put the dma instance into the pause state by setting the
+	 *  pause bit to true.
+	 */
+	dma->pause = TRUE;
+
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int dma_start(int handle, unsigned int channels, unsigned int * handles)
+ *
+ *  Description: Initiate a transfer on up to 3 channels.
+ *
+ *  handle:	 handle for the channel to initiate transfer on.
+ *  channels:   number of channels to initiate transfers on.
+ *  handles:	pointer to an array of handles, one for each channel which
+ *			   is to be started.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_start(int handle, unsigned int channels, unsigned int * handles)
+{
+	ep93xx_dma_t * dma_pointers[3];
+	unsigned int M2P_reg_bases[3];
+	unsigned int loop, uiCONTROL;
+	unsigned long flags;
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Start: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	if (channels < 1) {
+		printk(KERN_ERR "DMA Start: Invalid parameter.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA Start \n");
+
+	/*
+	 *  Mask off registers.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Check if this is a start multiple.
+	 */
+	if (channels > 1) {
+		DPRINTK("DMA ERROR: Start, multiple start not supported yet \n");
+		return(-1);
+	} else {
+		/*
+		 *  Check if this channel is already transferring.
+		 */
+		if (dma_chan[channel].xfer_enable && !dma_chan[channel].pause) {
+			printk(KERN_ERR
+				   "DMA Start: Invalid command for channel %d.\n", channel);
+
+			/*
+			 *  Unmask irqs
+			 */
+			local_irq_restore(flags);
+
+			/*
+			 *  This channel is already transferring, so return an error.
+			 */
+			return(-EINVAL);
+		}
+
+		/*
+		 *  If this is an M2M channel, call a different function.
+		 */
+		if (channel >= 10) {
+			/*
+			 *  Unmask irqs
+			 */
+			local_irq_restore(flags);
+
+			/*
+			 *  Call the m2m start function.  Only start one channel.
+			 */
+			return(dma_start_m2m(channel, &dma_chan[channel]));
+		}
+
+		/*
+		 *  Make sure the channel has at least one buffer in the queue.
+		 */
+		if (dma_chan[channel].new_buffers < 1) {
+			DPRINTK("DMA Start: Channel starved.\n");
+
+			/*
+			 *  This channel does not have enough buffers queued up,
+			 *  so enter the pause by starvation state.
+			 */
+			dma_chan[channel].xfer_enable = TRUE;
+			dma_chan[channel].pause = TRUE;
+
+			/*
+			 *  Unmask irqs
+			 */
+			local_irq_restore(flags);
+
+			/*
+			 *  Success.
+			 */
+			return(0);
+		}
+
+		/*
+		 *  Set up a dma instance pointer for this dma channel.
+		 */
+		dma_pointers[0] = &dma_chan[channel];
+
+		/*
+		 * Set up a pointer to the register set for this channel.
+		 */
+		M2P_reg_bases[0] = dma_pointers[0]->reg_base;
+	}
+
+	/*
+	 *  Setup both MAXCNT registers with values from the next two buffers
+	 *  in the queue, and enable the next frame buffer interrupt on the channel.
+	 */
+	for (loop = 0; loop < channels; loop++) {
+		/*
+		 *  Check if we need to restore a paused transfer.
+		 */
+		if (dma_pointers[loop]->pause_buf.buf_id != -1)
+			outl( dma_pointers[loop]->pause_buf.size,
+			      M2P_reg_bases[loop]+M2P_OFFSET_MAXCNT0 );
+		else
+			outl( dma_pointers[loop]->buffer_queue[dma_pointers[loop]->current_buffer].size,
+			      M2P_reg_bases[loop]+M2P_OFFSET_MAXCNT0 );
+	}
+
+	for (loop = 0; loop < channels; loop++) {
+		/*
+		 *  Enable the specified dma channels.
+		 */
+		uiCONTROL = inl(M2P_reg_bases[loop]+M2P_OFFSET_CONTROL);
+		uiCONTROL |= CONTROL_M2P_ENABLE;
+		outl( uiCONTROL, M2P_reg_bases[loop]+M2P_OFFSET_CONTROL );
+
+		/*
+		 *  Update the dma channel instance transfer state.
+		 */
+		dma_pointers[loop]->xfer_enable = TRUE;
+		dma_pointers[loop]->pause = FALSE;
+	}
+
+	/*
+	 *  Program up the BASE0 registers for all specified channels, this
+	 *  will initiate transfers on all specified channels.
+	 */
+	for (loop = 0; loop < channels; loop++)
+		/*
+		 *  Check if we need to restore a paused transfer.
+		 */
+		if (dma_pointers[loop]->pause_buf.buf_id != -1) {
+			outl( dma_pointers[loop]->pause_buf.source,
+			      M2P_reg_bases[loop]+M2P_OFFSET_BASE0 );
+
+			/*
+			 *  Set the pause buffer to NULL
+			 */
+			dma_pointers[loop]->pause_buf.buf_id = -1;
+			dma_pointers[loop]->pause_buf.size = 0;
+		} else if(dma_pointers[loop]->new_buffers){
+			outl( dma_pointers[loop]->buffer_queue[
+				  dma_pointers[loop]->current_buffer].source,
+			      M2P_reg_bases[loop]+M2P_OFFSET_BASE0 );
+            dma_pointers[loop]->new_buffers--;
+            
+          }
+
+	/*
+	 *  Before restoring irqs setup the second MAXCNT/BASE
+	 *  register with a second buffer.
+	 */
+	for (loop = 0; loop < channels; loop++)
+		if (dma_pointers[loop]->new_buffers) {
+        	/*
+        	 *  By default we enable the next frame buffer interrupt.
+        	 */
+        	uiCONTROL = inl(M2P_reg_bases[loop]+M2P_OFFSET_CONTROL);
+        	uiCONTROL |= CONTROL_M2P_NFBINTEN;
+        	outl( uiCONTROL, M2P_reg_bases[loop]+M2P_OFFSET_CONTROL );
+
+			outl( dma_pointers[loop]->buffer_queue[
+				  (dma_pointers[loop]->current_buffer + 1) %
+				  MAX_EP93XX_DMA_BUFFERS].size,
+			      M2P_reg_bases[loop]+M2P_OFFSET_MAXCNT1 );
+
+			outl( dma_pointers[loop]->buffer_queue[
+				  (dma_pointers[loop]->current_buffer + 1) %
+				  MAX_EP93XX_DMA_BUFFERS].source,
+			      M2P_reg_bases[loop]+M2P_OFFSET_BASE1 );
+            dma_pointers[loop]->new_buffers--;
+		}
+
+	/*
+	  DPRINTK("DMA - It's been started!!");
+	  DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+	  DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+	  DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+	  DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+	  DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+	  DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+	  DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+	  DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+	  DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+	  DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+	  DPRINTK("Pause - %d \n", dma_pointers[0]->pause);
+	  DPRINTK("xfer_enable - %d \n", dma_pointers[0]->xfer_enable);
+	  DPRINTK("total bytes - 0x%x \n", dma_pointers[0]->total_bytes);
+	  DPRINTK("total buffer - %d \n", dma_pointers[0]->total_buffers);
+	  DPRINTK("new buffers - %d \n", dma_pointers[0]->new_buffers);
+	  DPRINTK("current buffer - %d \n", dma_pointers[0]->current_buffer);
+	  DPRINTK("last buffer - %d \n", dma_pointers[0]->last_buffer);
+	  DPRINTK("used buffers - %d \n", dma_pointers[0]->used_buffers);
+	*/
+	/*
+	 *  Unmask irqs
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_add_buffer(int handle, unsigned int * address,
+ *						 unsigned int size, unsigned int last)
+ *
+ *  Description: Add a buffer entry to the DMA buffer queue.
+ *
+ *  handle:	 handle for the channel to add this buffer to.
+ *  address:	Pointer to an integer which is the start address of the
+ *			  buffer which is to be added to the queue.
+ *  size:	   size of the buffer in bytes.
+ *  last:	   1 if this is the last buffer in this stream, 0 otherwise.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_add_buffer(int handle, unsigned int source, unsigned int dest,
+		      unsigned int size, unsigned int last,
+		      unsigned int buf_id)
+{
+	unsigned long flags;
+	ep93xx_dma_t * dma;
+	int  channel;
+#if 0
+	static int peak_total_buffers=0;
+#endif
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR
+			   "DMA Add Buffer: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	/*
+	 *  Get a pointer to the dma instance.
+	 */
+	dma = &dma_chan[channel];
+
+#if 0	
+	if( dma->total_buffers > peak_total_buffers )
+	{
+	    peak_total_buffers=dma->total_buffers;
+	    printk("peak_total_buffers=%d\n", peak_total_buffers );
+	}
+#endif
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  If the buffer queue is full, last_buffer is the same as current_buffer and
+	 *  we're not tranfering, or last_buffer is pointing to a used buffer, then exit.
+	 *  TODO: do I need to do any more checks?
+	 */
+	if (dma->total_buffers >= MAX_EP93XX_DMA_BUFFERS) 
+	{
+		DPRINTK("too many dma buffers: MAX_EP93XX_DMA_BUFFERS set to low ?\n");
+		/*
+		 *  Restore the state of the irqs
+		 */
+		local_irq_restore(flags);
+
+		/*
+		 *  Fail.
+		 */
+		return(-1);
+	}
+
+	/*
+	 *  Add this buffer to the queue
+	 */
+	dma->buffer_queue[dma->last_buffer].source = source;
+	dma->buffer_queue[dma->last_buffer].dest = dest;
+	dma->buffer_queue[dma->last_buffer].size = size;
+	dma->buffer_queue[dma->last_buffer].last = last;
+	dma->buffer_queue[dma->last_buffer].buf_id = buf_id;
+
+	/*
+	 *  Reset the used field of the buffer structure.
+	 */
+	dma->buffer_queue[dma->last_buffer].used = FALSE;
+
+	/*
+	 *  Increment the End Item Pointer.
+	 */
+	dma->last_buffer = (dma->last_buffer + 1) % MAX_EP93XX_DMA_BUFFERS;
+
+	/*
+	 *  Increment the new buffers counter and the total buffers counter
+	 */
+	dma->new_buffers++;
+	dma->total_buffers++;
+
+	/*
+	 *  restore the interrupt state.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Check if the channel was starved into a stopped state.
+	 */
+	if (dma->pause && dma->xfer_enable) {
+		if (dma->new_buffers >= 1) {
+			DPRINTK("DMA - calling start from add after starve. \n");
+
+			/*
+			 *  The channel was starved into a stopped state, and we've got
+			 *  2 new buffers, so start tranferring again.
+			 */
+			ep93xx_dma_start(handle, 1, 0);
+		}
+	}
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_remove_buffer(int handle, unsigned int * address,
+ *								unsigned int * size)
+ *
+ *  Description: Remove a buffer entry from the DMA buffer queue. If
+ *			   buffer was removed successfully, return 0, otherwise
+ *			   return -1.
+ *
+ *  handle:	 handle for the channel to remove a buffer from.
+ *  address:	Pointer to an integer which is filled in with the start
+ *			  address of the removed buffer.
+ *  size:	   Pointer to an integer which is filled in with the size in
+ *			  bytes of the removed buffer.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_remove_buffer(int handle, unsigned int * buf_id)
+{
+	unsigned int test;
+	unsigned int loop;
+	int return_val = -1;
+	unsigned long flags;
+	ep93xx_dma_t *dma;
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR
+			   "DMA Remove Buffer: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Make sure there are used buffers to be returned.
+	 */
+	if (dma->used_buffers) {
+		test = dma->last_buffer;
+
+		for (loop = 0; loop < MAX_EP93XX_DMA_BUFFERS; loop++) {
+			if (dma->buffer_queue[test].used && (dma->buffer_queue[test].buf_id != -1)) {
+				/*DPRINTK("buffer %d used \n", test); */
+
+				/*
+				 *  This is a used buffer, fill in the buf_id pointer
+				 *  with the buf_id for this buffer.
+				 */
+				*buf_id = dma->buffer_queue[test].buf_id;
+
+				/*
+				 *  Reset this buffer structure
+				 */
+				dma->buffer_queue[test].buf_id = -1;
+
+				/*
+				 *  Decrement the used buffer counter, and the total buffer counter.
+				 */
+				dma->used_buffers--;
+				dma->total_buffers--;
+
+				/*
+				 *  Successful removal of a buffer, so set the return
+				 *  value to 0, then exit this loop.
+				 */
+				return_val = 0;
+				break;
+			}
+
+			/*
+			 *  This buffer isn't used, let's see if the next one is.
+			 */
+			test = (test + 1) % MAX_EP93XX_DMA_BUFFERS;
+		}
+	}
+
+	/*
+	 *  Restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(return_val);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_pause(int handle, unsigned int channels,
+ *					   unsigned int * handles)
+ *
+ *  Description: Disable any ongoing transfer for the given channel, retaining
+ *			   the state of the current buffer transaction so that upon
+ *			   resume, the dma will continue where it left off.
+ *
+ *  handle:	 Handle for the channel to be paused.  If this is a pause for
+ *			  for multiple channels, handle is a valid handle for one of
+ *			  the channels to be paused.
+ *  channels:   number of channel to pause transfers on.
+ *  handles:	Pointer to an array of handles, one for each channel which
+ *			  to be paused.  If this pause is intended only for one
+ *			  channel, this field should be set to NULL.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_pause(int handle, unsigned int channels, unsigned int * handles)
+{
+	unsigned long flags;
+	ep93xx_dma_t * dma;
+	int channel;
+
+	DPRINTK("ep93xx_dma_pause \n");
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		/*
+		 *  restore interrupts.
+		 */
+		local_irq_restore(flags);
+
+		printk(KERN_ERR
+			   "DMA Pause: Invalid dma handle.\n");
+
+		/*
+		 *  Fail.
+		 */
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: pause \n", channel);
+
+	/*
+	 *  Set up a pointer to the dma instance data.
+	 */
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Check if we're already paused.
+	 */
+	if (dma->pause) {
+		/*
+		 *  We're paused, but are we stopped?
+		 */
+		if (dma->xfer_enable)
+			/*
+			 *  Put the channel in the stopped state.
+			 */
+			dma->xfer_enable = FALSE;
+
+		DPRINTK("DMA Pause - already paused.");
+	} else {
+		/*
+		 *  Put the channel into the stopped state.
+		 */
+		dma->xfer_enable = FALSE;
+		dma->pause = TRUE;
+	}
+
+	/*
+	 *  restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Already paused, so exit.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  void ep93xx_dma_flush(int handle)
+ *
+ *  Description: Flushes all queued buffers and transfers in progress
+ *			   for the given channel.  Return the buffer entries
+ *			   to the calling function.
+ *
+ *  handle:	 handle for the channel for which the flush is intended.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_flush(int handle)
+{
+	unsigned int loop;
+	unsigned long flags;
+	ep93xx_dma_t * dma;
+	int  channel;
+	unsigned int M2P_reg_base,uiCONTROL;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Flush: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: flush \n", channel);
+
+	/*
+	 *  Set up a pointer to the dma instance data for this channel
+	 */
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Disable the dma channel
+	 */
+	if (channel < 10) {
+		/*
+		 *  M2P channel
+		 */
+		uiCONTROL = inl(dma->reg_base+M2P_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2P_ENABLE;
+		outl( uiCONTROL, dma->reg_base+M2P_OFFSET_CONTROL );
+	} else {
+		/*
+		 *  M2M channel
+		 */
+		uiCONTROL = inl(dma->reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, dma->reg_base+M2M_OFFSET_CONTROL );
+	}
+
+	for (loop = 0; loop < MAX_EP93XX_DMA_BUFFERS; loop++)
+	{
+		dma->buffer_queue[loop].buf_id = -1;
+		dma->buffer_queue[loop].last = 0;
+	}
+
+	/*
+	 *  Set the Current and Last item to zero.
+	 */
+	dma->current_buffer = 0;
+	dma->last_buffer = 0;
+
+	/*
+	 *  Reset the Buffer counters
+	 */
+	dma->used_buffers = 0;
+	dma->new_buffers = 0;
+	dma->total_buffers = 0;
+
+	/*
+	 *  reset the Total bytes counter.
+	 */
+	dma->total_bytes = 0;
+
+    /*
+     * Reset the paused buffer.
+     */
+     dma->pause_buf.last = 0;
+     dma->pause_buf.buf_id = -1;
+
+	M2P_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_queue_full(int handle)
+ *
+ *  Description: Query to determine if the DMA queue of buffers for
+ *			  a given channel is full.
+ *			  0 = queue is full
+ *			  1 = queue is not full
+ *
+ *  handle:	 handle for the channel to query.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_queue_full(int handle)
+{
+	int list_full = 0;
+	unsigned long flags;
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Queue Full: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: queue full \n", channel);
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  If the last item is equal to the used item then
+	 *  the queue is full.
+	 */
+	if (dma_chan[channel].total_buffers < MAX_EP93XX_DMA_BUFFERS)
+		list_full =  FALSE;
+	else
+		list_full = TRUE;
+
+	/*
+	 *  restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	return(list_full);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_get_position()
+ *
+ *  Description:  Takes two integer pointers and fills them with the start
+ *                and current address of the buffer currently transferring
+ *                on the specified DMA channel.
+ *
+ *  handle         handle for the channel to query.
+ *  *buf_id        buffer id for the current buffer transferring on the
+ *                 dma channel.
+ *  *total         total bytes transferred on the channel.  Only counts  
+ *                 whole buffers transferred.
+ *  *current_frac  number of bytes transferred so far in the current buffer.
+ ****************************************************************************/
+int
+ep93xx_dma_get_position(int handle, unsigned int * buf_id,
+                        unsigned int * total, unsigned int * current_frac )
+{
+	int  channel;
+	ep93xx_dma_t * dma;
+	unsigned int buf_id1, total1, current_frac1, buf_id2, total2;
+	unsigned int Status, NextBuffer, StateIsBufNext, M2P_reg_base=0;
+	unsigned int pause1, pause2;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.  See if this is a 
+	 *  valid handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Get Position: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	dma = &dma_chan[channel];
+
+	/*
+	 * If DMA moves to a new buffer in the middle of us grabbing the 
+	 * buffer info, then do it over again.
+	 */
+	do{
+		buf_id1 = dma->buffer_queue[dma->current_buffer].buf_id;
+		total1  = dma->total_bytes;
+		pause1  = dma->pause;
+
+		if (channel < 10) {
+			// M2P
+			M2P_reg_base = dma->reg_base;
+
+			Status = inl(M2P_reg_base+M2P_OFFSET_STATUS);
+
+			NextBuffer = ((Status & STATUS_M2P_NEXTBUFFER) != 0);
+
+			StateIsBufNext = ((Status & STATUS_M2P_CURRENT_MASK) == 
+			                  STATUS_M2P_DMA_BUF_NEXT);
+			
+			if( NextBuffer ^ StateIsBufNext )
+				current_frac1 = inl(M2P_reg_base+M2P_OFFSET_CURRENT1) -
+				                inl(M2P_reg_base+M2P_OFFSET_BASE1);	
+			else
+				current_frac1 = inl(M2P_reg_base+M2P_OFFSET_CURRENT0) -
+				                inl(M2P_reg_base+M2P_OFFSET_BASE0);	
+			
+		} else { 
+			// M2M - TODO implement this for M2M
+			current_frac1 = 0;
+		}
+		
+		buf_id2 = dma->buffer_queue[dma->current_buffer].buf_id;
+		total2 = dma->total_bytes;
+		pause2  = dma->pause;
+
+	} while ( (buf_id1 != buf_id2) || (total1 != total2) || (pause1 != pause2) );
+
+	if (pause1)
+		current_frac1 = 0;
+
+	if (buf_id)
+		*buf_id = buf_id1;
+
+	if (total)
+		*total  = total1;
+
+	if (current_frac)
+		*current_frac = current_frac1;
+	
+//	DPRINTK("DMA buf_id %d, total %d, frac %d\n", buf_id1, total1, current_frac1);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_get_total(int handle)
+ *
+ *  Description:	Returns the total number of bytes transferred on the
+ *			specified channel since the channel was requested.
+ *
+ *  handle:	 handle for the channel to query.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_get_total(int handle)
+{
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Get Total: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: total: %d \n", channel, dma_chan[channel].total_bytes);
+
+	/*
+	 *  Return the total number of bytes transferred on this channel since
+	 *  it was requested.
+	 */
+	return(dma_chan[channel].total_bytes);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_is_done(int handle)
+ *
+ *  Description:	Determines if the specified channel is done
+ *			transferring the requested data.
+ *
+ *  handle:	 handle for the channel to query.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_is_done(int handle)
+{
+	ep93xx_dma_t *dma;
+	int channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "ep93xx_dma_is_done: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+        /*
+         * Get a pointer to the DMA channel state structure.
+         */
+        dma = &dma_chan[channel];
+
+        /*
+         * See if there are any buffers remaining to be provided to the HW.
+         */
+        if (dma->new_buffers)
+            return 0;
+
+        /*
+         * See if this is a M2P or M2M channel.
+         */
+        if (channel < 10) {
+            /*
+             * If the bytes remaining register of the HW is not zero, then
+             * there is more work to be done.
+             */
+            if (inl(dma->reg_base + M2P_OFFSET_REMAIN) != 0)
+                return 0;
+        } else {
+            /*
+             * If either byte count register in the HW is not zero, then there
+             * is more work to be done.
+             */
+            if ((inl(dma->reg_base + M2M_OFFSET_BCR0) != 0) ||
+                (inl(dma->reg_base + M2M_OFFSET_BCR1) != 0))
+                return 0;
+        }
+
+        /*
+         * The DMA is complete.
+         */
+        return 1;
+}
+
+/*****************************************************************************
+ * ep93xx_dma_request
+ *
+ * Description: This function will allocate a DMA channel for a particular
+ * hardware peripheral.  Before initiating a transfer on the allocated
+ * channel, the channel must be set up and buffers have to queued up.
+ *
+ *  handle:	 pointer to an integer which is filled in with a unique
+ *			  handle for this instance of the dma interface.
+ *  device_id   string with the device name, primarily used by /proc.
+ *  device	  hardware device ID for which the requested dma channel will
+ *			  transfer data.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_request(int * handle, const char *device_id,
+				   ep93xx_dma_dev_t device)
+{
+	ep93xx_dma_t *dma = NULL;
+	int channel;
+	unsigned int error = 0;
+	unsigned int loop;
+	unsigned int M2P_reg_base;
+
+	/*
+	 *  Check if the device requesting a DMA channel is a valid device.
+	 */
+	if ((device >= UNDEF) || (device < 0))
+		return(-ENODEV);
+
+	/*
+	 *  We've got a valid hardware device requesting a DMA channel.
+	 *  Now check if the device should open an M2P or M2M channel
+	 */
+	if (device < 20)
+		channel = dma_open_m2p(device);
+	else
+		channel = dma_open_m2m(device);
+
+	/*
+	 *  Check if we successfully opened a DMA channel
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "%s: Could not open dma channel for this device.\n",
+			   device_id);
+		return(-EBUSY);
+	}
+
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Request the appropriate IRQ for the specified channel
+	 */
+	if (channel < 10)
+		error = request_irq(dma->irq, dma_m2p_irq_handler,
+				    IRQF_DISABLED, device_id, (void *) dma);
+	else
+		error = request_irq(dma->irq, &dma_m2m_irq_handler,
+				    IRQF_DISABLED, device_id, (void *) dma);
+	/*
+	 *  Check for any errors during the irq request
+	 */
+	if (error) {
+		printk(KERN_ERR "%s: unable to request IRQ %d for DMA channel\n",
+			   device_id, dma->irq);
+		return(error);
+	}
+
+	/*
+	 *  Generate a valid handle and exit.
+	 *
+	 *  Increment the last valid handle.
+	 *  Check for wraparound (unlikely, but we like to be complete).
+	 */
+	dma->last_valid_handle++;
+
+	if ( (dma->last_valid_handle & DMA_HANDLE_SPECIFIER_MASK) !=
+	     (channel << 28) )
+		dma->last_valid_handle = (channel << 28) + 1;
+
+	/*
+	 *  Fill in the handle pointer with a valid handle for
+	 *  this dma channel instance.
+	 */
+	*handle = dma->last_valid_handle;
+
+	DPRINTK("Handle for channel %d: 0x%x\n", channel, *handle);
+
+	/*
+	 * Save the device ID and device name.
+	 */
+	dma->device = device;
+	dma->device_id = device_id;
+
+	/*
+	 *  Init all fields within the dma instance.
+	 */
+	for (loop = 0; loop < MAX_EP93XX_DMA_BUFFERS; loop++)
+		dma->buffer_queue[loop].buf_id = -1;
+
+	/*
+	 *  Initialize all buffer queue variables.
+	 */
+	dma->current_buffer = 0;
+	dma->last_buffer = 0;
+
+	dma->new_buffers = 0;
+	dma->used_buffers = 0;
+	dma->total_buffers = 0;
+
+	/*
+	 *  Initialize the total bytes variable
+	 */
+	dma->total_bytes = 0;
+
+	/*
+	 *  Initialize the transfer and pause state variables to 0.
+	 */
+	dma->xfer_enable = 0;
+
+	dma->pause = 0;
+
+	/*
+	 *  Initialize the pause buffer structure.
+	 */
+	dma->pause_buf.buf_id = -1;
+
+	/*
+	 *  Initialize the callback function and user data fields.
+	 */
+	dma->callback = NULL;
+
+	/*
+	 * User data used as a parameter for the Callback function.  The user
+	 * sets up the data and sends it with the callback function.
+	 */
+	dma->user_data = 0;
+
+	M2P_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  Debugging message.
+	 */
+	DPRINTK("Successfully requested dma channel %d\n", channel);
+	DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+	DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+	DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+	DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+	DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+	DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+	DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+	DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+	DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+	DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+	DPRINTK("Buffer	source	   size	   last	   used \n");
+	for (loop = 0; loop < 5; loop ++)
+		DPRINTK("%d		0x%x		 0x%x		%d		 %d \n",
+			loop, dma->buffer_queue[loop].source, dma->buffer_queue[loop].size,
+			dma->buffer_queue[loop].last, dma->buffer_queue[loop].used);
+	DPRINTK("pause	 0x%x		 0x%x		%d		 %d \n",
+		dma->pause_buf.source, dma->pause_buf.size,
+		dma->pause_buf.last, dma->pause_buf.used);
+
+	DPRINTK("Pause - %d \n", dma->pause);
+	DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+	DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+	DPRINTK("total buffer - %d \n", dma->total_buffers);
+	DPRINTK("new buffers - %d \n", dma->new_buffers);
+	DPRINTK("current buffer - %d \n", dma->current_buffer);
+	DPRINTK("last buffer - %d \n", dma->last_buffer);
+	DPRINTK("used buffers - %d \n", dma->used_buffers);
+
+	DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+	DPRINTK("VIC0IRQSTATUS - 0x%x, VIC0INTENABLE - 0x%x \n",
+		*(unsigned int *)(VIC0IRQSTATUS),
+		*(unsigned int *)(VIC0INTENABLE));
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ * ep93xx_dma_free
+ *
+ * Description: This function will free the dma channel for future requests.
+ *
+ *  handle:	 handle for the channel to be freed.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_free(int handle)
+{
+	ep93xx_dma_t *dma;
+	unsigned int M2M_reg_base, M2P_reg_base, uiCONTROL;
+	int channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Free: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	/*
+	 *  Get a pointer to the dma instance.
+	 */
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Disable the dma channel
+	 */
+	if (channel < 10) {
+		/*
+		 *  M2P channel
+		 */
+		M2P_reg_base = dma->reg_base;
+
+		uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2P_ENABLE;
+		outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+	} else {
+		/*
+		 *  M2M channel
+		 */
+		M2M_reg_base = dma->reg_base;
+
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	}
+
+	/*
+	 *  Free the interrupt servicing this dma channel
+	 */
+
+	free_irq(dma->irq, (void *) dma);
+
+	/*
+	 *  Decrement the reference count for this instance of the dma interface
+	 */
+	dma->ref_count--;
+
+	/*
+	 *  Set the transfer and pause state variables to 0
+	 *  (unititialized state).
+	 */
+	dma->xfer_enable = 0;
+	dma->pause = 0;
+
+	/*
+	 *  Debugging message.
+	 */
+	DPRINTK("Successfully freed dma channel %d\n", channel);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ * ep93xx_dma_init(void)
+ *
+ * Description: This function is called during system initialization to
+ * setup the interrupt number and register set base address for each DMA
+ * channel.
+ *
+ ****************************************************************************/
+static int __init
+ep93xx_dma_init(void)
+{
+	int channel;
+
+	/*
+	 * Init some values in each dma instance.
+	 */
+	for (channel = 0; channel < MAX_EP93XX_DMA_CHANNELS; channel++) {
+		/*
+		 *  IRQ for the specified dma channel.
+		 */
+		dma_chan[channel].irq = IRQ_EP93XX_DMAM2P0 + channel;
+
+		/*
+		 *  Initial value of the dma channel handle.
+		 */
+		dma_chan[channel].last_valid_handle = channel << 28;
+
+		/*
+		 *  Give the instance a pointer to the dma channel register
+		 *  base.
+		 */
+		if (channel < 10)
+			dma_chan[channel].reg_base = DMAM2PChannelBase[channel];
+		else
+			dma_chan[channel].reg_base = DMAM2MChannelBase[channel - 10];
+
+		/*
+		 *  Initialize the reference count for this channel.
+		 */
+		dma_chan[channel].ref_count = 0;
+	}
+
+	DPRINTK("DMA Interface intitialization complete\n");
+
+	/*
+	 * Success
+	 */
+	return 0;
+}
+
+arch_initcall(ep93xx_dma_init);
+
+EXPORT_SYMBOL(ep93xx_dma_free);
+EXPORT_SYMBOL(ep93xx_dma_request);
+EXPORT_SYMBOL(ep93xx_dma_flush);
+EXPORT_SYMBOL(ep93xx_dma_pause);
+EXPORT_SYMBOL(ep93xx_dma_remove_buffer);
+EXPORT_SYMBOL(ep93xx_dma_add_buffer);
+EXPORT_SYMBOL(ep93xx_dma_start);
+EXPORT_SYMBOL(ep93xx_dma_config);
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/dma_ep93xx.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/dma_ep93xx.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/dma_ep93xx.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/dma_ep93xx.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,199 @@
+/*****************************************************************************
+ *
+ * arch/arm/mach-ep93xx/dma_ep93xx.h
+ *
+ * DESCRIPTION:    93XX DMA controller API private defintions.
+ *
+ * Copyright Cirrus Logic Corporation, 2003.  All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#ifndef _EP93XX_DMA_H_
+#define _EP93XX_DMA_H_
+
+// as it turns out the ide dma is the biggest dma buffer hog so far
+// in case the HDD is "thinking" (seek/buffer flush)
+// the continueing r/w DMAs to the HDD will be queued up to up to PRD_ENTRIES entries...
+#include <linux/ide.h>
+#define MAX_EP93XX_DMA_BUFFERS      PRD_ENTRIES
+
+#ifndef TRUE
+#define TRUE                        1
+#endif
+
+#ifndef FALSE
+#define FALSE                       0
+#endif
+
+#ifndef NULL
+#define NULL                        0
+#endif
+
+/*****************************************************************************
+ *
+ * DMA buffer structure type.
+ *
+ ****************************************************************************/
+typedef struct ep93xx_dma_buffer_s
+{
+    unsigned int    source;     /* buffer physical source address.          */
+    unsigned int    dest;       /* buffer physical destination address,     */
+                                /* only used with the 2 M2M channels.       */
+    unsigned int    size;       /* buffer size in bytes                     */
+    unsigned int    last;       /* 1 if this is the last buffer             */
+                                /* in this transaction.  If 1,              */
+                                /* disable the NFBint so we aren't          */
+                                /* interrupted for another buffer           */
+                                /* when we know there won't be another.     */
+    unsigned int    used;       /* This field is set to 1 by the DMA        */
+                                /* interface after the buffer is transferred*/
+    int    buf_id;              /* unique identifyer specified by the       */
+                                /* the driver which requested the dma       */
+} ep93xx_dma_buffer_t;
+
+typedef ep93xx_dma_buffer_t * ep93xx_dma_buffer_p;
+
+/*****************************************************************************
+ *
+ * Instance definition for the DMA interface.
+ *
+ ****************************************************************************/
+typedef struct ep9312_dma_s
+{
+    /*
+     *  This 1 when the instance is in use, and 0 when it's not.
+     */
+    unsigned int ref_count;
+
+    /*
+     * This is the last valid handle for this instance.  When giving out a
+     * new handle this will be incremented and given out.
+     */
+    int last_valid_handle;
+
+    /*
+     * device specifies one of the 20 DMA hardware ports this 
+     * DMA channel will service.
+     */
+    ep93xx_dma_dev_t device;
+
+    /*
+     * DMABufferQueue is the queue of buffer structure pointers which the
+     * dma channel will use to setup transfers.
+     */
+    ep93xx_dma_buffer_t buffer_queue[MAX_EP93XX_DMA_BUFFERS];
+
+    /*
+     * currnt_buffer : This is the buffer currently being transfered on 
+     *                 this channel.
+     * last_buffer : This is the last buffer for this transfer.
+     * Note: current_buffer + 1 is already programmed into the dma
+     *       channel as the next buffer to transfer. Don't write
+     *       over either entry.
+     */
+    int current_buffer;
+    int last_buffer;
+
+    /*
+     * The following 3 fields are buffer counters.
+     *
+     * iNewBuffers: Buffers in the queue which have not been transfered.
+     * iUsedBuffers: Buffers in the queue which have have been tranferred,
+     *               and are waiting to be returned.
+     * iTotalBuffers: Total number of buffers in the queue.
+     */  
+    int new_buffers;
+    int used_buffers;
+    int total_buffers;
+
+    /*
+     * uiTotalBytes has the total bytes transfered on the channel since the
+     * last flush.  This value does not include the bytes tranfered in the
+     * current buffer.  A byte count is only added after a complete buffer
+     * is tranfered. 
+     */
+    unsigned int total_bytes;
+
+    /*
+     *  Interrupt number for this channel
+     */
+    unsigned int irq;
+
+    /*
+     * Indicates whether or not the channel is currently enabled to transfer
+     * data.
+     */
+    unsigned int xfer_enable;
+    
+    /*
+     * pause indicates if the dma channel was paused by calling the pause
+     * ioctl.
+     */
+    unsigned int pause;
+    
+    /*
+     *  buffer structure used during a pause to capture the current
+     *  address and remaining bytes for the buffer actively being transferred
+     *  on the channel. This buffer will be used to reprogram the dma 
+     *  channel upon a resume.
+     */
+    ep93xx_dma_buffer_t pause_buf;
+    
+    /*
+     * DMACallback is a function pointer which the calling application can 
+     * use install a function to.  this fuction can be used to notify the 
+     * calling application of an interrupt.
+     */
+    dma_callback callback;
+
+    /*
+     * User data used as a parameter for the Callback function.  The user
+     * sets up the data and sends it with the callback function.
+     */
+    unsigned int user_data;
+    
+    /*
+     * A string representation of the device attached to the channel.
+     */
+    const char * device_id;
+    
+    /*
+     * The register base address for this dma channel.
+     */
+    unsigned int reg_base;
+    
+} ep93xx_dma_t;
+
+/*****************************************************************************
+ *
+ * DMA macros
+ *
+ ****************************************************************************/
+#define DMA_HANDLE_SPECIFIER_MASK   0xF0000000
+#define DMA_CH0_HANDLE_SPECIFIER    0x00000000
+#define DMA_CH1_HANDLE_SPECIFIER    0x10000000
+#define DMA_CH2_HANDLE_SPECIFIER    0x20000000
+#define DMA_CH3_HANDLE_SPECIFIER    0x30000000
+#define DMA_CH4_HANDLE_SPECIFIER    0x40000000
+#define DMA_CH5_HANDLE_SPECIFIER    0x50000000
+#define DMA_CH6_HANDLE_SPECIFIER    0x60000000
+#define DMA_CH7_HANDLE_SPECIFIER    0x70000000
+#define DMA_CH8_HANDLE_SPECIFIER    0x80000000
+#define DMA_CH9_HANDLE_SPECIFIER    0x90000000
+#define DMA_CH10_HANDLE_SPECIFIER   0xA0000000
+#define DMA_CH11_HANDLE_SPECIFIER   0xB0000000
+
+#endif // _DMADRV_H_
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/dma.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/dma.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/dma.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/dma.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,246 @@
+/*****************************************************************************
+ * linux/arch/arm/mach-ep93xx/include/mach/dma.h
+ *
+ *  Copyright (C) 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS     0xffffffff
+
+/*
+ *  Not using the regular generic DMA interface for ep93xx.
+ */
+#define MAX_DMA_CHANNELS   0
+
+/*
+ * The ep93xx dma controller has 5 memory to peripheral (TX) channels, 5
+ * peripheral to memory (RX) channels and 2 memory to memory channels.
+ */
+#define MAX_EP93XX_DMA_M2P_CHANNELS 10
+#define MAX_EP93XX_DMA_M2M_CHANNELS 2
+
+/*
+ * The generic arm linux api does not support the ep93xx dma model, therefore
+ * we use a set of dma support functions written specifically for this dma
+ * controller.
+ */
+#define MAX_EP93XX_DMA_CHANNELS (MAX_EP93XX_DMA_M2P_CHANNELS + MAX_EP93XX_DMA_M2M_CHANNELS)
+
+/*****************************************************************************
+ *
+ * Max DMA buffer size
+ *
+ ****************************************************************************/
+#define DMA_MAX_BUFFER_BYTES    0xFFFF
+
+/*****************************************************************************
+ *
+ * typedefs
+ *
+ ****************************************************************************/
+
+/*****************************************************************************
+ *
+ * All devices which can use a DMA channel
+ *
+ * NOTE: There exist two types of DMA channels, those that transfer
+ *       between an internal peripheral and memory (M2P/P2M), and
+ *       those that transfer between an external peripheral and memory (M2M).
+ *       This becomes a bit confusing when you take into account the fact
+ *       that the M2M channels can also transfer between two specific
+ *       internal peripherals and memory.
+ *       The first 20 enumerated devices use the first type of channel (M2P/
+ *       P2M).  The last six enumerations are specific to the M2M channels.
+ *
+ ****************************************************************************/
+typedef enum
+{
+    /*
+     *  Hardware device options for the 10 M2P/P2M DMA channels.
+     */
+    DMATx_I2S1 = 0x00000000,    /* TX peripheral ports can be allocated an  */
+    DMATx_I2S2 = 0x00000001,    /* even numbered DMA channel.               */
+    DMATx_AAC1 = 0x00000002,
+    DMATx_AAC2 = 0x00000003,
+    DMATx_AAC3 = 0x00000004,
+    DMATx_I2S3 = 0x00000005,
+    DMATx_UART1 = 0x00000006,
+    DMATx_UART2 = 0x00000007,
+    DMATx_UART3 = 0x00000008,
+    DMATx_IRDA = 0x00000009,
+    DMARx_I2S1 = 0x0000000A,    /* RX perhipheral ports can be allocated an */
+    DMARx_I2S2 = 0x0000000B,    /* odd numbered DMA channel.                */
+    DMARx_AAC1 = 0x0000000C,
+    DMARx_AAC2 = 0x0000000D,
+    DMARx_AAC3 = 0x0000000E,
+    DMARx_I2S3 = 0x0000000F,
+    DMARx_UART1 = 0x00000010,
+    DMARx_UART2 = 0x00000011,
+    DMARx_UART3 = 0x00000012,
+    DMARx_IRDA = 0x00000013,
+
+    /*
+     *  Device options for the 2 M2M DMA channels
+     */
+    DMA_MEMORY = 0x00000014,
+    DMA_IDE = 0x00000015,
+    DMARx_SSP = 0x00000016,
+    DMATx_SSP = 0x00000017,
+    DMATx_EXT_DREQ = 0x00000018,
+    DMARx_EXT_DREQ = 0x00000019,
+    UNDEF = 0x0000001A
+} ep93xx_dma_dev_t;
+
+/*****************************************************************************
+ *
+ * Enumerated type used as a parameter for a callback function.
+ * Indicates the type of interrupt.
+ *
+ ****************************************************************************/
+typedef enum
+{
+    /*
+     *  Common interrupts
+     */
+    STALL,
+    NFB,
+
+    /*
+     *  Specific to M2P channels
+     */
+    CHERROR,
+
+    /*
+     *  Specific to M2M channels
+     */
+    DONE,
+    UNDEF_INT
+} ep93xx_dma_int_t;
+
+/*****************************************************************************
+ *
+ * Init flag bit defintions for M2P/P2M flags.
+ *
+ ****************************************************************************/
+
+/*
+ *  Channel error interrupt enable.
+ */
+#define CHANNEL_ERROR_INT_ENABLE    0x00000001
+
+/*
+ *  Determines how the channel state machine behaves in the NEXT state and
+ *  in receipt of a peripheral error.
+ *  0 -> NEXT -> ON (ignore the peripheral error.)
+ *  1 -> NEXT -> STALL (effectively disable the channel.)
+ */
+#define CHANNEL_ABORT               0x00000002
+
+/*
+ *  Ignore channel error interrupt.
+ */
+#define IGNORE_CHANNEL_ERROR        0x00000004
+
+/*****************************************************************************
+ *
+ * Init flag bit defintions for M2M flags.
+ *
+ ****************************************************************************/
+
+/*
+ *  Destination address hold.  This should be set for IDE write transfers
+ */
+#define DESTINATION_HOLD            0x0000001
+
+/*
+ *  Source Address hold. This should be set for IDE read transfers
+ */
+#define SOURCE_HOLD                 0x0000002
+
+/*
+ *  Transfer mode.
+ *  00 - s/w initiated M2M transfer
+ *  01 - h/w initiated external peripheral transfer - memory to external
+ *       peripheral/IDE/SSP.
+ *  10 - h/w initiated external peripheral transfer - external
+ *        peripheral/IDE/SSP to memory.
+ *  11 - not used.
+ */
+#define TRANSFER_MODE_MASK          0x000000C
+#define TRANSFER_MODE_SHIFT         2
+#define TRANSFER_MODE_SW            0x0000000
+#define TRANSFER_MODE_HW_M2P        0x0000004
+#define TRANSFER_MODE_HW_P2M        0x0000008
+
+/*
+ *  Peripheral wait states count. Latency in HCLK cycles needed by the
+ *  peripheral to de-assert its request line once the transfer is
+ *  finished.
+ *
+ *  IDE Operation           Wait States
+ *  --------------          ------------
+ *  IDE MDMA read               0
+ *  IDE MDMA write              3
+ *  IDE UDMA read               1
+ *  IDE UDMA write              2
+ */
+#define WAIT_STATES_MASK            0x00007F0
+#define WAIT_STATES_SHIFT           4
+#define WS_IDE_MDMA_READ            0
+#define WS_IDE_MDMA_WRITE           3
+#define WS_IDE_UDMA_READ            1
+#define WS_IDE_UDMA_WRITE           2
+
+/*****************************************************************************
+ *
+ * Type definition for the callback function
+ *
+ ****************************************************************************/
+typedef void (* dma_callback)(ep93xx_dma_int_t dma_int,
+                              ep93xx_dma_dev_t device,
+                              unsigned int user_data);
+
+/*****************************************************************************
+ *
+ * API function prototypes
+ *
+ ****************************************************************************/
+extern int ep93xx_dma_request(int * handle, const char *device_id,
+                              ep93xx_dma_dev_t device);
+extern int ep93xx_dma_free(int handle);
+extern int ep93xx_dma_config(int handle, unsigned int flags_m2p,
+                             unsigned int flags_m2m,
+                             dma_callback callback, unsigned int user_data);
+extern int ep93xx_dma_add_buffer(int handle, unsigned int source,
+                                 unsigned int dest, unsigned int size,
+                                 unsigned int last, unsigned int buf_id);
+extern int ep93xx_dma_remove_buffer(int handle, unsigned int * buf_id);
+extern int ep93xx_dma_start(int handle, unsigned int channels,
+                            unsigned int * handles);
+extern int ep93xx_dma_pause(int handle, unsigned int channels,
+                            unsigned int * handles);
+extern int ep93xx_dma_flush(int handle);
+extern int ep93xx_dma_queue_full(int handle);
+extern int ep93xx_dma_get_position(int handle, unsigned int * buf_id,
+                    unsigned int * total, unsigned int * current_frac);
+extern int ep93xx_dma_get_total(int handle);
+extern int ep93xx_dma_is_done(int handle);
+
+#endif /* _ASM_ARCH_DMA_H */
+
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h	2009-04-27 17:37:11.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h	2009-05-06 06:52:19.000000000 +0000
@@ -49,17 +49,898 @@
  */
 
 #define EP93XX_AHB_PHYS_BASE		0x80000000
-#define EP93XX_AHB_VIRT_BASE		0xfef00000
+#define EP93XX_AHB_VIRT_BASE		0xff000000//0xfef00000
 #define EP93XX_AHB_SIZE			0x00100000
 
+
 #define EP93XX_APB_PHYS_BASE		0x80800000
-#define EP93XX_APB_VIRT_BASE		0xfed00000
+#define EP93XX_APB_VIRT_BASE		0xff800000//0xfed00000
 #define EP93XX_APB_SIZE			0x00200000
 
 
-/* AHB peripherals */
+#define IO_BASE_PHYS 			EP93XX_AHB_PHYS_BASE
+#define IO_BASE_VIRT 			EP93XX_AHB_VIRT_BASE
+/*
+ * We don't map the PCMCIA initially.  The PCMCIA driver will use ioremap
+ * to be able to see it.  But besides that PCMCIA will not exist in the
+ * memory map.
+ */
+#define PCMCIA_BASE_VIRT    0xD0000000     // Virtual address of PCMCIA
+#define PCMCIA_BASE_PHYS    0x40000000     // Physical address of PCMCIA
+#define PCMCIA_SIZE         0x10000000     // How much?
+
+
+
+/*
+ * We don't map the PCMCIA initially.  The PCMCIA driver will use ioremap
+ * to be able to see it.  But besides that PCMCIA will not exist in the	       */
+/* SMC register map                                                            */
+/* Address     Read Location                   Write Location                  */
+/* 0x8000.2000 SMCBCR0(Bank config register 0) SMCBCR0(Bank config register 0) */
+/* 0x8000.2004 SMCBCR1(Bank config register 1) SMCBCR1(Bank config register 1) */
+/* 0x8000.2008 SMCBCR2(Bank config register 2) SMCBCR2(Bank config register 2) */
+/* 0x8000.200C SMCBCR3(Bank config register 3) SMCBCR3(Bank config register 3) */
+/* 0x8000.2010 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2014 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2018 SMCBCR6(Bank config register 6) SMCBCR6(Bank config register 6) */
+/* 0x8000.201C SMCBCR7(Bank config register 7) SMCBCR7(Bank config register 7) */
+/* 0x8000.2020 PCAttribute Register            PCAttribute Register            */
+/* 0x8000.2024 PCCommon Register               PCCommon Register               */
+/* 0x8000.2028 PCIO Register                   PCIO Register                   */
+/* 0x8000.202C Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2030 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2034 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2038 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.203C Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2040 PCMCIACtrl Register             PCMCIACtrl Register             */
+
+#define SRAM_OFFSET             0x080000
+#define SRAM_BASE               (EP93XX_AHB_VIRT_BASE|SRAM_OFFSET)
+#define SMCBCR0                 (SRAM_BASE+0x00) /* 0x8000.2000  Bank config register 0 */
+#define SMCBCR1                 (SRAM_BASE+0x04) /* 0x8000.2004  Bank config register 1 */
+#define SMCBCR2                 (SRAM_BASE+0x08) /* 0x8000.2008  Bank config register 2 */
+#define SMCBCR3                 (SRAM_BASE+0x0C) /* 0x8000.200C  Bank config register 3 */
+                                                 /* 0x8000.2010  Reserved, RAZ          */
+                                                 /* 0x8000.2014  Reserved, RAZ          */
+#define SMCBCR6                 (SRAM_BASE+0x18) /* 0x8000.2018  Bank config register 6 */
+#define SMCBCR7                 (SRAM_BASE+0x1C) /* 0x8000.201C  Bank config register 7 */
+
+#define SMC_PCAttribute         (SRAM_BASE+0x20) /* 0x8000.2020  PCMCIA Attribute Register */
+#define SMC_PCCommon            (SRAM_BASE+0x24) /* 0x8000.2024  PCMCIA Common Register    */
+#define SMC_PCIO                (SRAM_BASE+0x28) /* 0x8000.2028  PCMCIA IO Register        */
+                                                 /* 0x8000.202C  Reserved, RAZ           */
+                                                 /* 0x8000.2030  Reserved, RAZ           */
+                                                 /* 0x8000.2034  Reserved, RAZ           */
+                                                 /* 0x8000.2038  Reserved, RAZ           */
+                                                 /* 0x8000.203C  Reserved, RAZ           */
+#define SMC_PCMCIACtrl          (SRAM_BASE+0x40) /* 0x8000.2040  PCMCIA control register */
+
+
+	
+
 #define EP93XX_DMA_BASE			(EP93XX_AHB_VIRT_BASE + 0x00000000)
+//
+/* 8000_0000 - 8000_ffff: DMA  */
+#define DMA_OFFSET              0x000000
+#define DMA_BASE                (EP93XX_DMA_BASE)
+#define DMAMP_TX_0_CONTROL      (DMA_BASE+0x0000)
+#define DMAMP_TX_0_INTERRUPT    (DMA_BASE+0x0004)
+#define DMAMP_TX_0_PPALLOC      (DMA_BASE+0x0008)
+#define DMAMP_TX_0_STATUS       (DMA_BASE+0x000C)       
+#define DMAMP_TX_0_REMAIN       (DMA_BASE+0x0014)
+#define DMAMP_TX_0_MAXCNT0      (DMA_BASE+0x0020)
+#define DMAMP_TX_0_BASE0        (DMA_BASE+0x0024)
+#define DMAMP_TX_0_CURRENT0     (DMA_BASE+0x0028)
+#define DMAMP_TX_0_MAXCNT1      (DMA_BASE+0x0030)
+#define DMAMP_TX_0_BASE1        (DMA_BASE+0x0034)
+#define DMAMP_TX_0_CURRENT1     (DMA_BASE+0x0038)
+
+#define DMAMP_RX_1_CONTROL      (DMA_BASE+0x0040)
+#define DMAMP_RX_1_INTERRUPT    (DMA_BASE+0x0044)
+#define DMAMP_RX_1_PPALLOC      (DMA_BASE+0x0048)
+#define DMAMP_RX_1_STATUS       (DMA_BASE+0x004C)       
+#define DMAMP_RX_1_REMAIN       (DMA_BASE+0x0054)
+#define DMAMP_RX_1_MAXCNT0      (DMA_BASE+0x0060)
+#define DMAMP_RX_1_BASE0        (DMA_BASE+0x0064)
+#define DMAMP_RX_1_CURRENT0     (DMA_BASE+0x0068)
+#define DMAMP_RX_1_MAXCNT1      (DMA_BASE+0x0070)
+#define DMAMP_RX_1_BASE1        (DMA_BASE+0x0074)
+#define DMAMP_RX_1_CURRENT1     (DMA_BASE+0x0078)
+
+#define DMAMP_TX_2_CONTROL      (DMA_BASE+0x0080)
+#define DMAMP_TX_2_INTERRUPT    (DMA_BASE+0x0084)
+#define DMAMP_TX_2_PPALLOC      (DMA_BASE+0x0088)
+#define DMAMP_TX_2_STATUS       (DMA_BASE+0x008C)       
+#define DMAMP_TX_2_REMAIN       (DMA_BASE+0x0094)
+#define DMAMP_TX_2_MAXCNT0      (DMA_BASE+0x00A0)
+#define DMAMP_TX_2_BASE0        (DMA_BASE+0x00A4)
+#define DMAMP_TX_2_CURRENT0     (DMA_BASE+0x00A8)
+#define DMAMP_TX_2_MAXCNT1      (DMA_BASE+0x00B0)
+#define DMAMP_TX_2_BASE1        (DMA_BASE+0x00B4)
+#define DMAMP_TX_2_CURRENT1     (DMA_BASE+0x00B8)
+
+#define DMAMP_RX_3_CONTROL      (DMA_BASE+0x00C0)
+#define DMAMP_RX_3_INTERRUPT    (DMA_BASE+0x00C4)
+#define DMAMP_RX_3_PPALLOC      (DMA_BASE+0x00C8)
+#define DMAMP_RX_3_STATUS       (DMA_BASE+0x00CC)       
+#define DMAMP_RX_3_REMAIN       (DMA_BASE+0x00D4)
+#define DMAMP_RX_3_MAXCNT0      (DMA_BASE+0x00E0)
+#define DMAMP_RX_3_BASE0        (DMA_BASE+0x00E4)
+#define DMAMP_RX_3_CURRENT0     (DMA_BASE+0x00E8)
+#define DMAMP_RX_3_MAXCNT1      (DMA_BASE+0x00F0)
+#define DMAMP_RX_3_BASE1        (DMA_BASE+0x00F4)
+#define DMAMP_RX_3_CURRENT1     (DMA_BASE+0x00F8)
+
+#define DMAMM_0_CONTROL         (DMA_BASE+0x0100)
+#define DMAMM_0_INTERRUPT       (DMA_BASE+0x0104)
+#define DMAMM_0_STATUS          (DMA_BASE+0x010C)
+#define DMAMM_0_BCR0            (DMA_BASE+0x0110)
+#define DMAMM_0_BCR1            (DMA_BASE+0x0114)
+#define DMAMM_0_SAR_BASE0       (DMA_BASE+0x0118)
+#define DMAMM_0_SAR_BASE1       (DMA_BASE+0x011C)
+#define DMAMM_0_SAR_CURRENT0    (DMA_BASE+0x0124)
+#define DMAMM_0_SAR_CURRENT1    (DMA_BASE+0x0128)
+#define DMAMM_0_DAR_BASE0       (DMA_BASE+0x012C)
+#define DMAMM_0_DAR_BASE1       (DMA_BASE+0x0130)
+#define DMAMM_0_DAR_CURRENT0    (DMA_BASE+0x0134)
+#define DMAMM_0_DAR_CURRENT1    (DMA_BASE+0x013C)
+
+#define DMAMM_1_CONTROL         (DMA_BASE+0x0140)
+#define DMAMM_1_INTERRUPT       (DMA_BASE+0x0144)
+#define DMAMM_1_STATUS          (DMA_BASE+0x014C)
+#define DMAMM_1_BCR0            (DMA_BASE+0x0150)       
+#define DMAMM_1_BCR1            (DMA_BASE+0x0154)
+#define DMAMM_1_SAR_BASE0       (DMA_BASE+0x0158)
+#define DMAMM_1_SAR_BASE1       (DMA_BASE+0x015C)
+#define DMAMM_1_SAR_CURRENT0    (DMA_BASE+0x0164)
+#define DMAMM_1_SAR_CURRENT1    (DMA_BASE+0x0168)
+#define DMAMM_1_DAR_BASE0       (DMA_BASE+0x016C)
+#define DMAMM_1_DAR_BASE1       (DMA_BASE+0x0170)
+#define DMAMM_1_DAR_CURRENT0    (DMA_BASE+0x0174)
+#define DMAMM_1_DAR_CURRENT1    (DMA_BASE+0x017C)
+
+#define DMAMP_RX_5_CONTROL      (DMA_BASE+0x0200)
+#define DMAMP_RX_5_INTERRUPT    (DMA_BASE+0x0204)
+#define DMAMP_RX_5_PPALLOC      (DMA_BASE+0x0208)
+#define DMAMP_RX_5_STATUS       (DMA_BASE+0x020C)       
+#define DMAMP_RX_5_REMAIN       (DMA_BASE+0x0214)
+#define DMAMP_RX_5_MAXCNT0      (DMA_BASE+0x0220)
+#define DMAMP_RX_5_BASE0        (DMA_BASE+0x0224)
+#define DMAMP_RX_5_CURRENT0     (DMA_BASE+0x0228)
+#define DMAMP_RX_5_MAXCNT1      (DMA_BASE+0x0230)
+#define DMAMP_RX_5_BASE1        (DMA_BASE+0x0234)
+#define DMAMP_RX_5_CURRENT1     (DMA_BASE+0x0238)
+
+#define DMAMP_TX_4_CONTROL      (DMA_BASE+0x0240)
+#define DMAMP_TX_4_INTERRUPT    (DMA_BASE+0x0244)
+#define DMAMP_TX_4_PPALLOC      (DMA_BASE+0x0248)
+#define DMAMP_TX_4_STATUS       (DMA_BASE+0x024C)       
+#define DMAMP_TX_4_REMAIN       (DMA_BASE+0x0254)
+#define DMAMP_TX_4_MAXCNT0      (DMA_BASE+0x0260)
+#define DMAMP_TX_4_BASE0        (DMA_BASE+0x0264)
+#define DMAMP_TX_4_CURRENT0     (DMA_BASE+0x0268)
+#define DMAMP_TX_4_MAXCNT1      (DMA_BASE+0x0270)
+#define DMAMP_TX_4_BASE1        (DMA_BASE+0x0274)
+#define DMAMP_TX_4_CURRENT1     (DMA_BASE+0x0278)
+
+#define DMAMP_RX_7_CONTROL      (DMA_BASE+0x0280)
+#define DMAMP_RX_7_INTERRUPT    (DMA_BASE+0x0284)
+#define DMAMP_RX_7_PPALLOC      (DMA_BASE+0x0288)
+#define DMAMP_RX_7_STATUS       (DMA_BASE+0x028C)       
+#define DMAMP_RX_7_REMAIN       (DMA_BASE+0x0294)
+#define DMAMP_RX_7_MAXCNT0      (DMA_BASE+0x02A0)
+#define DMAMP_RX_7_BASE0        (DMA_BASE+0x02A4)
+#define DMAMP_RX_7_CURRENT0     (DMA_BASE+0x02A8)
+#define DMAMP_RX_7_MAXCNT1      (DMA_BASE+0x02B0)
+#define DMAMP_RX_7_BASE1        (DMA_BASE+0x02B4)
+#define DMAMP_RX_7_CURRENT1     (DMA_BASE+0x02B8)
+
+#define DMAMP_TX_6_CONTROL      (DMA_BASE+0x02C0)
+#define DMAMP_TX_6_INTERRUPT    (DMA_BASE+0x02C4)
+#define DMAMP_TX_6_PPALLOC      (DMA_BASE+0x02C8)
+#define DMAMP_TX_6_STATUS       (DMA_BASE+0x02CC)       
+#define DMAMP_TX_6_REMAIN       (DMA_BASE+0x02D4)
+#define DMAMP_TX_6_MAXCNT0      (DMA_BASE+0x02E0)
+#define DMAMP_TX_6_BASE0        (DMA_BASE+0x02E4)
+#define DMAMP_TX_6_CURRENT0     (DMA_BASE+0x02E8)
+#define DMAMP_TX_6_MAXCNT1      (DMA_BASE+0x02F0)
+#define DMAMP_TX_6_BASE1        (DMA_BASE+0x02F4)
+#define DMAMP_TX_6_CURRENT1     (DMA_BASE+0x02F8)
+
+#define DMAMP_RX_9_CONTROL      (DMA_BASE+0x0300)
+#define DMAMP_RX_9_INTERRUPT    (DMA_BASE+0x0304)
+#define DMAMP_RX_9_PPALLOC      (DMA_BASE+0x0308)
+#define DMAMP_RX_9_STATUS       (DMA_BASE+0x030C)
+#define DMAMP_RX_9_REMAIN       (DMA_BASE+0x0314)
+#define DMAMP_RX_9_MAXCNT0      (DMA_BASE+0x0320)
+#define DMAMP_RX_9_BASE0        (DMA_BASE+0x0324)
+#define DMAMP_RX_9_CURRENT0     (DMA_BASE+0x0328)
+#define DMAMP_RX_9_MAXCNT1      (DMA_BASE+0x0330)
+#define DMAMP_RX_9_BASE1        (DMA_BASE+0x0334)
+#define DMAMP_RX_9_CURRENT1     (DMA_BASE+0x0338)
+
+#define DMAMP_TX_8_CONTROL      (DMA_BASE+0x0340)
+#define DMAMP_TX_8_INTERRUPT    (DMA_BASE+0x0344)
+#define DMAMP_TX_8_PPALLOC      (DMA_BASE+0x0348)
+#define DMAMP_TX_8_STATUS       (DMA_BASE+0x034C)
+#define DMAMP_TX_8_REMAIN       (DMA_BASE+0x0354)
+#define DMAMP_TX_8_MAXCNT0      (DMA_BASE+0x0360)
+#define DMAMP_TX_8_BASE0        (DMA_BASE+0x0364)
+#define DMAMP_TX_8_CURRENT0     (DMA_BASE+0x0368)
+#define DMAMP_TX_8_MAXCNT1      (DMA_BASE+0x0370)
+#define DMAMP_TX_8_BASE1        (DMA_BASE+0x0374)
+#define DMAMP_TX_8_CURRENT1     (DMA_BASE+0x0378)
+
+#define DMA_ARBITRATION         (DMA_BASE+0x0380)
+#define DMA_INTERRUPT           (DMA_BASE+0x03C0)
+
+
+/*
+ * DMA Register Base addresses and Offsets
+ */
+#define DMA_M2P_TX_0_BASE       DMAMP_TX_0_CONTROL
+#define DMA_M2P_RX_1_BASE       DMAMP_RX_1_CONTROL
+#define DMA_M2P_TX_2_BASE       DMAMP_TX_2_CONTROL
+#define DMA_M2P_RX_3_BASE       DMAMP_RX_3_CONTROL
+#define DMA_M2M_0_BASE          DMAMM_0_CONTROL   
+#define DMA_M2M_1_BASE          DMAMM_1_CONTROL   
+#define DMA_M2P_RX_5_BASE       DMAMP_RX_5_CONTROL
+#define DMA_M2P_TX_4_BASE       DMAMP_TX_4_CONTROL
+#define DMA_M2P_RX_7_BASE       DMAMP_RX_7_CONTROL
+#define DMA_M2P_TX_6_BASE       DMAMP_TX_6_CONTROL
+#define DMA_M2P_RX_9_BASE       DMAMP_RX_9_CONTROL
+#define DMA_M2P_TX_8_BASE       DMAMP_TX_8_CONTROL
+
+#define M2P_OFFSET_CONTROL          0x0000
+#define M2P_OFFSET_INTERRUPT        0x0004
+#define M2P_OFFSET_PPALLOC          0x0008
+#define M2P_OFFSET_STATUS           0x000C       
+#define M2P_OFFSET_REMAIN           0x0014
+#define M2P_OFFSET_MAXCNT0          0x0020
+#define M2P_OFFSET_BASE0            0x0024
+#define M2P_OFFSET_CURRENT0         0x0028
+#define M2P_OFFSET_MAXCNT1          0x0030
+#define M2P_OFFSET_BASE1            0x0034
+#define M2P_OFFSET_CURRENT1         0x0038
+
+#define M2M_OFFSET_CONTROL          0x0000
+#define M2M_OFFSET_INTERRUPT        0x0004
+#define M2M_OFFSET_STATUS           0x000C
+#define M2M_OFFSET_BCR0             0x0010
+#define M2M_OFFSET_BCR1             0x0014
+#define M2M_OFFSET_SAR_BASE0        0x0018
+#define M2M_OFFSET_SAR_BASE1        0x001C
+#define M2M_OFFSET_SAR_CURRENT0     0x0024
+#define M2M_OFFSET_SAR_CURRENT1     0x0028
+#define M2M_OFFSET_DAR_BASE0        0x002C
+#define M2M_OFFSET_DAR_BASE1        0x0030
+#define M2M_OFFSET_DAR_CURRENT0     0x0034
+#define M2M_OFFSET_DAR_CURRENT1     0x003C
+
+
+
+/* 8003_0000 - 8003_ffff: Raster */
+#define RASTER_OFFSET           0x030000
+#define RASTER_BASE             (EP93XX_AHB_VIRT_BASE|RASTER_OFFSET)
+#define VLINESTOTAL             (RASTER_BASE+0x00)
+#define VSYNCSTRTSTOP           (RASTER_BASE+0x04)
+#define VACTIVESTRTSTOP         (RASTER_BASE+0x08)
+#define VCLKSTRTSTOP            (RASTER_BASE+0x0C)
+#define HCLKSTOTAL              (RASTER_BASE+0x10)
+#define HSYNCSTRTSTOP           (RASTER_BASE+0x14)
+#define HACTIVESTRTSTOP         (RASTER_BASE+0x18)
+#define HCLKSTRTSTOP            (RASTER_BASE+0x1C)
+#define BRIGHTNESS              (RASTER_BASE+0x20)
+#define VIDEOATTRIBS            (RASTER_BASE+0x24)
+#define VIDSCRNPAGE             (RASTER_BASE+0x28)
+#define VIDSCRNHPG              (RASTER_BASE+0x2C)
+#define SCRNLINES               (RASTER_BASE+0x30)
+#define LINELENGTH              (RASTER_BASE+0x34)
+#define VLINESTEP               (RASTER_BASE+0x38)
+#define LINECARRY               (RASTER_BASE+0x3C)
+#define BLINKRATE               (RASTER_BASE+0x40)
+#define BLINKMASK               (RASTER_BASE+0x44)
+#define BLINKPATTRN             (RASTER_BASE+0x48)
+#define PATTRNMASK              (RASTER_BASE+0x4C)
+#define BG_OFFSET               (RASTER_BASE+0x50)
+#define PIXELMODE               (RASTER_BASE+0x54)
+#define PARLLIFOUT              (RASTER_BASE+0x58)
+#define PARLLIFIN               (RASTER_BASE+0x5C)
+#define CURSOR_ADR_START        (RASTER_BASE+0x60)
+#define CURSOR_ADR_RESET        (RASTER_BASE+0x64)
+#define CURSORSIZE              (RASTER_BASE+0x68)
+#define CURSORCOLOR1            (RASTER_BASE+0x6C)
+#define CURSORCOLOR2            (RASTER_BASE+0x70)
+#define CURSORXYLOC             (RASTER_BASE+0x74)
+#define CURSOR_DHSCAN_LH_YLOC   (RASTER_BASE+0x78)
+#define RASTER_SWLOCK           (RASTER_BASE+0x7C)
+#define GS_LUT                  (RASTER_BASE+0x80)
+#define RASTER_TCR              (RASTER_BASE+0x100)
+#define RASTER_TISRA            (RASTER_BASE+0x104)
+#define RASTER_TISRB            (RASTER_BASE+0x108)
+#define CURSOR_TISR             (RASTER_BASE+0x10C)
+#define RASTER_TOCRA            (RASTER_BASE+0x110)
+#define RASTER_TOCRB            (RASTER_BASE+0x114)
+#define FIFO_TOCRA              (RASTER_BASE+0x118)
+#define FIFO_TOCRB              (RASTER_BASE+0x11C)
+#define BLINK_TISR              (RASTER_BASE+0x120)
+#define DAC_TISRA               (RASTER_BASE+0x124)
+#define DAC_TISRB               (RASTER_BASE+0x128)
+#define SHIFT_TISR              (RASTER_BASE+0x12C)
+#define DACMUX_TOCRA            (RASTER_BASE+0x130)
+#define DACMUX_TOCRB            (RASTER_BASE+0x134)
+#define PELMUX_TOCR             (RASTER_BASE+0x138)
+#define VIDEO_TOCRA             (RASTER_BASE+0x13C)
+#define VIDEO_TOCRB             (RASTER_BASE+0x140)
+#define YCRCB_TOCR              (RASTER_BASE+0x144)
+#define CURSOR_TOCR             (RASTER_BASE+0x148)
+#define VIDEO_TOCRC             (RASTER_BASE+0x14C)
+#define SHIFT_TOCR              (RASTER_BASE+0x150)
+#define BLINK_TOCR              (RASTER_BASE+0x154)
+#define RASTER_TCER             (RASTER_BASE+0x180)
+#define SIGVAL                  (RASTER_BASE+0x200)
+#define SIGCTL                  (RASTER_BASE+0x204)
+#define VSIGSTRTSTOP            (RASTER_BASE+0x208)
+#define HSIGSTRTSTOP            (RASTER_BASE+0x20C)
+#define SIGCLR                  (RASTER_BASE+0x210)
+#define ACRATE                  (RASTER_BASE+0x214)
+#define LUTCONT                 (RASTER_BASE+0x218)
+#define VBLANKSTRTSTOP          (RASTER_BASE+0x228)
+#define HBLANKSTRTSTOP          (RASTER_BASE+0x22C)
+#define LUT                     (RASTER_BASE+0x400)
+#define CURSORBLINK1            (RASTER_BASE+0x21C)
+#define CURSORBLINK2            (RASTER_BASE+0x220)
+#define CURSORBLINK             (RASTER_BASE+0x224)
+#define EOLOFFSET               (RASTER_BASE+0x230)
+#define FIFOLEVEL               (RASTER_BASE+0x234)
+#define GS_LUT2                 (RASTER_BASE+0x280)
+#define GS_LUT3                 (RASTER_BASE+0x300)
+#define COLOR_LUT               (RASTER_BASE+0x400)
+ 
+/* 8004_0000 - 8004_ffff: Graphics */
+#define GRAPHICS_OFFSET         0x040000
+#define GRAPHICS_BASE           (EP93XX_AHB_VIRT_BASE|GRAPHICS_OFFSET)
+#define SRCPIXELSTRT            (GRAPHICS_BASE+0x00)
+#define DESTPIXELSTRT           (GRAPHICS_BASE+0x04)
+#define BLKSRCSTRT              (GRAPHICS_BASE+0x08)
+#define BLKDSTSTRT              (GRAPHICS_BASE+0x0C)
+#define BLKSRCWIDTH             (GRAPHICS_BASE+0x10)
+#define SRCLINELENGTH           (GRAPHICS_BASE+0x14)
+#define BLKDESTWIDTH            (GRAPHICS_BASE+0x18)
+#define BLKDESTHEIGHT           (GRAPHICS_BASE+0x1C)
+#define DESTLINELENGTH          (GRAPHICS_BASE+0x20)
+#define BLOCKCTRL               (GRAPHICS_BASE+0x24)
+#define TRANSPATTRN             (GRAPHICS_BASE+0x28)
+#define BLOCKMASK               (GRAPHICS_BASE+0x2C)
+#define BACKGROUND              (GRAPHICS_BASE+0x30)
+#define LINEINC                 (GRAPHICS_BASE+0x34)
+#define LINEINIT                (GRAPHICS_BASE+0x38)
+#define LINEPATTRN              (GRAPHICS_BASE+0x3C)
+
+
+/* 800B_0000 - 800B_FFFF: VIC 0 */
+#define VIC0_OFFSET              0x0B0000
+#define VIC0_BASE                (EP93XX_AHB_VIRT_BASE|VIC0_OFFSET)
+#define VIC0                     (VIC0_BASE+0x000) 
+#define VIC0IRQSTATUS            (VIC0_BASE+0x000) /* R   IRQ status register               */
+#define VIC0FIQSTATUS            (VIC0_BASE+0x004) /* R   FIQ status register               */
+#define VIC0RAWINTR              (VIC0_BASE+0x008) /* R   Raw interrupt status register     */
+#define VIC0INTSELECT            (VIC0_BASE+0x00C) /* R/W Interrupt select register         */
+#define VIC0INTENABLE            (VIC0_BASE+0x010) /* R/W Interrupt enable register         */
+#define VIC0INTENCLEAR           (VIC0_BASE+0x014) /* W   Interrupt enable clear register   */
+#define VIC0SOFTINT              (VIC0_BASE+0x018) /* R/W Software interrupt register       */
+#define VIC0SOFTINTCLEAR         (VIC0_BASE+0x01C) /* R/W Software interrupt clear register */
+#define VIC0PROTECTION           (VIC0_BASE+0x020) /* R/W Protection enable register        */
+#define VIC0VECTADDR             (VIC0_BASE+0x030) /* R/W Vector address register           */
+#define VIC0DEFVECTADDR          (VIC0_BASE+0x034) /* R/W Default vector address register   */
+#define VIC0VECTADDR00           (VIC0_BASE+0x100) /* R/W Vector address 00 register        */
+#define VIC0VECTADDR01           (VIC0_BASE+0x104) /* R/W Vector address 01 register        */
+#define VIC0VECTADDR02           (VIC0_BASE+0x108) /* R/W Vector address 02 register        */
+#define VIC0VECTADDR03           (VIC0_BASE+0x10C) /* R/W Vector address 03 register        */
+#define VIC0VECTADDR04           (VIC0_BASE+0x110) /* R/W Vector address 04 register        */
+#define VIC0VECTADDR05           (VIC0_BASE+0x114) /* R/W Vector address 05 register        */
+#define VIC0VECTADDR06           (VIC0_BASE+0x118) /* R/W Vector address 06 register        */
+#define VIC0VECTADDR07           (VIC0_BASE+0x11C) /* R/W Vector address 07 register        */
+#define VIC0VECTADDR08           (VIC0_BASE+0x120) /* R/W Vector address 08 register        */
+#define VIC0VECTADDR09           (VIC0_BASE+0x124) /* R/W Vector address 09 register        */
+#define VIC0VECTADDR10           (VIC0_BASE+0x128) /* R/W Vector address 10 register        */
+#define VIC0VECTADDR11           (VIC0_BASE+0x12C) /* R/W Vector address 11 register        */
+#define VIC0VECTADDR12           (VIC0_BASE+0x130) /* R/W Vector address 12 register        */
+#define VIC0VECTADDR13           (VIC0_BASE+0x134) /* R/W Vector address 13 register        */
+#define VIC0VECTADDR14           (VIC0_BASE+0x138) /* R/W Vector address 14 register        */
+#define VIC0VECTADDR15           (VIC0_BASE+0x13C) /* R/W Vector address 15 register        */
+#define VIC0VECTCNTL00           (VIC0_BASE+0x200) /* R/W Vector control 00 register        */
+#define VIC0VECTCNTL01           (VIC0_BASE+0x204) /* R/W Vector control 01 register        */
+#define VIC0VECTCNTL02           (VIC0_BASE+0x208) /* R/W Vector control 02 register        */
+#define VIC0VECTCNTL03           (VIC0_BASE+0x20C) /* R/W Vector control 03 register        */
+#define VIC0VECTCNTL04           (VIC0_BASE+0x210) /* R/W Vector control 04 register        */
+#define VIC0VECTCNTL05           (VIC0_BASE+0x214) /* R/W Vector control 05 register        */
+#define VIC0VECTCNTL06           (VIC0_BASE+0x218) /* R/W Vector control 06 register        */
+#define VIC0VECTCNTL07           (VIC0_BASE+0x21C) /* R/W Vector control 07 register        */
+#define VIC0VECTCNTL08           (VIC0_BASE+0x220) /* R/W Vector control 08 register        */
+#define VIC0VECTCNTL09           (VIC0_BASE+0x224) /* R/W Vector control 09 register        */
+#define VIC0VECTCNTL10           (VIC0_BASE+0x228) /* R/W Vector control 10 register        */
+#define VIC0VECTCNTL11           (VIC0_BASE+0x22C) /* R/W Vector control 11 register        */
+#define VIC0VECTCNTL12           (VIC0_BASE+0x230) /* R/W Vector control 12 register        */
+#define VIC0VECTCNTL13           (VIC0_BASE+0x234) /* R/W Vector control 13 register        */
+#define VIC0VECTCNTL14           (VIC0_BASE+0x238) /* R/W Vector control 14 register        */
+#define VIC0VECTCNTL15           (VIC0_BASE+0x23C) /* R/W Vector control 15 register        */
+#define VIC0ITCR                 (VIC0_BASE+0x300) /* R/W Test control register             */
+#define VIC0ITIP1                (VIC0_BASE+0x304) /* R   Test input register (nVICIRQIN/nVICFIQIN)*/
+#define VIC0ITIP2                (VIC0_BASE+0x308) /* R   Test input register (VICVECTADDRIN)      */
+#define VIC0ITOP1                (VIC0_BASE+0x30C) /* R   Test output register (nVICIRQ/nVICFIQ)   */
+#define VIC0ITOP2                (VIC0_BASE+0x310) /* R   Test output register (VICVECTADDROUT)    */
+#define VIC0PERIPHID0            (VIC0_BASE+0xFE0) /* R   Peripheral ID register bits 7:0   */
+#define VIC0PERIPHID1            (VIC0_BASE+0xFE4) /* R   Peripheral ID register bits 15:8  */
+#define VIC0PERIPHID2            (VIC0_BASE+0xFE8) /* R   Peripheral ID register bits 23:16 */
+#define VIC0PERIPHID3            (VIC0_BASE+0xFEC) /* R   Peripheral ID register bits 31:24 */
+
+
+/* 800C_0000 - 800C_FFFF: VIC 0 */
+#define VIC1_OFFSET              0x0C0000
+#define VIC1_BASE                (EP93XX_AHB_VIRT_BASE|VIC1_OFFSET)
+#define VIC1                     (VIC1_BASE+0x000) 
+#define VIC1IRQSTATUS            (VIC1_BASE+0x000) /* R   IRQ status register               */
+#define VIC1FIQSTATUS            (VIC1_BASE+0x004) /* R   FIQ status register               */
+#define VIC1RAWINTR              (VIC1_BASE+0x008) /* R   Raw interrupt status register     */
+#define VIC1INTSELECT            (VIC1_BASE+0x00C) /* R/W Interrupt select register         */
+#define VIC1INTENABLE            (VIC1_BASE+0x010) /* R/W Interrupt enable register         */
+#define VIC1INTENCLEAR           (VIC1_BASE+0x014) /* W   Interrupt enable clear register   */
+#define VIC1SOFTINT              (VIC1_BASE+0x018) /* R/W Software interrupt register       */
+#define VIC1SOFTINTCLEAR         (VIC1_BASE+0x01C) /* R/W Software interrupt clear register */
+#define VIC1PROTECTION           (VIC1_BASE+0x020) /* R/W Protection enable register        */
+#define VIC1VECTADDR             (VIC1_BASE+0x030) /* R/W Vector address register           */
+#define VIC1DEFVECTADDR          (VIC1_BASE+0x034) /* R/W Default vector address register   */
+#define VIC1VECTADDR00           (VIC1_BASE+0x100) /* R/W Vector address 00 register        */
+#define VIC1VECTADDR01           (VIC1_BASE+0x104) /* R/W Vector address 01 register        */
+#define VIC1VECTADDR02           (VIC1_BASE+0x108) /* R/W Vector address 02 register        */
+#define VIC1VECTADDR03           (VIC1_BASE+0x10C) /* R/W Vector address 03 register        */
+#define VIC1VECTADDR04           (VIC1_BASE+0x110) /* R/W Vector address 04 register        */
+#define VIC1VECTADDR05           (VIC1_BASE+0x114) /* R/W Vector address 05 register        */
+#define VIC1VECTADDR06           (VIC1_BASE+0x118) /* R/W Vector address 06 register        */
+#define VIC1VECTADDR07           (VIC1_BASE+0x11C) /* R/W Vector address 07 register        */
+#define VIC1VECTADDR08           (VIC1_BASE+0x120) /* R/W Vector address 08 register        */
+#define VIC1VECTADDR09           (VIC1_BASE+0x124) /* R/W Vector address 09 register        */
+#define VIC1VECTADDR10           (VIC1_BASE+0x128) /* R/W Vector address 10 register        */
+#define VIC1VECTADDR11           (VIC1_BASE+0x12C) /* R/W Vector address 11 register        */
+#define VIC1VECTADDR12           (VIC1_BASE+0x130) /* R/W Vector address 12 register        */
+#define VIC1VECTADDR13           (VIC1_BASE+0x134) /* R/W Vector address 13 register        */
+#define VIC1VECTADDR14           (VIC1_BASE+0x138) /* R/W Vector address 14 register        */
+#define VIC1VECTADDR15           (VIC1_BASE+0x13C) /* R/W Vector address 15 register        */
+#define VIC1VECTCNTL00           (VIC1_BASE+0x200) /* R/W Vector control 00 register        */
+#define VIC1VECTCNTL01           (VIC1_BASE+0x204) /* R/W Vector control 01 register        */
+#define VIC1VECTCNTL02           (VIC1_BASE+0x208) /* R/W Vector control 02 register        */
+#define VIC1VECTCNTL03           (VIC1_BASE+0x20C) /* R/W Vector control 03 register        */
+#define VIC1VECTCNTL04           (VIC1_BASE+0x210) /* R/W Vector control 04 register        */
+#define VIC1VECTCNTL05           (VIC1_BASE+0x214) /* R/W Vector control 05 register        */
+#define VIC1VECTCNTL06           (VIC1_BASE+0x218) /* R/W Vector control 06 register        */
+#define VIC1VECTCNTL07           (VIC1_BASE+0x21C) /* R/W Vector control 07 register        */
+#define VIC1VECTCNTL08           (VIC1_BASE+0x220) /* R/W Vector control 08 register        */
+#define VIC1VECTCNTL09           (VIC1_BASE+0x224) /* R/W Vector control 09 register        */
+#define VIC1VECTCNTL10           (VIC1_BASE+0x228) /* R/W Vector control 10 register        */
+#define VIC1VECTCNTL11           (VIC1_BASE+0x22C) /* R/W Vector control 11 register        */
+#define VIC1VECTCNTL12           (VIC1_BASE+0x230) /* R/W Vector control 12 register        */
+#define VIC1VECTCNTL13           (VIC1_BASE+0x234) /* R/W Vector control 13 register        */
+#define VIC1VECTCNTL14           (VIC1_BASE+0x238) /* R/W Vector control 14 register        */
+#define VIC1VECTCNTL15           (VIC1_BASE+0x23C) /* R/W Vector control 15 register        */
+#define VIC1ITCR                 (VIC1_BASE+0x300) /* R/W Test control register             */
+#define VIC1ITIP1                (VIC1_BASE+0x304) /* R   Test input register (nVICIRQIN/nVICFIQIN)*/
+#define VIC1ITIP2                (VIC1_BASE+0x308) /* R   Test input register (VICVECTADDRIN)      */
+#define VIC1ITOP1                (VIC1_BASE+0x30C) /* R   Test output register (nVICIRQ/nVICFIQ)   */
+#define VIC1ITOP2                (VIC1_BASE+0x310) /* R   Test output register (VICVECTADDROUT)    */
+#define VIC1PERIPHID0            (VIC1_BASE+0xFE0) /* R   Peripheral ID register bits 7:0   */
+#define VIC1PERIPHID1            (VIC1_BASE+0xFE4) /* R   Peripheral ID register bits 15:8  */
+#define VIC1PERIPHID2            (VIC1_BASE+0xFE8) /* R   Peripheral ID register bits 23:16 */
+#define VIC1PERIPHID3            (VIC1_BASE+0xFEC) /* R   Peripheral ID register bits 31:24 */
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////APB/////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////
+/* 8081_0000 - 8081_ffff: Timers */
+#define TIMERS_OFFSET           0x010000
+#define TIMERS_BASE             (EP93XX_APB_VIRT_BASE|TIMERS_OFFSET)
+
+#define TIMER1LOAD              (TIMERS_BASE+0x00)
+#define TIMER1VALUE             (TIMERS_BASE+0x04)
+#define TIMER1CONTROL           (TIMERS_BASE+0x08)
+#define TIMER1CLEAR             (TIMERS_BASE+0x0C)
+#define TIMER1TEST              (TIMERS_BASE+0x10)
+
+#define TIMER2LOAD              (TIMERS_BASE+0x20)
+#define TIMER2VALUE             (TIMERS_BASE+0x24)
+#define TIMER2CONTROL           (TIMERS_BASE+0x28)
+#define TIMER2CLEAR             (TIMERS_BASE+0x2C)
+#define TIMER2TEST              (TIMERS_BASE+0x30)
+
+#define TIMER3LOAD              (TIMERS_BASE+0x80)
+#define TIMER3VALUE             (TIMERS_BASE+0x84)
+#define TIMER3CONTROL           (TIMERS_BASE+0x88)
+#define TIMER3CLEAR             (TIMERS_BASE+0x8C)
+#define TIMER3TEST              (TIMERS_BASE+0x90)
+
+#define TTIMERBZCONT            (TIMERS_BASE+0x40)
+
+#define TIMER4VALUELOW          (TIMERS_BASE+0x60)
+#define TIMER4VALUEHIGH         (TIMERS_BASE+0x64)
+
+
+/* 8082_0000 - 8082_ffff: I2S */
+#define I2S_OFFSET            0x020000
+#define I2S_BASE              (EP93XX_APB_VIRT_BASE|I2S_OFFSET)
+#define I2S_PHYS_BASE         (EP93XX_APB_PHYS_BASE + I2S_OFFSET)
+
+
+
+#define I2STxClkCfg           (I2S_BASE+0x00) /* 8082.0000 R/W Transmitter clock config register  */
+#define I2SRxClkCfg           (I2S_BASE+0x04) /* 8082.0004 R/W Receiver clock config register     */
+#define I2SGlSts              (I2S_BASE+0x08) /* 8082.0008 R/W SAI Global Status register.        */
+#define I2SGlCtrl             (I2S_BASE+0x0C) /* 8082.000C R/W SAI Global Control register        */
+
+#define I2STX0Lft             (I2S_BASE+0x10) /* 8082.0010 R/W Left  TX data reg for channel 0    */
+#define I2STX0Rt              (I2S_BASE+0x14) /* 8082.0014 R/W Right TX data reg for channel 0    */
+#define I2STX1Lft             (I2S_BASE+0x18) /* 8082.0018 R/W Left  TX data reg for channel 1    */
+#define I2STX1Rt              (I2S_BASE+0x1C) /* 8082.001C R/W Right TX data reg for channel 1    */
+#define I2STX2Lft             (I2S_BASE+0x20) /* 8082.0020 R/W Left  TX data reg for channel 2    */
+#define I2STX2Rt              (I2S_BASE+0x24) /* 8082.0024 R/W Right TX data reg for channel 2    */
+
+#define I2STXLinCtrlData      (I2S_BASE+0x28) /* 8082.0028 R/W TX Line Control data register      */
+#define I2STXCtrl             (I2S_BASE+0x2C) /* 8082.002C R/W TX Control register                */
+#define I2STXWrdLen           (I2S_BASE+0x30) /* 8082.0030 R/W TX Word Length                     */
+#define I2STX0En              (I2S_BASE+0x34) /* 8082.0034 R/W TX0 Channel Enable                 */
+#define I2STX1En              (I2S_BASE+0x38) /* 8082.0038 R/W TX1 Channel Enable                 */
+#define I2STX2En              (I2S_BASE+0x3C) /* 8082.003C R/W TX2 Channel Enable                 */
+
+#define I2SRX0Lft             (I2S_BASE+0x40) /* 8082.0040 R   Left  RX data reg for channel 0    */
+#define I2SRX0Rt              (I2S_BASE+0x44) /* 8082.0044 R   Right RX data reg for channel 0    */
+#define I2SRX1Lft             (I2S_BASE+0x48) /* 8082.0048 R   Left  RX data reg for channel 1    */
+#define I2SRX1Rt              (I2S_BASE+0x4C) /* 8082.004c R   Right RX data reg for channel 1    */
+#define I2SRX2Lft             (I2S_BASE+0x50) /* 8082.0050 R   Left  RX data reg for channel 2    */
+#define I2SRX2Rt              (I2S_BASE+0x54) /* 8082.0054 R   Right RX data reg for channel 2    */
+
+#define I2SRXLinCtrlData      (I2S_BASE+0x58) /* 8082.0058 R/W RX Line Control data register      */
+#define I2SRXCtrl             (I2S_BASE+0x5C) /* 8082.005C R/W RX Control register                */
+#define I2SRXWrdLen           (I2S_BASE+0x60) /* 8082.0060 R/W RX Word Length                     */
+#define I2SRX0En              (I2S_BASE+0x64) /* 8082.0064 R/W RX0 Channel Enable                 */
+#define I2SRX1En              (I2S_BASE+0x68) /* 8082.0068 R/W RX1 Channel Enable                 */
+#define I2SRX2En              (I2S_BASE+0x6C) /* 8082.006C R/W RX2 Channel Enable                 */
+
+
+
+
+/* 8084_0000 - 8084_ffff: GPIO */
+#define GPIO_OFFSET              0x040000
+#define GPIO_BASE                (EP93XX_APB_VIRT_BASE|GPIO_OFFSET)
+#define GPIO_PADR                (GPIO_BASE+0x00)
+#define GPIO_PBDR                (GPIO_BASE+0x04)
+#define GPIO_PCDR                (GPIO_BASE+0x08)
+#define GPIO_PDDR                (GPIO_BASE+0x0C)
+#define GPIO_PADDR               (GPIO_BASE+0x10)
+#define GPIO_PBDDR               (GPIO_BASE+0x14)
+#define GPIO_PCDDR               (GPIO_BASE+0x18)
+#define GPIO_PDDDR               (GPIO_BASE+0x1C)
+#define GPIO_PEDR                (GPIO_BASE+0x20)
+#define GPIO_PEDDR               (GPIO_BASE+0x24)
+// #define 0x8084.0028 Reserved
+// #define 0x8084.002C Reserved
+#define GPIO_PFDR                (GPIO_BASE+0x30) 
+#define GPIO_PFDDR               (GPIO_BASE+0x34)
+#define GPIO_PGDR                (GPIO_BASE+0x38)
+#define GPIO_PGDDR               (GPIO_BASE+0x3C)
+#define GPIO_PHDR                (GPIO_BASE+0x40)
+#define GPIO_PHDDR               (GPIO_BASE+0x44)
+// #define 0x8084.0048 RAZ RAZ                            
+#define GPIO_FINTTYPE1           (GPIO_BASE+0x4C)
+#define GPIO_FINTTYPE2           (GPIO_BASE+0x50)
+#define GPIO_FEOI                (GPIO_BASE+0x54) /* WRITE ONLY - READ UNDEFINED */
+#define GPIO_FINTEN              (GPIO_BASE+0x58)
+#define GPIO_INTSTATUSF          (GPIO_BASE+0x5C)
+#define GPIO_RAWINTSTASUSF       (GPIO_BASE+0x60) 
+#define GPIO_FDB                 (GPIO_BASE+0x64)
+#define GPIO_PAPINDR             (GPIO_BASE+0x68)
+#define GPIO_PBPINDR             (GPIO_BASE+0x6C)
+#define GPIO_PCPINDR             (GPIO_BASE+0x70)
+#define GPIO_PDPINDR             (GPIO_BASE+0x74)
+#define GPIO_PEPINDR             (GPIO_BASE+0x78)
+#define GPIO_PFPINDR             (GPIO_BASE+0x7C)
+#define GPIO_PGPINDR             (GPIO_BASE+0x80)
+#define GPIO_PHPINDR             (GPIO_BASE+0x84)
+#define GPIO_AINTTYPE1           (GPIO_BASE+0x90)
+#define GPIO_AINTTYPE2           (GPIO_BASE+0x94)
+#define GPIO_AEOI                (GPIO_BASE+0x98) /* WRITE ONLY - READ UNDEFINED */
+#define GPIO_AINTEN              (GPIO_BASE+0x9C)
+#define GPIO_INTSTATUSA          (GPIO_BASE+0xA0)
+#define GPIO_RAWINTSTSTISA       (GPIO_BASE+0xA4)
+#define GPIO_ADB                 (GPIO_BASE+0xA8)
+#define GPIO_BINTTYPE1           (GPIO_BASE+0xAC)
+#define GPIO_BINTTYPE2           (GPIO_BASE+0xB0)
+#define GPIO_BEOI                (GPIO_BASE+0xB4) /* WRITE ONLY - READ UNDEFINED */
+#define GPIO_BINTEN              (GPIO_BASE+0xB8)
+#define GPIO_INTSTATUSB          (GPIO_BASE+0xBC)
+#define GPIO_RAWINTSTSTISB       (GPIO_BASE+0xC0)
+#define GPIO_BDB                 (GPIO_BASE+0xC4)
+#define GPIO_EEDRIVE             (GPIO_BASE+0xC8)
+//#define Reserved               (GPIO_BASE+0xCC)
+#define GPIO_TCR                 (GPIO_BASE+0xD0) /* Test Registers */
+#define GPIO_TISRA               (GPIO_BASE+0xD4) /* Test Registers */
+#define GPIO_TISRB               (GPIO_BASE+0xD8) /* Test Registers */
+#define GPIO_TISRC               (GPIO_BASE+0xDC) /* Test Registers */
+#define GPIO_TISRD               (GPIO_BASE+0xE0) /* Test Registers */
+#define GPIO_TISRE               (GPIO_BASE+0xE4) /* Test Registers */
+#define GPIO_TISRF               (GPIO_BASE+0xE8) /* Test Registers */
+#define GPIO_TISRG               (GPIO_BASE+0xEC) /* Test Registers */
+#define GPIO_TISRH               (GPIO_BASE+0xF0) /* Test Registers */
+#define GPIO_TCER                (GPIO_BASE+0xF4) /* Test Registers */
+
+
+/* 8088_0000 - 8088_ffff: Ac97 Controller (AAC) */
+#define AC97_OFFSET             0x080000
+#define AC97_BASE               (EP93XX_APB_VIRT_BASE|AC97_OFFSET)
+#define EP93XX_AC97_PHY_BASE    (EP93XX_APB_PHYS_BASE|AC97_OFFSET)
+#define AC97DR1                 (AC97_BASE+0x00) /* 8088.0000 R/W Data read or written from/to FIFO1  */
+#define AC97RXCR1               (AC97_BASE+0x04) /* 8088.0004 R/W Control register for receive        */
+#define AC97TXCR1               (AC97_BASE+0x08) /* 8088.0008 R/W Control register for transmit       */
+#define AC97SR1                 (AC97_BASE+0x0C) /* 8088.000C R   Status register                     */
+#define AC97RISR1               (AC97_BASE+0x10) /* 8088.0010 R   Raw interrupt status register       */
+#define AC97ISR1                (AC97_BASE+0x14) /* 8088.0014 R   Interrupt Status                    */
+#define AC97IE1                 (AC97_BASE+0x18) /* 8088.0018 R/W Interrupt Enable                    */
+                                                               /* 8088.001C Reserved - RAZ                          */
+#define AC97DR2                 (AC97_BASE+0x20) /* 8088.0020 R/W Data read or written from/to FIFO2  */
+#define AC97RXCR2               (AC97_BASE+0x24) /* 8088.0024 R/W Control register for receive        */
+#define AC97TXCR2               (AC97_BASE+0x28) /* 8088.0028 R/W Control register for transmit       */
+#define AC97SR2                 (AC97_BASE+0x2C) /* 8088.002C R   Status register                     */
+#define AC97RISR2               (AC97_BASE+0x30) /* 8088.0030 R   Raw interrupt status register       */
+#define AC97ISR2                (AC97_BASE+0x34) /* 8088.0034 R   Interrupt Status                    */
+#define AC97IE2                 (AC97_BASE+0x38) /* 8088.0038 R/W Interrupt Enable                    */
+                                                               /* 8088.003C Reserved - RAZ                          */
+#define AC97DR3                 (AC97_BASE+0x40) /* 8088.0040 R/W Data read or written from/to FIFO3. */
+#define AC97RXCR3               (AC97_BASE+0x44) /* 8088.0044 R/W Control register for receive        */
+#define AC97TXCR3               (AC97_BASE+0x48) /* 8088.0048 R/W Control register for transmit       */
+#define AC97SR3                 (AC97_BASE+0x4C) /* 8088.004C R   Status register                     */
+#define AC97RISR3               (AC97_BASE+0x50) /* 8088.0050 R   Raw interrupt status register       */
+#define AC97ISR3                (AC97_BASE+0x54) /* 8088.0054 R   Interrupt Status                    */
+#define AC97IE3                 (AC97_BASE+0x58) /* 8088.0058 R/W Interrupt Enable                    */
+                                                               /* 8088.005C Reserved - RAZ                          */
+#define AC97DR2                 (AC97_BASE+0x20) /* 8088.0020 R/W Data read or written from/to FIFO2  */
+#define AC97RXCR2               (AC97_BASE+0x24) /* 8088.0024 R/W Control register for receive        */
+#define AC97TXCR2               (AC97_BASE+0x28) /* 8088.0028 R/W Control register for transmit       */
+#define AC97SR2                 (AC97_BASE+0x2C) /* 8088.002C R   Status register                     */
+#define AC97RISR2               (AC97_BASE+0x30) /* 8088.0030 R   Raw interrupt status register       */
+#define AC97ISR2                (AC97_BASE+0x34) /* 8088.0034 R   Interrupt Status                    */
+#define AC97IE2                 (AC97_BASE+0x38) /* 8088.0038 R/W Interrupt Enable                    */
+                                                               /* 8088.003C Reserved - RAZ                          */
+#define AC97DR3                 (AC97_BASE+0x40) /* 8088.0040 R/W Data read or written from/to FIFO3. */
+#define AC97RXCR3               (AC97_BASE+0x44) /* 8088.0044 R/W Control register for receive        */
+#define AC97TXCR3               (AC97_BASE+0x48) /* 8088.0048 R/W Control register for transmit       */
+#define AC97SR3                 (AC97_BASE+0x4C) /* 8088.004C R   Status register                     */
+#define AC97RISR3               (AC97_BASE+0x50) /* 8088.0050 R   Raw interrupt status register       */
+#define AC97ISR3                (AC97_BASE+0x54) /* 8088.0054 R   Interrupt Status                    */
+#define AC97IE3                 (AC97_BASE+0x58) /* 8088.0058 R/W Interrupt Enable                    */
+                                                               /* 8088.005C Reserved - RAZ                          */
+#define AC97DR4                 (AC97_BASE+0x60) /* 8088.0060 R/W Data read or written from/to FIFO4. */
+#define AC97RXCR4               (AC97_BASE+0x64) /* 8088.0064 R/W Control register for receive        */
+#define AC97TXCR4               (AC97_BASE+0x68) /* 8088.0068 R/W Control register for transmit       */
+#define AC97SR4                 (AC97_BASE+0x6C) /* 8088.006C R   Status register                     */
+#define AC97RISR4               (AC97_BASE+0x70) /* 8088.0070 R   Raw interrupt status register       */
+#define AC97ISR4                (AC97_BASE+0x74) /* 8088.0074 R   Interrupt Status                    */
+#define AC97IE4                 (AC97_BASE+0x78) /* 8088.0078 R/W Interrupt Enable                    */
+                                                               /* 8088.007C Reserved - RAZ                          */
+#define AC97S1DATA              (AC97_BASE+0x80) /* 8088.0080 R/W Data received/transmitted on SLOT1  */
+#define AC97S2DATA              (AC97_BASE+0x84) /* 8088.0084 R/W Data received/transmitted on SLOT2  */
+#define AC97S12DATA             (AC97_BASE+0x88) /* 8088.0088 R/W Data received/transmitted on SLOT12 */
+#define AC97RGIS                (AC97_BASE+0x8C) /* 8088.008C R/W Raw Global interrupt status register*/
+#define AC97GIS                 (AC97_BASE+0x90) /* 8088.0090 R   Global interrupt status register    */
+#define AC97IM                  (AC97_BASE+0x94) /* 8088.0094 R/W Interrupt mask register             */
+#define AC97EOI                 (AC97_BASE+0x98) /* 8088.0098 W   Interrupt clear register            */
+#define AC97GCR                 (AC97_BASE+0x9C) /* 8088.009C R/W Main Control register               */
+#define AC97RESET               (AC97_BASE+0xA0) /* 8088.00A0 R/W RESET control register.             */
+#define AC97SYNC                (AC97_BASE+0xA4) /* 8088.00A4 R/W SYNC control register.              */
+#define AC97GCIS                (AC97_BASE+0xA8) /* 8088.00A8 R  Global chan FIFO int status register */
+
+
+/* 808A_0000 - 808A_ffff: SSP - (SPI) */
+#define SSP_OFFSET             0x0A0000
+#define SSP_BASE               (EP93XX_APB_VIRT_BASE|SSP_OFFSET)
+#define SSPCR0                 (SSP_BASE+0x00)
+#define SSPCR1                 (SSP_BASE+0x04)
+#define SSPDR                  (SSP_BASE+0x08)
+#define SSPSR                  (SSP_BASE+0x0c)
+#define SSPCPSR                (SSP_BASE+0x10)
+#define SSPIIR                 (SSP_BASE+0x14)
+
+
+/*808B_0000 - 808B_ffff: IrDA */
+#define IRDA_OFFSET             0x0B0000
+#define IRDA_BASE               (EP93XX_APB_VIRT_BASE|IRDA_OFFSET)
+#define IrEnable                (IRDA_BASE+0x00)
+#define IrCtrl                  (IRDA_BASE+0x04)
+#define IrAdrMatchVal           (IRDA_BASE+0x08)
+#define IrFlag                  (IRDA_BASE+0x0C)
+#define IrData                  (IRDA_BASE+0x10)
+#define IrDataTail1             (IRDA_BASE+0x14)
+#define IrDataTail2             (IRDA_BASE+0x18)
+#define IrDataTail3             (IRDA_BASE+0x1c)
+#define IrRIB                   (IRDA_BASE+0x20)
+#define IrTR0                   (IRDA_BASE+0x24)
+#define IrDMACR                 (IRDA_BASE+0x28)
+#define SIRTR0                  (IRDA_BASE+0x30)
+#define MISR                    (IRDA_BASE+0x80)
+#define MIMR                    (IRDA_BASE+0x84)
+#define MIIR                    (IRDA_BASE+0x88)
+#define FISR                    (IRDA_BASE+0x180)
+#define FIMR                    (IRDA_BASE+0x184)
+#define FIIR                    (IRDA_BASE+0x188)
+
+
+/* 808C_0000 - 808C_ffff: UART1 */
+#define UART1_OFFSET            0x0C0000
+#define UART1_BASE              (EP93XX_APB_VIRT_BASE|UART1_OFFSET)
+#define UART1_BASE_VIRT         (EP93XX_APB_PHYS_BASE|UART1_OFFSET)
+#define UART1DR                 (UART1_BASE+0x000)
+#define UART1RSR                (UART1_BASE+0x004)
+#define UART1ECR                (UART1_BASE+0x004)
+#define UART1CR_H               (UART1_BASE+0x008)
+#define UART1CR_M               (UART1_BASE+0x00C)
+#define UART1CR_L               (UART1_BASE+0x010)
+#define UART1CR                 (UART1_BASE+0x014)
+#define UART1FR                 (UART1_BASE+0x018)
+#define UART1IIR                (UART1_BASE+0x01C)
+#define UART1ICR                (UART1_BASE+0x01C)
+#define UART1ILPR               (UART1_BASE+0x020)
+#define UART1DMACR              (UART1_BASE+0x028)
+#define UART1TMR                (UART1_BASE+0x084)
+#define UART1MCR                (UART1_BASE+0x100)
+#define UART1MSR                (UART1_BASE+0x104)
+#define UART1TCR                (UART1_BASE+0x108)
+#define UART1TISR               (UART1_BASE+0x10C)
+#define UART1TOCR               (UART1_BASE+0x110)
+#define HDLC1CR                 (UART1_BASE+0x20c)
+#define HDLC1AMV                (UART1_BASE+0x210)
+#define HDLC1AMSK               (UART1_BASE+0x214)
+#define HDLC1RIB                (UART1_BASE+0x218)
+#define HDLC1SR                 (UART1_BASE+0x21c)
+
+/* Offsets to the various UART registers */
+#define UARTDR                  0x0000
+#define UARTRSR                 0x0004
+#define UARTECR                 0x0004
+#define UARTCR_H                0x0008
+#define UARTCR_M                0x000C
+#define UARTCR_L                0x0010
+#define UARTCR                  0x0014
+#define UARTFR                  0x0018
+#define UARTIIR                 0x001C
+#define UARTICR                 0x001C
+#define UARTMCR                 0x0100
+#define UARTMSR                 0x0104
+
+/* 808d_0000 - 808d_ffff: UART2 */
+#define UART2_OFFSET            0x0D0000
+#define UART2_BASE              (EP93XX_APB_VIRT_BASE|UART2_OFFSET)
+#define UART2_BASE_VIRT         (EP93XX_APB_PHYS_BASE|UART2_OFFSET)
+#define UART2DR                 (UART2_BASE+0x00)
+#define UART2RSR                (UART2_BASE+0x04) /* Read */
+#define UART2ECR                (UART2_BASE+0x04) /* Write */
+#define UART2CR_H               (UART2_BASE+0x08)
+#define UART2CR_M               (UART2_BASE+0x0C)
+#define UART2CR_L               (UART2_BASE+0x10)
+#define UART2CR                 (UART2_BASE+0x14)
+#define UART2FR                 (UART2_BASE+0x18)
+#define UART2IIR                (UART2_BASE+0x1C) /* Read */
+#define UART2ICR                (UART2_BASE+0x1C) /* Write */
+#define UART2ILPR               (UART2_BASE+0x20)
+#define UART2DMACR              (UART2_BASE+0x28)
+#define UART2TMR                (UART2_BASE+0x84)
+
+
+/* 808e_0000 - 808e_ffff: UART3 */
+#define UART3_OFFSET            0x0E0000
+#define UART3_BASE              (EP93XX_APB_VIRT_BASE|UART3_OFFSET)
+#define UART3_BASE_VIRT         (EP93XX_APB_PHYS_BASE|UART3_OFFSET)
+#define UART3DR                 (UART3_BASE+0x00)
+#define UART3RSR                (UART3_BASE+0x04) /* Read */
+#define UART3ECR                (UART3_BASE+0x04) /* Write */
+#define UART3CR_H               (UART3_BASE+0x08)
+#define UART3CR_M               (UART3_BASE+0x0C)
+#define UART3CR_L               (UART3_BASE+0x10)
+#define UART3CR                 (UART3_BASE+0x14)
+#define UART3FR                 (UART3_BASE+0x18)
+#define UART3IIR                (UART3_BASE+0x1C) /* Read */
+#define UART3ICR                (UART3_BASE+0x1C) /* Write */
+#define UART3ILPR               (UART3_BASE+0x20)
+#define UART3DMACR              (UART3_BASE+0x28)
+#define UART3TCR                (UART3_BASE+0x80)
+#define UART3TISR               (UART3_BASE+0x88)
+#define UART3TOCR               (UART3_BASE+0x8C)
+#define UART3TMR                (UART3_BASE+0x84)
+#define UART3MCR                (UART3_BASE+0x100) /* Modem Control Reg */
+#define UART3MSR                (UART3_BASE+0x104) /* Modem Status Reg */
+
+#define UART3HDLCCR             (UART3_BASE+0x20C) /* HDLC Registers */
+#define UART3HDLCAMV            (UART3_BASE+0x210) /* HDLC Registers */
+#define UART3HDLCAMSK           (UART3_BASE+0x214) /* HDLC Registers */
+#define UART3HDLCCRIB           (UART3_BASE+0x218) /* HDLC Registers */
+#define UART3HDLCSR             (UART3_BASE+0x21C) /* HDLC Registers */
+
+/* 808f_0000 - 808f_ffff: KEY Matrix */
+#define KEY_OFFSET              0x0F0000
+#define KEY_BASE                (EP93XX_APB_VIRT_BASE|KEY_OFFSET)
+#define SCANINIT                (KEY_BASE+0x00)
+#define KEY_DIAG                (KEY_BASE+0x04)
+#define KEY_REG                 (KEY_BASE+0x08)
+#define KEY_TCR                 (KEY_BASE+0x10)
+#define KEY_TISR                (KEY_BASE+0x14)
+#define KEY_TOCR                (KEY_BASE+0x18)
+
+
+#define TOUCH_OFFSET            0x100000
+#define TOUCH_BASE              (EP93XX_APB_VIRT_BASE|TOUCH_OFFSET)
+#define TSSetup                 (TOUCH_BASE+0x00) /* R/W touchscreen controller setup control register.     */
+#define TSXYMaxMin              (TOUCH_BASE+0x04) /* R/W touchscreen controller max/min register.           */
+#define TSXYResult              (TOUCH_BASE+0x08) /* R   touchscreen controller result register.            */
+#define TSDischarge             (TOUCH_BASE+0x0C) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSXSample               (TOUCH_BASE+0x10) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSYSample               (TOUCH_BASE+0x14) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSDirect                (TOUCH_BASE+0x18) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSDetect                (TOUCH_BASE+0x1C) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSSWLock                (TOUCH_BASE+0x20) /*  NA    R/W touchscreen software lock register.         */
+#define TSSetup2                (TOUCH_BASE+0x24) /* R/W touchscreen setup control register #2.             */
+
+
+/* 8093_0000 - 8093_ffff: CSC/Syscon  PLL, clock control, & misc. stuff */
+#define SYSCON_OFFSET           0x130000
+#define SYSCON_BASE             ((EP93XX_APB_VIRT_BASE)|SYSCON_OFFSET)
+#define SYSCON_PWRSR            (SYSCON_BASE+0x0000)
+#define SYSCON_PWRCNT           (SYSCON_BASE+0x0004)
+#define SYSCON_HALT             (SYSCON_BASE+0x0008)
+#define SYSCON_STBY             (SYSCON_BASE+0x000c)
+#define SYSCON_BLEOI            (SYSCON_BASE+0x0010)
+#define SYSCON_MCEOI            (SYSCON_BASE+0x0014)
+#define SYSCON_TEOI             (SYSCON_BASE+0x0018)
+#define SYSCON_STFCLR           (SYSCON_BASE+0x001c)
+#define SYSCON_CLKSET1          (SYSCON_BASE+0x0020)
+#define SYSCON_CLKSET2          (SYSCON_BASE+0x0024)
+#define SYSCON_RESV00           (SYSCON_BASE+0x0028)
+#define SYSCON_RESV01           (SYSCON_BASE+0x002c)
+#define SYSCON_RESV02           (SYSCON_BASE+0x0030)
+#define SYSCON_RESV03           (SYSCON_BASE+0x0034)
+#define SYSCON_RESV04           (SYSCON_BASE+0x0038)
+#define SYSCON_RESV05           (SYSCON_BASE+0x003c)
+#define SYSCON_SCRREG0          (SYSCON_BASE+0x0040)
+#define SYSCON_SCRREG1          (SYSCON_BASE+0x0044)
+#define SYSCON_CLKTEST          (SYSCON_BASE+0x0048)
+#define SYSCON_USBRESET         (SYSCON_BASE+0x004c)
+#define SYSCON_APBWAIT          (SYSCON_BASE+0x0050)
+#define SYSCON_BMAR             (SYSCON_BASE+0x0054)
+#define SYSCON_BOOTCLR          (SYSCON_BASE+0x0058)
+#define SYSCON_DEVCFG           (SYSCON_BASE+0x0080)
+#define SYSCON_VIDDIV           (SYSCON_BASE+0x0084)
+#define SYSCON_MIRDIV           (SYSCON_BASE+0x0088)
+#define SYSCON_I2SDIV           (SYSCON_BASE+0x008C)
+#define SYSCON_KTDIV            (SYSCON_BASE+0x0090)
+#define SYSCON_CHIPID           (SYSCON_BASE+0x0094)
+#define SYSCON_TSTCR            (SYSCON_BASE+0x0098)
+#define SYSCON_SYSCFG           (SYSCON_BASE+0x009C)
+#define SYSCON_SWLOCK           (SYSCON_BASE+0x00C0)
+
+#define SYSCON_DEVCFG_KEYS      0x00000002
+#define SYSCON_DEVCFG_RasOnP3   0x00000010
+#define SYSCON_DEVCFG_GONK      0x08000000
+
+#define SYSCON_KTDIV_KEN        0x00008000
+
+
+
+
+
+
+
 
+
+
+
+
+//
 #define EP93XX_ETHERNET_BASE		(EP93XX_AHB_VIRT_BASE + 0x00010000)
 #define EP93XX_ETHERNET_PHYS_BASE	(EP93XX_AHB_PHYS_BASE + 0x00010000)
 
@@ -67,8 +948,11 @@
 #define EP93XX_USB_PHYS_BASE		(EP93XX_AHB_PHYS_BASE + 0x00020000)
 
 #define EP93XX_RASTER_BASE		(EP93XX_AHB_VIRT_BASE + 0x00030000)
+#define EP93XX_RASTER_PHYS_BASE         (EP93XX_AHB_PHYS_BASE + 0x00030000)
 
 #define EP93XX_GRAPHICS_ACCEL_BASE	(EP93XX_AHB_VIRT_BASE + 0x00040000)
+#define EP93XX_GRAPHICS_ACCEL_PHYS_BASE (EP93XX_AHB_PHYS_BASE + 0x00040000
+
 
 #define EP93XX_SDRAM_CONTROLLER_BASE	(EP93XX_AHB_VIRT_BASE + 0x00060000)
 
@@ -77,7 +961,141 @@
 #define EP93XX_BOOT_ROM_BASE		(EP93XX_AHB_VIRT_BASE + 0x00090000)
 
 #define EP93XX_IDE_BASE			(EP93XX_AHB_VIRT_BASE + 0x000a0000)
+#define EP93XX_IDE_REG(x)		(EP93XX_IDE_BASE + (x))
+#define EP93XX_IDE_CTRL			EP93XX_IDE_REG(0x0000)
+#define EP93XX_IDE_CFG			EP93XX_IDE_REG(0x0004)
+#define EP93XX_IDE_DATAOUT		EP93XX_IDE_REG(0x0010)
+#define EP93XX_IDE_DATAIN		EP93XX_IDE_REG(0x0014)
+
+#define EP93XX_IDE_CTRL_CS0n		(1L << 0)
+#define EP93XX_IDE_CTRL_CS1n		(1L << 1)
+#define EP93XX_IDE_CTRL_DA_MASK		0x1C
+#define EP93XX_IDE_CTRL_DA(x)		((x << 2) & EP93XX_IDE_CTRL_DA_MASK)
+#define EP93XX_IDE_CTRL_DA_CS_MASK	(EP93XX_IDE_CTRL_DA_MASK | EP93XX_IDE_CTRL_CS0n | EP93XX_IDE_CTRL_CS1n)
+#define EP93XX_IDE_CTRL_DA_CS(x)	(((x)) & EP93XX_IDE_CTRL_DA_CS_MASK)
+#define EP93XX_IDE_CTRL_DIORn		(1L << 5)
+#define EP93XX_IDE_CTRL_DIOWn		(1L << 6)
+#define EP93XX_IDE_CTRL_DASPn		(1L << 7)
+#define EP93XX_IDE_CTRL_DMARQ		(1L << 8)
+#define EP93XX_IDE_CTRL_INTRQ		(1L << 9)
+#define EP93XX_IDE_CTRL_IORDY		(1L << 10)
+
+#define EP93XX_IDE_CFG_IDEEN		(1L << 0)
+#define EP93XX_IDE_CFG_PIO		(1L << 1)
+#define EP93XX_IDE_CFG_MDMA		(1L << 2)
+#define EP93XX_IDE_CFG_UDMA		(1L << 3)
+#define EP93XX_IDE_CFG_MODE(x)		((x & 0x0F) << 4)
+#define EP93XX_IDE_CFG_WST(x)		((x & 0x03) << 8)
+
+
+
+/* Olde IDE DMA defines */
+/* 800A_0000 - 800A_ffff: IDE Interface  */
+#define IDE_OFFSET              0x0a0000
+#define IDE_BASE                (EP93XX_AHB_VIRT_BASE|IDE_OFFSET)
+#define IDECR                   (IDE_BASE+0x00)
+#define IDECFG                  (IDE_BASE+0x04)
+#define IDEMDMAOP               (IDE_BASE+0x08)
+#define IDEUDMAOP               (IDE_BASE+0x0C)
+#define IDEDATAOUT              (IDE_BASE+0x10)
+#define IDEDATAIN               (IDE_BASE+0x14)
+#define IDEMDMADATAOUT          (IDE_BASE+0x18)
+#define IDEMDMADATAIN           (IDE_BASE+0x1C)
+#define IDEUDMADATAOUT          (IDE_BASE+0x20)
+#define IDEUDMADATAIN           (IDE_BASE+0x24)
+#define IDEUDMASTATUS           (IDE_BASE+0x28)
+#define IDEUDMADEBUG            (IDE_BASE+0x2C)
+#define IDEUDMAWFST             (IDE_BASE+0x30)
+#define IDEUDMARFST             (IDE_BASE+0x34)
+
+/*****************************************************************************
+ *
+ *  Bit definitions for use with assembly code for the ide control register.
+ *
+ ****************************************************************************/
+#define IDECtrl_CS0n			0x00000001
+#define IDECtrl_CS1n			0x00000002
+#define IDECtrl_DA_MASK			0x0000001c
+#define IDECtrl_DA_SHIFT		2
+#define IDECtrl_DIORn			0x00000020
+#define IDECtrl_DIOWn			0x00000040
+#define IDECtrl_DASPn			0x00000080
+#define IDECtrl_DMARQ			0x00000100
+#define IDECtrl_INTRQ			0x00000200
+#define IDECtrl_IORDY			0x00000400
+
+#define IDECfg_IDEEN			0x00000001
+#define IDECfg_PIO			0x00000002
+#define IDECfg_MDMA			0x00000004
+#define IDECfg_UDMA			0x00000008
+#define IDECfg_MODE_MASK		0x000000f0
+#define IDECfg_MODE_SHIFT		4
+#define IDECfg_WST_MASK			0x00000300
+#define IDECfg_WST_SHIFT		8
+
+#define IDEMDMAOp_MEN			0x00000001
+#define IDEMDMAOp_RWOP			0x00000002
+
+#define IDEUDMAOp_UEN			0x00000001
+#define IDEUDMAOp_RWOP			0x00000002
+
+#define IDEUDMASts_CS0n			0x00000001
+#define IDEUDMASts_CS1n			0x00000002
+#define IDEUDMASts_DA_MASK		0x0000001c
+#define IDEUDMASts_DA_SHIFT		2
+#define IDEUDMASts_HSHD			0x00000020
+#define IDEUDMASts_STOP			0x00000040
+#define IDEUDMASts_DM			0x00000080
+#define IDEUDMASts_DDOE			0x00000100
+#define IDEUDMASts_DMARQ		0x00000200
+#define IDEUDMASts_DSDD			0x00000400
+#define IDEUDMASts_DMAide		0x00010000
+#define IDEUDMASts_INTide		0x00020000
+#define IDEUDMASts_SBUSY		0x00040000
+#define IDEUDMASts_NDO			0x01000000
+#define IDEUDMASts_NDI			0x02000000
+#define IDEUDMASts_N4X			0x04000000
+
+#define IDEUDMADebug_RWOE		0x00000001
+#define IDEUDMADebug_RWPTR		0x00000002
+#define IDEUDMADebug_RWDR		0x00000004
+#define IDEUDMADebug_RROE		0x00000008
+#define IDEUDMADebug_RRPTR		0x00000010
+#define IDEUDMADebug_RRDR		0x00000020
+
+#define IDEUDMAWrBufSts_HPTR_MASK	0x0000000f
+#define IDEUDMAWrBufSts_HPTR_SHIFT	0
+#define IDEUDMAWrBufSts_TPTR_MASK	0x000000f0
+#define IDEUDMAWrBufSts_TPTR_SHIFT	4
+#define IDEUDMAWrBufSts_EMPTY		0x00000100
+#define IDEUDMAWrBufSts_HOM		0x00000200
+#define IDEUDMAWrBufSts_NFULL		0x00000400
+#define IDEUDMAWrBufSts_FULL		0x00000800
+#define IDEUDMAWrBufSts_CRC_MASK	0xffff0000
+#define IDEUDMAWrBufSts_CRC_SHIFT	16
+
+#define IDEUDMARdBufSts_HPTR_MASK	0x0000000f
+#define IDEUDMARdBufSts_HPTR_SHIFT	0
+#define IDEUDMARdBufSts_TPTR_MASK	0x000000f0
+#define IDEUDMARdBufSts_TPTR_SHIFT	4
+#define IDEUDMARdBufSts_EMPTY		0x00000100
+#define IDEUDMARdBufSts_HOM		0x00000200
+#define IDEUDMARdBufSts_NFULL		0x00000400
+#define IDEUDMARdBufSts_FULL		0x00000800
+#define IDEUDMARdBufSts_CRC_MASK	0xffff0000
+#define IDEUDMARdBufSts_CRC_SHIFT	16
+
+
+
+
 
+
+
+
+
+
+
+/*----------------------------------old-------------------------------*/
 #define EP93XX_VIC1_BASE		(EP93XX_AHB_VIRT_BASE + 0x000b0000)
 
 #define EP93XX_VIC2_BASE		(EP93XX_AHB_VIRT_BASE + 0x000c0000)
@@ -107,21 +1125,26 @@
 
 #define EP93XX_GPIO_BASE		(EP93XX_APB_VIRT_BASE + 0x00040000)
 #define EP93XX_GPIO_REG(x)		(EP93XX_GPIO_BASE + (x))
-#define EP93XX_GPIO_F_INT_TYPE1		EP93XX_GPIO_REG(0x4c)
-#define EP93XX_GPIO_F_INT_TYPE2		EP93XX_GPIO_REG(0x50)
-#define EP93XX_GPIO_F_INT_ACK		EP93XX_GPIO_REG(0x54)
-#define EP93XX_GPIO_F_INT_ENABLE	EP93XX_GPIO_REG(0x58)
-#define EP93XX_GPIO_F_INT_STATUS	EP93XX_GPIO_REG(0x5c)
 #define EP93XX_GPIO_A_INT_TYPE1		EP93XX_GPIO_REG(0x90)
 #define EP93XX_GPIO_A_INT_TYPE2		EP93XX_GPIO_REG(0x94)
 #define EP93XX_GPIO_A_INT_ACK		EP93XX_GPIO_REG(0x98)
 #define EP93XX_GPIO_A_INT_ENABLE	EP93XX_GPIO_REG(0x9c)
 #define EP93XX_GPIO_A_INT_STATUS	EP93XX_GPIO_REG(0xa0)
+#define EP93XX_GPIO_A_INT_DEBOUNCE	EP93XX_GPIO_REG(0xa8)
 #define EP93XX_GPIO_B_INT_TYPE1		EP93XX_GPIO_REG(0xac)
 #define EP93XX_GPIO_B_INT_TYPE2		EP93XX_GPIO_REG(0xb0)
 #define EP93XX_GPIO_B_INT_ACK		EP93XX_GPIO_REG(0xb4)
 #define EP93XX_GPIO_B_INT_ENABLE	EP93XX_GPIO_REG(0xb8)
 #define EP93XX_GPIO_B_INT_STATUS	EP93XX_GPIO_REG(0xbc)
+#define EP93XX_GPIO_B_INT_DEBOUNCE	EP93XX_GPIO_REG(0xc4)
+
+#define EP93XX_GPIO_F_INT_TYPE1         EP93XX_GPIO_REG(0x4c)
+#define EP93XX_GPIO_F_INT_TYPE2         EP93XX_GPIO_REG(0x50)
+#define EP93XX_GPIO_F_INT_ACK           EP93XX_GPIO_REG(0x54)
+#define EP93XX_GPIO_F_INT_ENABLE        EP93XX_GPIO_REG(0x58)
+#define EP93XX_GPIO_F_INT_STATUS        EP93XX_GPIO_REG(0x5c)
+
+/*-------------------------------------------------------------------------------*/
 
 #define EP93XX_AAC_BASE			(EP93XX_APB_VIRT_BASE + 0x00080000)
 
@@ -155,10 +1178,15 @@
 #define EP93XX_SYSCON_CLOCK_USH_EN	0x10000000
 #define EP93XX_SYSCON_HALT		EP93XX_SYSCON_REG(0x08)
 #define EP93XX_SYSCON_STANDBY		EP93XX_SYSCON_REG(0x0c)
+#define EP93XX_SYSCON_CLKSET1           EP93XX_SYSCON_REG(0x20)
 #define EP93XX_SYSCON_CLOCK_SET1	EP93XX_SYSCON_REG(0x20)
+#define EP93XX_SYSCON_CLKSET2           EP93XX_SYSCON_REG(0x24)
 #define EP93XX_SYSCON_CLOCK_SET2	EP93XX_SYSCON_REG(0x24)
 #define EP93XX_SYSCON_DEVICE_CONFIG	EP93XX_SYSCON_REG(0x80)
 #define EP93XX_SYSCON_DEVICE_CONFIG_CRUNCH_ENABLE	0x00800000
+
+#define EP93XX_SYSCON_BMAR              EP93XX_SYSCON_REG(0x54)
+#define EP93XX_SYSCON_CHIPID           	EP93XX_SYSCON_REG(0x94)
 #define EP93XX_SYSCON_SWLOCK		EP93XX_SYSCON_REG(0xc0)
 
 #define EP93XX_WATCHDOG_BASE		(EP93XX_APB_VIRT_BASE + 0x00140000)
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/hardware.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/hardware.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/hardware.h	2009-04-27 17:37:11.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/hardware.h	2009-05-06 06:52:19.000000000 +0000
@@ -5,6 +5,13 @@
 #define __ASM_ARCH_HARDWARE_H
 
 #include "ep93xx-regs.h"
+#include "regs_syscon.h"
+#include "regs_dma.h"
+#include "regs_ac97.h"
+#include "regs_smc.h"
+#include "regs_spi.h"
+
+#include "memory.h"
 
 #define pcibios_assign_all_busses()	0
 
@@ -12,4 +19,31 @@
 
 #include "ts72xx.h"
 
+#if (defined(CONFIG_MACH_EDB9315A) || defined(CONFIG_MACH_EDB9307A) || defined(CONFIG_MACH_EDB9302A))
+#define EP93XX_PARAMS_PHYS	0xc0000100
+#define EP93XX_ZREL_ADDR	0xc0008000
+#define EP93XX_PHYS_ADDR	0xc0000000
+/*#define EP93XX_INITRD_PHYS	0x01000000*/
+
+#else
+#define EP93XX_PARAMS_PHYS      0x00000100
+#define EP93XX_ZREL_ADDR        0x00008000
+#define EP93XX_PHYS_ADDR        0x00000000
+/*#define EP93XX_INITRD_PHYS	0x01000000*/
+#endif
+
+#ifndef MSECS_TO_JIFFIES
+#define MSECS_TO_JIFFIES(ms) (((ms)*HZ+999)/1000)
+#endif
+
+#if (defined(CONFIG_MACH_EDB9312) || defined(CONFIG_MACH_EDB9315) || defined(CONFIG_MACH_EDB9307) )
+#define EP93XX_FLASH_BASE   0x60000000
+#define EP93XX_FLASH_WIDTH  4
+#define EP93XX_FLASH_SIZE   0x02000000
+#else
+#define EP93XX_FLASH_BASE   0x60000000
+#define EP93XX_FLASH_WIDTH  2
+#define EP93XX_FLASH_SIZE   0x00800000
+#endif
+
 #endif
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_ac97.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_ac97.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_ac97.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_ac97.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,180 @@
+/*=============================================================================
+ *  FILE:           regs_ac97.h
+ *
+ *  DESCRIPTION:    Ac'97 Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *=============================================================================
+ */
+#ifndef _REGS_AC97_H_
+#define _REGS_AC97_H_
+
+//-----------------------------------------------------------------------------
+// Bit definitionses
+//-----------------------------------------------------------------------------
+#define AC97ISR_RIS                     8
+#define AC97ISR_TIS                     4
+#define AC97ISR_RTIS                    2
+#define AC97ISR_TCIS                    1
+
+#define AC97RGIS_SLOT1TXCOMPLETE     0x01
+#define AC97RGIS_SLOT2RXVALID        0x02
+#define AC97RGIS_GPIOTXCOMPLETE      0x04
+#define AC97RGIS_GPIOINTRX           0x08
+#define AC97RGIS_RWIS                0x10
+#define AC97RGIS_CODECREADY          0x20
+#define AC97RGIS_SLOT2TXCOMPLETE     0x40
+
+#define AC97SR_RXFE                 0x0001
+#define AC97SR_TXFE                 0x0002      
+#define AC97SR_RXFF                 0x0004
+#define AC97SR_TXFF                 0x0008
+#define AC97SR_TXBUSY               0x0010
+#define AC97SR_RXOE                 0x0020
+#define AC97SR_TXUE                 0x0040
+
+#define AC97GSR_IFE                     0x1
+#define AC97GSR_LOOP                    0x2
+#define AC97GSR_OVERRIDECODECREADY      0x4
+
+#define AC97RESET_TIMEDRESET            0x1
+#define AC97RESET_FORCEDRESET           0x2
+#define AC97RESET_EFORCER               0x4
+
+#define AC97RXCR_REN                    0x1
+
+#define AC97TXCR_TEN                    0x1
+
+
+//****************************************************************************
+//
+// The Ac97 Codec registers, accessable through the Ac-link.
+// These are not controller registers and are not memory mapped.
+// Includes registers specific to CS4202 (Beavis).
+//
+//****************************************************************************
+#define AC97_REG_OFFSET_MASK                0x0000007E
+
+#define AC97_00_RESET                          0x00000000
+#define AC97_02_MASTER_VOL                     0x00000002
+#define AC97_04_HEADPHONE_VOL                  0x00000004
+#define AC97_06_MONO_VOL                       0x00000006
+#define AC97_08_TONE                           0x00000008
+#define AC97_0A_PC_BEEP_VOL                    0x0000000A
+#define AC97_0C_PHONE_VOL                      0x0000000C
+#define AC97_0E_MIC_VOL                        0x0000000E
+#define AC97_10_LINE_IN_VOL                    0x00000010
+#define AC97_12_CD_VOL                         0x00000012
+#define AC97_14_VIDEO_VOL                      0x00000014
+#define AC97_16_AUX_VOL                        0x00000016
+#define AC97_18_PCM_OUT_VOL                    0x00000018
+#define AC97_1A_RECORD_SELECT                  0x0000001A
+#define AC97_1C_RECORD_GAIN                    0x0000001C
+#define AC97_1E_RESERVED_1E                    0x0000001E
+#define AC97_20_GENERAL_PURPOSE                0x00000020
+#define AC97_22_3D_CONTROL                     0x00000022
+#define AC97_24_MODEM_RATE                     0x00000024
+#define AC97_26_POWERDOWN                      0x00000026
+#define AC97_28_EXT_AUDIO_ID                   0x00000028
+#define AC97_2A_EXT_AUDIO_POWER                0x0000002A
+#define AC97_2C_PCM_FRONT_DAC_RATE             0x0000002C
+#define AC97_2E_PCM_SURR_DAC_RATE              0x0000002E
+#define AC97_30_PCM_LFE_DAC_RATE               0x00000030
+#define AC97_32_PCM_LR_ADC_RATE                0x00000032
+#define AC97_34_MIC_ADC_RATE                   0x00000034
+#define AC97_36_6CH_VOL_C_LFE                  0x00000036
+#define AC97_38_6CH_VOL_SURROUND               0x00000038
+#define AC97_3A_SPDIF_CONTROL                  0x0000003A
+#define AC97_3C_EXT_MODEM_ID                   0x0000003C
+#define AC97_3E_EXT_MODEM_POWER                0x0000003E
+#define AC97_40_LINE1_CODEC_RATE               0x00000040
+#define AC97_42_LINE2_CODEC_RATE               0x00000042
+#define AC97_44_HANDSET_CODEC_RATE             0x00000044
+#define AC97_46_LINE1_CODEC_LEVEL              0x00000046
+#define AC97_48_LINE2_CODEC_LEVEL              0x00000048
+#define AC97_4A_HANDSET_CODEC_LEVEL            0x0000004A
+#define AC97_4C_GPIO_PIN_CONFIG                0x0000004C
+#define AC97_4E_GPIO_PIN_TYPE                  0x0000004E
+#define AC97_50_GPIO_PIN_STICKY                0x00000050
+#define AC97_52_GPIO_PIN_WAKEUP                0x00000052
+#define AC97_54_GPIO_PIN_STATUS                0x00000054
+#define AC97_56_RESERVED                       0x00000056
+#define AC97_58_RESERVED                       0x00000058
+#define AC97_5A_CRYSTAL_REV_N_FAB_ID           0x0000005A
+#define AC97_5C_TEST_AND_MISC_CTRL             0x0000005C
+#define AC97_5E_AC_MODE                        0x0000005E
+#define AC97_60_MISC_CRYSTAL_CONTROL           0x00000060
+#define AC97_62_VENDOR_RESERVED                0x00000062
+#define AC97_64_DAC_SRC_PHASE_INCR             0x00000064
+#define AC97_66_ADC_SRC_PHASE_INCR             0x00000066
+#define AC97_68_RESERVED_68                    0x00000068
+#define AC97_6A_SERIAL_PORT_CONTROL            0x0000006A
+#define AC97_6C_VENDOR_RESERVED                0x0000006C
+#define AC97_6E_VENDOR_RESERVED                0x0000006E
+#define AC97_70_BDI_CONFIG                     0x00000070
+#define AC97_72_BDI_WAKEUP                     0x00000072
+#define AC97_74_VENDOR_RESERVED                0x00000074
+#define AC97_76_CAL_ADDRESS                    0x00000076
+#define AC97_78_CAL_DATA                       0x00000078
+#define AC97_7A_VENDOR_RESERVED                0x0000007A
+#define AC97_7C_VENDOR_ID1                     0x0000007C
+#define AC97_7E_VENDOR_ID2                     0x0000007E
+
+
+#ifndef __ASSEMBLY__
+
+//
+// enum type for use with reg AC97_RECORD_SELECT
+//
+typedef enum{
+    RECORD_MIC          = 0x0000,
+    RECORD_CD           = 0x0101,
+    RECORD_VIDEO_IN     = 0x0202,
+    RECORD_AUX_IN       = 0x0303,
+    RECORD_LINE_IN      = 0x0404,
+    RECORD_STEREO_MIX   = 0x0505,
+    RECORD_MONO_MIX     = 0x0606,
+    RECORD_PHONE_IN     = 0x0707
+} Ac97RecordSources;
+
+#endif /* __ASSEMBLY__ */
+
+//
+// Sample rates supported directly in AC97_PCM_FRONT_DAC_RATE and 
+// AC97_PCM_LR_ADC_RATE.
+//
+#define Ac97_Fs_8000        0x1f40
+#define Ac97_Fs_11025       0x2b11
+#define Ac97_Fs_16000       0x3e80
+#define Ac97_Fs_22050       0x5622
+#define Ac97_Fs_32000       0x7d00
+#define Ac97_Fs_44100       0xac44
+#define Ac97_Fs_48000       0xbb80
+
+//
+// RSIZE and TSIZE in AC97RXCR and AC97TXCR
+//
+#define Ac97_SIZE_20            2
+#define Ac97_SIZE_18            1
+#define Ac97_SIZE_16            0
+#define Ac97_SIZE_12            3
+
+//=============================================================================
+//=============================================================================
+
+
+#endif /* _REGS_AC97_H_ */
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_dma.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_dma.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_dma.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_dma.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,276 @@
+/*****************************************************************************
+ *  
+ * linux/arch/arm/mach-ep93xx/include/mach/regs_dma.h
+ *
+ *  Register definitions for the ep93xx dma channel registers.
+ *
+ *  Copyright (C) 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#ifndef _REGS_DMA_H_
+#define _REGS_DMA_H_
+
+/*****************************************************************************
+ * 0x8000.0000 -> 0x8000.003C M2P Channel 0 Registers (Tx) 
+ * 0x8000.0040 -> 0x8000.007C M2P Channel 1 Registers (Rx) 
+ * 0x8000.0080 -> 0x8000.00BC M2P Channel 2 Registers (Tx)  
+ * 0x8000.00C0 -> 0x8000.00FC M2P Channel 3 Registers (Rx) 
+ * 0x8000.0100 -> 0x8000.013C M2M Channel 0 Registers      
+ * 0x8000.0140 -> 0x8000.017C M2M Channel 1 Registers      
+ * 0x8000.0180 -> 0x8000.01BC Not Used                     
+ * 0x8000.01C0 -> 0x8000.01FC Not Used                     
+ * 0x8000.0200 -> 0x8000.023C M2P Channel 5 Registers (Rx) 
+ * 0x8000.0240 -> 0x8000.027C M2P Channel 4 Registers (Tx) 
+ * 0x8000.0280 -> 0x8000.02BC M2P Channel 7 Registers (Rx) 
+ * 0x8000.02C0 -> 0x8000.02FC M2P Channel 6 Registers (Tx) 
+ * 0x8000.0300 -> 0x8000.033C M2P Channel 9 Registers (Rx) 
+ * 0x8000.0340 -> 0x8000.037C M2P Channel 8 Registers (Tx) 
+ * 0x8000.0380 DMA Channel Arbitration register            
+ * 0x8000.03C0 DMA Global Interrupt register               
+ * 0x8000.03C4 -> 0x8000.03FC Not Used                     
+ *
+ *
+ * Internal M2P/P2M Channel Register Map                   
+ *
+ * Offset Name      Access  Bits Reset Value               
+ * 0x00   CONTROL   R/W     6    0                         
+ * 0x04   INTERRUPT R/W TC* 3    0                         
+ * 0x08   PPALLOC   R/W     4    channel dependant         
+ *                               (see reg description)     
+ * 0x0C   STATUS    RO      8    0                         
+ * 0x10   reserved                                         
+ * 0x14   REMAIN    RO      16   0                         
+ * 0X18   Reserved                                         
+ * 0X1C   Reserved                                         
+ * 0x20   MAXCNT0   R/W     16   0                         
+ * 0x24   BASE0     R/W     32   0                         
+ * 0x28   CURRENT0  RO      32   0                         
+ * 0x2C   Reserved                                         
+ * 0x30   MAXCNT1   R/W     16   0                         
+ * 0x34   BASE1     R/W     32   0                         
+ * 0X38   CURRENT1  RO      32   0                         
+ * 0X3C   Reserved                                         
+ *                                                         
+ * M2M Channel Register Map                                
+ * Offset Name         Access   Bits Reset Value           
+ *                                                         
+ * 0x00   CONTROL      R/W      22   0                     
+ * 0x04   INTERRUPT    R/W TC*  3    0                     
+ * 0x08   Reserved                                         
+ * 0x0C   STATUS       R/W TC*  14   0                     
+ * 0x10   BCR0         R/W      16   0                     
+ * 0x14   BCR1         R/W      16   0                     
+ * 0x18   SAR_BASE0    R/W      32   0                     
+ * 0x1C   SAR_BASE1    R/W      32   0                     
+ * 0x20   Reserved                                         
+ * 0x24   SAR_CURRENT0 RO       32   0                     
+ * 0x28   SAR_CURRENT1 RO       32   0                     
+ * 0x2C   DAR_BASE0    R/W      32   0                     
+ * 0x30   DAR_BASE1    R/W      32   0                     
+ * 0x34   DAR_CURRENT0 RO       32   0                     
+ * 0X38   Reserved                                         
+ * 0X3C   DAR_CURRENT1 RO       32   0                          
+ * * Write this location once to clear the bit (see        
+ * Interrupt/Status register description for which bits    
+ * this rule applies to).
+ *                                  
+ ****************************************************************************/
+
+#ifndef __ASSEMBLY__ 
+/*
+ * DMA Register Base addresses
+ */
+static unsigned int const DMAM2PChannelBase[10] =
+{
+    DMA_M2P_TX_0_BASE,
+    DMA_M2P_RX_1_BASE,
+    DMA_M2P_TX_2_BASE,
+    DMA_M2P_RX_3_BASE,
+    DMA_M2P_TX_4_BASE,
+    DMA_M2P_RX_5_BASE,
+    DMA_M2P_TX_6_BASE,
+    DMA_M2P_RX_7_BASE,
+    DMA_M2P_TX_8_BASE,
+    DMA_M2P_RX_9_BASE
+};
+
+static unsigned int const DMAM2MChannelBase[2] = 
+{
+    DMA_M2M_0_BASE,
+    DMA_M2M_1_BASE
+};
+
+#endif /* __ASSEMBLY__ */
+
+/*----------------------------------------------------------------------------------*/
+/* M2P Registers                                                                    */
+/*----------------------------------------------------------------------------------*/
+/*
+ * M2P CONTROL register bit defines 
+ */
+#define CONTROL_M2P_STALLINTEN      0x00000001	    /* Enables the STALL interrupt  */
+#define CONTROL_M2P_NFBINTEN        0x00000002	    /* Enables the NFB interrupt    */
+#define CONTROL_M2P_CHERRORINTEN    0x00000008      /* Enables the ChError interrupt*/
+#define CONTROL_M2P_ENABLE		    0x00000010      /* Enables the channel          */
+#define CONTROL_M2P_ABRT		    0x00000020      /* Determines how DMA behaves in*/ 
+			                                        /* NEXT state with peripheral   */
+                                                    /* error                        */
+			                                        /* 0: NEXT -> ON, ignore error  */
+			                                        /* 1: NEXT -> STALL, disable ch.*/ 
+#define CONTROL_M2P_ICE			    0x00000040      /* Ignore Channel Error         */
+
+/*
+ * M2P INTERRUPT register bit defines
+ */
+#define INTERRUPT_M2P_STALLINT      0x00000001	    /* Indicates channel stalled.   */
+#define INTERRUPT_M2P_NFBINT        0x00000002		/* Indicates channel is hungry. */
+#define INTERRUPT_M2P_CHERRORINT    0x00000008	    /* Peripheral detects error     */
+
+
+/*
+ * STATUS register bit defines
+ */
+#define STATUS_M2P_STALL            0x00000001		/* A '1' indicates channel is       */
+                                                    /* stalled                          */
+#define STATUS_M2P_NFB			    0x00000002      /* A '1' indicates channel has moved*/
+			                                        /* from NEXT state to ON state, but */
+			                                        /* waiting for next buffer to be    */
+                                                    /* programmed.                      */
+#define STATUS_M2P_CHERROR		    0x00000008      /* Enables the ChError interrupt    */
+#define STATUS_M2P_CURRENT_MASK     0x00000030      /* Current state of the FSM         */
+#define STATUS_M2P_CURRENT_SHIFT    4
+#define STATUS_M2P_NEXTBUFFER	    0x00000040      /* Informs the int handler after an */
+			                                        /* NFB int which pair of maxcnt and */
+                                                    /* base regs to update.             */
+#define STATUS_M2P_BYTES_MASK       0x0000f800 		/* number of valid DMA data         */
+#define STATUS_M2P_BYTES_SHIFT      7               /* currently in                     */
+								        		    /* packer/unpacker                  */
+
+#define STATUS_M2P_DMA_NO_BUF		0x00000000
+#define STATUS_M2P_DMA_BUF_ON		0x00000010
+#define STATUS_M2P_DMA_BUF_NEXT		0x00000020
+
+/*
+ * Register masks to mask off reserved bits after reading register.
+ */
+#define M2P_MASK_PPALLOC            0x0000000f
+#define M2P_MASK_REMAIN             0x0000ffff
+#define M2P_MASK_MAXCNT0            0x0000ffff
+#define M2P_MASK_BASE0              0xffffffff
+#define M2P_MASK_CURRENT0           0xffffffff
+#define M2P_MASK_MAXCNT1            0x0000ffff
+#define M2P_MASK_BASE1              0xffffffff
+#define M2P_MASK_CURRENT1           0xffffffff
+
+
+/*----------------------------------------------------------------------------------*/
+/* M2M Registers                                                                    */
+/*----------------------------------------------------------------------------------*/
+
+#define CONTROL_M2M_STALLINTEN	0x00000001  /* Enables the STALL interrupt                     */
+#define CONTROL_M2M_SCT			0x00000002  /* Source Copy Transfer. Setup a                   */
+										    /* block transfer from 1 memory source             */
+										    /* location.                                       */
+#define CONTROL_M2M_DONEINTEN	0x00000004  /* Enables the DONE interrupt which                */
+										    /* indicates if the xfer completed                 */
+										    /* successfully                                    */
+#define CONTROL_M2M_ENABLE		0x00000008  /* Enables the channel                             */
+#define CONTROL_M2M_START		0x00000010  /* Initiates the xfer. 'software trigger'          */
+#define CONTROL_M2M_BWC_MASK	0x000001e0  /* Bandwidth control. Indicate number of           */
+#define CONTROL_M2M_BWC_SHIFT   5			/* bytes in a transfer.                            */
+#define CONTROL_M2M_PW_MASK		0x00000600  /* Peripheral width. Used for xfers                */
+#define CONTROL_M2M_PW_SHIFT    9			/* between memory and external peripheral.         */
+										    /* 00: byte, 01: halfword, 10: word.               */
+#define CONTROL_M2M_DAH			0x00000800  /* Destination Address Hold                        */
+#define CONTROL_M2M_SAH			0x00001000  /* Source Address Hold                             */
+#define CONTROL_M2M_TM_MASK     0x00006000  /* Transfer Mode. 00: sw triggered,                */
+#define CONTROL_M2M_TM_SHIFT    13			/* 01: hw initiated M2P, 01: hw initiated P2M      */
+#define CONTROL_M2M_ETDP_MASK	0x00018000  /* End-of-Transfer/Terminal Count pin              */
+#define CONTROL_M2M_ETDP_SHIFT  15		    /* direction and polarity.                         */
+#define CONTROL_M2M_DACKP		0x00020000  /* DMA acknowledge pin polarity                    */
+
+#define CONTROL_M2M_DREQP_MASK  0x00180000	/* DMA request pin polarity. must be set           */
+#define CONTROL_M2M_DREQP_SHIFT 19			/* before enable bit.                              */
+#define CONTROL_M2M_NFBINTEN	0x00200000  /* Enables generation of the NFB interrupt.        */
+#define CONTROL_M2M_RSS_MASK    0x00c00000	/* Request source selection:                       */
+#define CONTROL_M2M_RSS_SHIFT	22			/*		000 - External DReq[0]                     */
+										    /*		001 - External DReq[1]                     */
+										    /*		01X - Internal SSPRx                       */
+										    /*		10X - Internal SSPTx                       */
+										    /*		11X - Internal IDE                         */
+#define CONTROL_M2M_NO_HDSK		0x01000000  /* No handshake.  When set the peripheral doesn't  */
+										    /* require the regular handshake protocal. Must    */
+									    	/* be set for SSP and IDE operations, optional     */
+										    /* for external peripherals.                       */
+#define CONTROL_M2M_PWSC_MASK   0xfe000000	/* Peripheral wait states count. Gives the latency */
+#define CONTROL_M2M_PWSC_SHIFT	25			/* (in PCLK cycles) needed by the peripheral to    */
+								    		/* deassert its' request once the M2M xfer w/ DMA  */
+									    	/* is complete.                                    */
+
+/*
+ * M2M INTERRUPT register bit defines
+ */
+#define INTERRUPT_M2M_STALLINT	0x00000001	/* Stall interrupt indicates channel stalled. */
+#define INTERRUPT_M2M_DONEINT	0x00000002	/* Transaction done.                          */
+#define INTERRUPT_M2M_NFBINT	0x00000004	/* Next frame buffer interrupt indicates      */
+											/* channel requires a new buffer              */
+
+
+
+/*
+ * M2M STATUS register bit defines
+ */
+#define STATUS_M2M_STALL		0x00000001  /* A '1' indicates channel is stalled           */
+#define STATUS_M2M_CURRENTSTATE_MASK  0x0000003e  /* Indicates state of M2M Channel control       */
+#define STATUS_M2M_CURRENTSTATE_SHIFT 1		/* FSM (0-2):                                   */
+										    /*	000 - IDLE, 001 - STALL, 010 - MEM_RD,      */
+										    /*  011 - MEM_WR, 100 - BWC_WAIT                */
+										    /* and M2M buffer FSM (3-2):                    */
+										    /* 	00 - NO_BUF, 01 - BUF_ON, 10 - BUF_NEXT     */
+#define STATUS_M2M_DONE		    0x00000040  /* Transfer completed successfully if 1.        */
+#define STATUS_M2M_TCS_MASK		0x00000180  /* Terminal Count status. Indicates whether or  */
+#define STATUS_M2M_TCS_SHIFT    7			/* or not the actual byte count reached         */
+								    		/* programmed limit for buffer descriptor       */
+#define STATUS_M2M_EOTS_MASK    0x00000600  /* End-of-Transfer status for buffer            */
+#define STATUS_M2M_EOTS_SHIFT   9
+#define STATUS_M2M_NFB			0x00000800  /* A '1' indicates channel has moved            */
+										    /* from NEXT state to ON state, but	the next    */
+										    /* byte count reg for next buffer has not been  */
+										    /* programmed yet.                              */
+#define STATUS_M2M_NB			0x00001000  /* NextBuffer status. Informs NFB service       */
+										    /* routine, after NFB int, which pair of buffer */
+										    /* descriptor registers is free to update.      */
+#define STATUS_M2M_DREQS		0x00002000  /* DREQ status.  Reflects the status of the     */
+										    /* synchronized external peripherals DMA        */
+										    /* request signal.                              */
+
+/*
+ * Register masks to mask off reserved bits after reading register.
+ */
+#define M2M_MASK_BCR0             0x0000ffff
+#define M2M_MASK_BCR1             0x0000ffff
+#define M2M_MASK_SAR_BASE0        0xffffffff
+#define M2M_MASK_SAR_BASE1        0xffffffff
+#define M2M_MASK_SAR_CURRENT0     0xffffffff
+#define M2M_MASK_SAR_CURRENT1     0xffffffff
+#define M2M_MASK_DAR_BASE0        0xffffffff
+#define M2M_MASK_DAR_BASE1        0xffffffff
+#define M2M_MASK_DAR_CURRENT0     0xffffffff
+#define M2M_MASK_DAR_CURRENT1     0xffffffff
+
+
+#endif /* _REGS_DMA_H_ */
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_i2s.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_i2s.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_i2s.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_i2s.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,97 @@
+/*=============================================================================
+ *
+ *  FILE:       	reg_i2s.h
+ *
+ *  DESCRIPTION:    ep93xx I2S Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *=============================================================================
+ */
+#ifndef _REG_I2S_H_
+#define _REG_I2S_H_
+
+//
+// I2STXClkCfg bits
+//
+#define i2s_txcc_trls           0x00000001
+#define i2s_txcc_tckp           0x00000002
+#define i2s_txcc_trel           0x00000004
+#define i2s_txcc_mstr           0x00000008
+#define i2s_txcc_nbcg           0x00000010
+
+#define i2s_txcc_bcr_32x        0x00000020
+#define i2s_txcc_bcr_64x        0x00000040
+#define i2s_txcc_bcr_128x       0x00000060
+
+//
+// I2SRxClkCfg bits
+//
+#define i2s_rxcc_rrls           0x00000001
+#define i2s_rxcc_rckp           0x00000002
+#define i2s_rxcc_rrel           0x00000004
+#define i2s_rxcc_mstr           0x00000008
+#define i2s_rxcc_nbcg           0x00000010
+
+#define i2s_rxcc_bcr_32x        0x00000020
+#define i2s_rxcc_bcr_64x        0x00000040
+#define i2s_rxcc_bcr_128x       0x00000060
+
+//
+// I2SGlSts bits
+//
+#define TX0_UNDERFLOW           0x00000001
+#define TX1_UNDERFLOW           0x00000002
+#define TX2_UNDERFLOW           0x00000004
+
+#define RX0_OVERFLOW            0x00000008
+#define RX1_OVERFLOW            0x00000010
+#define RX2_OVERFLOW            0x00000020
+
+#define TX0_OVERFLOW            0x00000040
+#define TX1_OVERFLOW            0x00000080
+#define TX2_OVERFLOW            0x00000100
+
+#define RX0_UNDERFLOW           0x00000200
+#define RX1_UNDERFLOW           0x00000400
+#define RX2_UNDERFLOW           0x00000800
+
+#define TX0_FIFO_FULL           0x00001000
+#define TX0_FIFO_EMPTY          0x00002000
+#define TX0_FIFO_HALF_EMPTY     0x00004000
+
+#define RX0_FIFO_FULL           0x00008000
+#define RX0_FIFO_EMPTY          0x00010000
+#define RX0_FIFO_HALF_FULL      0x00020000
+
+#define TX1_FIFO_FULL           0x00040000
+#define TX1_FIFO_EMPTY          0x00080000
+#define TX1_FIFO_HALF_EMPTY     0x00100000
+
+#define RX1_FIFO_FULL           0x00200000
+#define RX1_FIFO_EMPTY          0x00400000
+#define RX1_FIFO_HALF_FULL      0x00800000
+
+#define TX2_FIFO_FULL           0x01000000
+#define TX2_FIFO_EMPTY          0x02000000
+#define TX2_FIFO_HALF_EMPTY     0x04000000
+
+#define RX2_FIFO_FULL           0x08000000
+#define RX2_FIFO_EMPTY          0x10000000
+#define RX2_FIFO_HALF_FULL      0x20000000
+
+#endif // _REG_I2S_H_
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_smc.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_smc.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_smc.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_smc.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,57 @@
+/*=======================================================================
+ *
+ *  FILE:       regs_smc.h
+ *
+ *  DESCRIPTION:    Static Memory Controller/PCMCIA Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2004
+ *
+ *=======================================================================
+ */
+#ifndef _REGS_SMC_H_
+#define _REGS_SMC_H_
+
+/* Bit definitions */
+
+//
+// Bit fields for SMCBCR?
+//
+#define SMCBCR_IDCY_MASK		0x0000000f
+#define SMCBCR_WST1_MASK		0x000003e0
+#define SMCBCR_RBLE			0x00000400
+#define SMCBCR_WST2_MASK		0x0000f800
+#define SMCBCR_WPERR			0x02000000
+#define SMCBCR_WP			0x04000000
+#define SMCBCR_PME			0x08000000
+#define SMCBCR_MW_MASK			0x30000000
+#define SMCBCR_MW_8			0x00000000
+#define SMCBCR_MW_16			0x10000000
+#define SMCBCR_MW_32			0x20000000
+#define SMCBCR_EBIBRKDIS		0x40000000
+#define SMCBCR_IDCY_SHIFT		0
+#define SMCBCR_WST1_SHIFT		5
+#define SMCBCR_WST2_SHIFT		11
+#define SMCBCR_MW_SHIFT			28
+
+//
+// Bit field for SMC_PCAttribute, SMC_PCCommon, and SMC_PCIO
+//      
+#define PCCONFIG_ADDRESSTIME_MASK   0x000000FF
+#define PCCONFIG_HOLDTIME_MASK      0x00000F00
+#define PCCONFIG_ACCESSTIME_MASK    0x00FF0000
+#define PCCONFIG_MW_8BIT            0x00000000
+#define PCCONFIG_MW_16BIT           0x80000000
+#define PCCONFIG_ADDRESSTIME_SHIFT  0
+#define PCCONFIG_HOLDTIME_SHIFT     8
+#define PCCONFIG_ACCESSTIME_SHIFT   16
+
+//
+// Bit field for SMC_PCMCIACtrl
+//
+#define PCCONT_PC1EN                0x00000001
+#define PCCONT_PC2EN                0x00000002
+#define PCCONT_PC1RST               0x00000004
+#define PCCONT_WEN                  0x00000010
+
+
+#endif /* _REGS_SMC_H_ */
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_spi.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_spi.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_spi.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_spi.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,87 @@
+/*=======================================================================
+ *
+ *  FILE:       regs_spi.h
+ *
+ *  DESCRIPTION:    SSP Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *=======================================================================
+ */
+ 
+#ifndef _REGS_SSP_H_
+#define _REGS_SSP_H_
+
+//-----------------------------------------------------------------------------
+// Bits in SSPCR0
+//-----------------------------------------------------------------------------
+#define SSPCR0_DSS_MASK             0x0000000f
+#define SSPCR0_DSS_4BIT             0x00000003
+#define SSPCR0_DSS_5BIT             0x00000004
+#define SSPCR0_DSS_6BIT             0x00000005
+#define SSPCR0_DSS_7BIT             0x00000006
+#define SSPCR0_DSS_8BIT             0x00000007
+#define SSPCR0_DSS_9BIT             0x00000008
+#define SSPCR0_DSS_10BIT            0x00000009
+#define SSPCR0_DSS_11BIT            0x0000000a
+#define SSPCR0_DSS_12BIT            0x0000000b
+#define SSPCR0_DSS_13BIT            0x0000000c
+#define SSPCR0_DSS_14BIT            0x0000000d
+#define SSPCR0_DSS_15BIT            0x0000000e
+#define SSPCR0_DSS_16BIT            0x0000000f
+
+//-----------------------------------------------------------------------------
+// Bits in SSPCR1
+//-----------------------------------------------------------------------------
+#define SSPC1_RIE                   0x00000001
+#define SSPC1_TIE                   0x00000002
+#define SSPC1_RORIE		            0x00000004
+#define SSPC1_LBM                   0x00000008
+#define SSPC1_SSE                   0x00000010
+#define SSPC1_MS                    0x00000020
+#define SSPC1_SOD                   0x00000040
+
+#define SSPCR0_DSS_SHIFT            0
+#define SSPCR0_FRF_MASK             0x00000030
+#define SSPCR0_FRF_SHIFT            4
+#define SSPCR0_FRF_MOTOROLA         (0 << SSPCR0_FRF_SHIFT)
+#define SSPCR0_FRF_TI               (1 << SSPCR0_FRF_SHIFT)
+#define SSPCR0_FRF_NI               (2 << SSPCR0_FRF_SHIFT)
+#define SSPCR0_SPO                  0x00000040
+#define SSPCR0_SPH                  0x00000080
+#define SSPCR0_SCR_MASK             0x0000ff00
+#define SSPCR0_SCR_SHIFT            8
+
+//-----------------------------------------------------------------------------
+// Bits in SSPSR
+//-----------------------------------------------------------------------------
+#define SSPSR_TFE		    0x00000001      // TX FIFO is empty
+#define SSPSR_TNF    		0x00000002      // TX FIFO is not full
+#define SSPSR_RNE        	0x00000004      // RX FIFO is not empty
+#define SSPSR_RFF   		0x00000008      // RX FIFO is full
+#define SSPSR_BSY			0x00000010      // SSP is busy
+
+//-----------------------------------------------------------------------------
+// Bits in SSPIIR
+//-----------------------------------------------------------------------------
+#define SSPIIR_RIS			0x00000001      // RX FIFO IRQ status
+#define SSPIIR_TIS			0x00000002      // TX FIFO is not full
+#define SSPIIR_RORIS		0x00000004      // RX FIFO is full
+
+//=============================================================================
+//=============================================================================
+
+#endif /* _REGS_SSP_H_ */
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_syscon.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_syscon.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/regs_syscon.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/regs_syscon.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,286 @@
+/*=============================================================================
+ *
+ *  FILE:       	reg_syscon.h
+ *
+ *  DESCRIPTION:    ep93xx Syscon Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *=============================================================================
+ */
+#ifndef _REGS_SYSCON_H_
+#define _REGS_SYSCON_H_
+
+//=============================================================================
+#ifndef __ASSEMBLY__
+
+#define SysconSetLocked(registername,value)     \
+    {                                           \
+        local_irq_disable();			\
+	outl( 0xAA, EP93XX_SYSCON_SWLOCK);             \
+        outl( value, registername);             \
+	local_irq_enable();                    \
+    }
+
+#endif /* Not __ASSEMBLY__ */
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+// SYSCON_CLKSET1
+//-----------------------------------------------------------------------------
+#define SYSCON_CLKSET1_PLL1_X2IPD_SHIFT     0
+#define SYSCON_CLKSET1_PLL1_X2IPD_MASK      0x0000001f
+#define SYSCON_CLKSET1_PLL1_X2FBD2_SHIFT    5
+#define SYSCON_CLKSET1_PLL1_X2FBD2_MASK     0x000007e0
+#define SYSCON_CLKSET1_PLL1_X1FBD1_SHIFT    11
+#define SYSCON_CLKSET1_PLL1_X1FBD1_MASK     0x0000f800
+#define SYSCON_CLKSET1_PLL1_PS_SHIFT        16
+#define SYSCON_CLKSET1_PLL1_PS_MASK         0x00030000
+#define SYSCON_CLKSET1_PCLKDIV_SHIFT        18
+#define SYSCON_CLKSET1_PCLKDIV_MASK         0x000c0000
+#define SYSCON_CLKSET1_HCLKDIV_SHIFT        20
+#define SYSCON_CLKSET1_HCLKDIV_MASK         0x00700000
+#define SYSCON_CLKSET1_nBYP1                0x00800000
+#define SYSCON_CLKSET1_SMCROM               0x01000000
+#define SYSCON_CLKSET1_FCLKDIV_SHIFT        25
+#define SYSCON_CLKSET1_FCLKDIV_MASK         0x0e000000
+
+#define SYSCON_CLKSET1_HSEL                 0x00000001
+#define SYSCON_CLKSET1_PLL1_EXCLKSEL        0x00000002
+
+#define SYSCON_CLKSET1_PLL1_P_MASK          0x0000007C
+#define SYSCON_CLKSET1_PLL1_P_SHIFT         2
+
+#define SYSCON_CLKSET1_PLL1_M1_MASK         0x00000780
+#define SYSCON_CLKSET1_PLL1_M1_SHIFT        7
+#define SYSCON_CLKSET1_PLL1_M2_MASK         0x0000F800
+#define SYSCON_CLKSET1_PLL1_M2_SHIFT        11
+#define SYSCON_CLKSET1_PLL1_PS_MASK         0x00030000
+#define SYSCON_CLKSET1_PLL1_PS_SHIFT        16
+#define SYSCON_CLKSET1_PCLK_DIV_MASK        0x000C0000
+#define SYSCON_CLKSET1_PCLK_DIV_SHIFT       18
+#define SYSCON_CLKSET1_HCLK_DIV_MASK        0x00700000
+#define SYSCON_CLKSET1_HCLK_DIV_SHIFT       20
+#define SYSCON_CLKSET1_SMCROM               0x01000000
+#define SYSCON_CLKSET1_FCLK_DIV_MASK        0x0E000000
+#define SYSCON_CLKSET1_FCLK_DIV_SHIFT       25
+
+#define SYSCON_CLKSET2_PLL2_EN              0x00000001
+#define SYSCON_CLKSET2_PLL2EXCLKSEL         0x00000002
+#define SYSCON_CLKSET2_PLL2_P_MASK          0x0000007C
+#define SYSCON_CLKSET2_PLL2_P_SHIFT         2
+#define SYSCON_CLKSET2_PLL2_M2_MASK         0x00000F80
+#define SYSCON_CLKSET2_PLL2_M2_SHIFT        7
+#define SYSCON_CLKSET2_PLL2_M1_MASK         0x0001F000
+#define SYSCON_CLKSET2_PLL2_M1              12
+#define SYSCON_CLKSET2_PLL2_PS_MASK         0x000C0000
+#define SYSCON_CLKSET2_PLL2_PS_SHIFT        18
+#define SYSCON_CLKSET2_USBDIV_MASK          0xF0000000
+#define SYSCON_CLKSET2_USBDIV_SHIFT         28
+
+//-----------------------------------------------------------------------------
+// DEV_CFG Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_DEVCFG_SHena            0x00000001
+#define SYSCON_DEVCFG_KEYS             0x00000002
+#define SYSCON_DEVCFG_ADCPD            0x00000004
+#define SYSCON_DEVCFG_RAS              0x00000008
+#define SYSCON_DEVCFG_RASonP3          0x00000010
+#define SYSCON_DEVCFG_TTIC             0x00000020
+#define SYSCON_DEVCFG_I2SonAC97        0x00000040
+#define SYSCON_DEVCFG_I2SonSSP         0x00000080
+#define SYSCON_DEVCFG_EonIDE           0x00000100
+#define SYSCON_DEVCFG_PonG             0x00000200
+#define SYSCON_DEVCFG_GonIDE           0x00000400
+#define SYSCON_DEVCFG_HonIDE           0x00000800
+#define SYSCON_DEVCFG_HC1CEN           0x00001000
+#define SYSCON_DEVCFG_HC1IN            0x00002000
+#define SYSCON_DEVCFG_HC3CEN           0x00004000
+#define SYSCON_DEVCFG_HC3IN            0x00008000
+#define SYSCON_DEVCFG_TIN              0x00020000
+#define SYSCON_DEVCFG_U1EN             0x00040000
+#define SYSCON_DEVCFG_EXVC             0x00080000
+#define SYSCON_DEVCFG_U2EN             0x00100000
+#define SYSCON_DEVCFG_A1onG            0x00200000
+#define SYSCON_DEVCFG_A2onG            0x00400000
+#define SYSCON_DEVCFG_CPENA            0x00800000
+#define SYSCON_DEVCFG_U3EN             0x01000000
+#define SYSCON_DEVCFG_MonG             0x02000000
+#define SYSCON_DEVCFG_TonG             0x04000000
+#define SYSCON_DEVCFG_GonK             0x08000000
+#define SYSCON_DEVCFG_IonU2            0x10000000
+#define SYSCON_DEVCFG_D0onG            0x20000000
+#define SYSCON_DEVCFG_D1onG            0x40000000
+#define SYSCON_DEVCFG_SWRST            0x80000000
+
+//-----------------------------------------------------------------------------
+// VIDDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_VIDDIV_VDIV_MASK         0x0000007f              
+#define SYSCON_VIDDIV_VDIV_SHIFT        0
+#define SYSCON_VIDDIV_PDIV_MASK         0x00000300
+#define SYSCON_VIDDIV_PDIV_SHIFT        8
+#define SYSCON_VIDDIV_PSEL              0x00002000
+#define SYSCON_VIDDIV_ESEL              0x00004000
+#define SYSCON_VIDDIV_VENA              0x00008000
+
+//-----------------------------------------------------------------------------
+// MIRDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_MIRDIV_MDIV_MASK         0x0000003f
+#define SYSCON_MIRDIV_MDIV_SHIFT        0
+#define SYSCON_MIRDIV_PDIV_MASK         0x00000300
+#define SYSCON_MIRDIV_PDIV_SHIFT        8
+#define SYSCON_MIRDIV_PSEL              0x00002000              
+#define SYSCON_MIRDIV_ESEL              0x00004000
+#define SYSCON_MIRDIV_MENA              0x00008000
+
+//-----------------------------------------------------------------------------
+// I2SDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_I2SDIV_MDIV_MASK         0x0000007f
+#define SYSCON_I2SDIV_MDIV_SHIFT        0
+#define SYSCON_I2SDIV_PDIV_MASK         0x00000300
+#define SYSCON_I2SDIV_PDIV_SHIFT        8
+#define SYSCON_I2SDIV_PSEL              0x00002000
+#define SYSCON_I2SDIV_ESEL              0x00004000
+#define SYSCON_I2SDIV_MENA              0x00008000
+#define SYSCON_I2SDIV_SDIV              0x00010000
+#define SYSCON_I2SDIV_LRDIV_MASK        0x00060000
+#define SYSCON_I2SDIV_LRDIV_SHIFT       17
+#define SYSCON_I2SDIV_SPOL              0x00080000
+#define SYSCON_I2SDIV_DROP              0x00100000
+#define SYSCON_I2SDIV_ORIDE             0x20000000
+#define SYSCON_I2SDIV_SLAVE             0x40000000
+#define SYSCON_I2SDIV_SENA              0x80000000
+
+#define SYSCON_I2SDIV_PDIV_OFF          0x00000000
+#define SYSCON_I2SDIV_PDIV_2            0x00000100
+#define SYSCON_I2SDIV_PDIV_25           0x00000200
+#define SYSCON_I2SDIV_PDIV_3            0x00000300
+
+#define SYSCON_I2SDIV_LRDIV_32          0x00000000
+#define SYSCON_I2SDIV_LRDIV_64          0x00020000
+#define SYSCON_I2SDIV_LRDIV_128         0x00040000
+
+//-----------------------------------------------------------------------------
+// KTDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_KTDIV_KDIV               0x00000001
+#define SYSCON_KTDIV_KEN                0x00008000
+#define SYSCON_KTDIV_ADIV               0x00010000
+#define SYSCON_KTDIV_TSEN               0x80000000
+
+//-----------------------------------------------------------------------------
+// CHIPID Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_CHIPID_ID_MASK           0x0000ffff
+#define SYSCON_CHIPID_ID_SHIFT          0
+#define SYSCON_CHIPID_PKID              0x00010000
+#define SYSCON_CHIPID_BND               0x00040000
+#define SYSCON_CHIPID_FAB_MASK          0x0e000000
+#define SYSCON_CHIPID_FAB_SHIFT         25
+#define SYSCON_CHIPID_REV_MASK          0xf0000000
+#define SYSCON_CHIPID_REV_SHIFT         28
+
+//-----------------------------------------------------------------------------
+// TESTCR Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_TESTCR_TMODE_MASK        0x000000ff
+#define SYSCON_TESTCR_TMODE_SHIFT       0
+#define SYSCON_TESTCR_BONDO             0x00000100
+#define SYSCON_TESTCR_PACKO             0x00000800
+#define SYSCON_TESTCR_ETOM              0x00002000
+#define SYSCON_TESTCR_TOM               0x00004000
+#define SYSCON_TESTCR_OVR               0x00008000
+#define SYSCON_TESTCR_TonIDE            0x00010000
+#define SYSCON_TESTCR_RonG              0x00020000
+
+//-----------------------------------------------------------------------------
+// SYSCFG Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_SYSCFG_LCSn1             0x00000001
+#define SYSCON_SYSCFG_LCSn2             0x00000002
+#define SYSCON_SYSCFG_LCSn3             0x00000004
+#define SYSCON_SYSCFG_LEECK             0x00000008
+#define SYSCON_SYSCFG_LEEDA             0x00000010
+#define SYSCON_SYSCFG_LASDO             0x00000020
+#define SYSCON_SYSCFG_LCSn6             0x00000040
+#define SYSCON_SYSCFG_LCSn7             0x00000080
+#define SYSCON_SYSCFG_SBOOT             0x00000100
+#define SYSCON_SYSCFG_FAB_MASK          0x0e000000
+#define SYSCON_SYSCFG_FAB_SHIFT         25
+#define SYSCON_SYSCFG_REV_MASK          0xf0000000
+#define SYSCON_SYSCFG_REV_SHIFT         28
+
+
+//-----------------------------------------------------------------------------
+// PWRSR Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_PWRSR_CHIPMAN_MASK       0xFF000000
+#define SYSCON_PWRSR_CHIPMAN_SHIFT      24
+#define SYSCON_PWRSR_CHIPID_MASK        0x00FF0000
+#define SYSCON_PWRSR_CHIPID_SHIFT       16
+#define SYSCON_PWRSR_WDTFLG             0x00008000
+#define SYSCON_PWRSR_CLDFLG             0x00002000
+#define SYSCON_PWRSR_TEST_RESET         0x00001000
+#define SYSCON_PWRSR_RSTFLG             0x00000800
+#define SYSCON_PWRSR_SWRESET            0x00000400
+#define SYSCON_PWRSR_PLL2_LOCKREG       0x00000200
+#define SYSCON_PWRSR_PLL2_LOCK          0x00000100
+#define SYSCON_PWRSR_PLL1_LOCKREG       0x00000080    
+#define SYSCON_PWRSR_PLL1_LOCK          0x00000040    
+#define SYSCON_PWRSR_RTCDIV             0x0000003F
+
+//-----------------------------------------------------------------------------
+// PWRCNT Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_PWRCNT_FIREN             0x80000000
+#define SYSCON_PWRCNT_UARTBAUD          0x20000000
+#define SYSCON_PWRCNT_USHEN             0x10000000
+#define SYSCON_PWRCNT_DMA_M2MCH1        0x08000000
+#define SYSCON_PWRCNT_DMA_M2MCH0        0x04000000
+#define SYSCON_PWRCNT_DMA_M2PCH8        0x02000000
+#define SYSCON_PWRCNT_DMA_M2PCH9        0x01000000
+#define SYSCON_PWRCNT_DMA_M2PCH6        0x00800000
+#define SYSCON_PWRCNT_DMA_M2PCH7        0x00400000
+#define SYSCON_PWRCNT_DMA_M2PCH4        0x00200000
+#define SYSCON_PWRCNT_DMA_M2PCH5        0x00100000
+#define SYSCON_PWRCNT_DMA_M2PCH2        0x00080000
+#define SYSCON_PWRCNT_DMA_M2PCH3        0x00040000
+#define SYSCON_PWRCNT_DMA_M2PCH0        0x00020000
+#define SYSCON_PWRCNT_DMA_M2PCH1        0x00010000
+
+//-----------------------------------------------------------------------------
+// BMAR Register Defines
+//-----------------------------------------------------------------------------
+#define BMAR_PRIORD_00              0x00000000
+#define BMAR_PRIORD_01              0x00000001
+#define BMAR_PRIORD_02              0x00000002
+#define BMAR_PRIORD_03              0x00000003
+#define BMAR_PRI_CORE               0x00000008
+#define BMAR_DMA_ENIRQ              0x00000010
+#define BMAR_DMA_ENFIQ              0x00000020
+#define BMAR_USB_ENIRQ              0x00000040
+#define BMAR_USB_ENFIQ              0x00000080
+#define BMAR_MAC_ENIRQ              0x00000100
+#define BMAR_MAC_ENFIQ              0x00000200
+#define BMAR_GRAPHICS_ENIRQ         0x00000400
+#define BMAR_GRAPHICS_ENFIQ         0x00000800
+
+
+#endif // _REGS_SYSCON_H_
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/ssp.h linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/ssp.h
--- linux-2.6.29.2/arch/arm/mach-ep93xx/include/mach/ssp.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/include/mach/ssp.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,32 @@
+/*
+ * 
+ *  FILE:           ssp.h
+ *
+ *  DESCRIPTION:    SSP Interface Driver Module implementation
+ *
+ *  Copyright Cirrus Logic Corporation, 2001-2003.  All rights reserved
+ *
+ */
+#ifndef _SSP_DRV_H_
+#define _SSP_DRV_H_
+
+typedef enum 
+{
+	PS2_KEYBOARD = 0,
+	I2S_CODEC    = 1,
+	SERIAL_FLASH = 2
+} SSPDeviceType;
+
+typedef void (*SSPDataCallback)(unsigned int Data);
+
+typedef struct _SSP_DRIVER_API
+{
+    int (*Open)(SSPDeviceType Device, SSPDataCallback Callback);
+    int (*Read)(int Handle, unsigned int Addr, unsigned int *pValue);
+    int (*Write)(int Handle, unsigned int Addr, unsigned int Value);
+    int (*Close)(int Handle);
+} SSP_DRIVER_API;
+
+extern SSP_DRIVER_API *SSPDriver;
+
+#endif /* _SSP_DRV_H_ */
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/arch/arm/mach-ep93xx/ssp.c linux-2.6.29.2.new/arch/arm/mach-ep93xx/ssp.c
--- linux-2.6.29.2/arch/arm/mach-ep93xx/ssp.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/arch/arm/mach-ep93xx/ssp.c	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,975 @@
+/*
+ *  FILE:			ssp.c
+ *
+ *  DESCRIPTION:	SSP Interface Driver Module implementation
+ *
+ *  Copyright Cirrus Logic Corporation, 2001-2003.  All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ *  This driver provides a way to read and write devices on the SSP
+ *  interface.
+ *
+ *  For Tx devices, EGPIO7 is used as an address pin:
+ *  I2S Codec CS4228        = EGPIO7 == 1
+ *  Serial Flash AT25F1024  = EGPIO7 == 0
+ */
+#include <linux/delay.h>
+//#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <linux/autoconf.h>
+
+#include <linux/spinlock.h>
+#include <linux/semaphore.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/ssp.h>
+
+#undef DEBUG
+//#define DEBUG 1
+#ifdef DEBUG
+//#define DPRINTK( x... )  printk( ##x )
+#define DPRINTK( fmt, arg... )  printk( fmt, ##arg )
+#else
+//#define DPRINTK( x... )
+#define DPRINTK( fmt, arg... )
+#endif
+
+
+#define EP93XX_KEY_TIMER_PERIOD_MSEC 20
+
+static int SSP_Open(SSPDeviceType Device, SSPDataCallback Callback);
+static int SSP_Close(int Handle);
+static int SSP_Read(int Handle, unsigned int Addr, unsigned int *pValue);
+static int SSP_Write(int Handle, unsigned int Addr, unsigned int Value);
+static int CheckHandle(int Handle);
+
+static void  SetSSPtoPS2(void);
+static void  SetSSPtoI2S(void);
+static void  SetSSPtoFLASH(void);
+static int  ReadIntoBuffer(void);
+
+static int SSP_Write_I2SCodec(int Handle, unsigned int RegAddr,unsigned int RegValue);
+
+/*
+ * Key buffer...
+ */
+#define KEYBUF_SIZE 256
+static unsigned int uiKeyBuffer[KEYBUF_SIZE];
+static spinlock_t ssp_spinlock = SPIN_LOCK_UNLOCKED;
+
+
+typedef enum{
+	SSP_MODE_UNKNOWN = 0,
+	SSP_MODE_PS2,
+	SSP_MODE_I2S,
+	SSP_MODE_FLASH,
+} SSPmodes_t;
+
+static struct timer_list g_KbdTimer;
+static SSPmodes_t gSSPmode = SSP_MODE_UNKNOWN;
+static SSPDataCallback gKeyCallback = 0;
+static int gHookedInterrupt = 0;
+
+/*
+ * Keep the last valid handle for SSP for kbd, i2s, and flash
+ */
+static int iLastValidHandle = -1;
+static int KeyboardHandle = 0;
+static int I2SHandle = 0;
+static int FlashHandle = 0;
+
+#define SSP_DEVICE_MASK    0xf0000000
+#define SSP_DEVICE_SHIFT	 28
+
+SSP_DRIVER_API SSPinstance =
+{
+	SSP_Open,
+	SSP_Read,
+	SSP_Write,
+	SSP_Close,
+};
+
+/*
+ * The only instance of this driver.
+ */
+SSP_DRIVER_API *SSPDriver = &SSPinstance;
+
+//=============================================================================
+// SSPIrqHandler
+//=============================================================================
+// This routine will get all of the keys out of the SPI FIFO.
+//=============================================================================
+static irqreturn_t SSPIrqHandler( int irq, void *dev_id)
+{
+	//
+	// Get key codes from SSP and send them to the keyboard callback.
+	//
+	ReadIntoBuffer();
+	
+	//
+	// Clear the interrupt.
+	//
+	outl( 0, SSPIIR );
+
+	return IRQ_HANDLED;
+}
+
+//=============================================================================
+// TimerRoutine
+//=============================================================================
+// This function is called periodically to make sure that no keys are stuck in
+// the SPI FIFO.  This is necessary because the SPI only interrupts on half
+// full FIFO which can leave up to one keyboard event in the FIFO until another
+// key is pressed.
+//=============================================================================
+static void TimerRoutine(unsigned long Data)
+{
+	int keycount;
+
+	//
+	// Get key codes from SSP and send them to the keyboard callback.
+	//
+	keycount = ReadIntoBuffer();
+	
+	//
+	// If no keys were received, call the Data callback anyway so it can
+	// check for stuck keys.
+	//
+	if( (keycount==0) && gKeyCallback )
+	{
+		gKeyCallback(-1);
+	}
+	
+	//
+	// Reschedule our timer in another 20 mSec.
+	//
+	g_KbdTimer.expires = jiffies + MSECS_TO_JIFFIES( EP93XX_KEY_TIMER_PERIOD_MSEC );
+	add_timer(&g_KbdTimer);
+}
+
+/*
+ * HookInterrupt
+ *
+ * Requests SSP interrupt, sets up interrupt handler, sets up keyboard polling
+ * timer.
+ */
+static int HookInterrupt(void)
+{
+	if (gHookedInterrupt)
+	{
+		printk( KERN_ERR "SSP driver interrupt already hooked\n");
+		return(-1);
+	}
+
+
+	if (request_irq(IRQ_EP93XX_SSP1RX, SSPIrqHandler, IRQF_DISABLED, "ep93xxsspd", 0))
+	{
+		printk( KERN_ERR "SSP driver failed to get IRQ handler\n");
+		return(-1);
+	}
+	
+	gHookedInterrupt = 1;
+
+	//
+	// Initialize the timer that we will use to poll the SPI.
+	//
+	init_timer(&g_KbdTimer);
+	g_KbdTimer.function = TimerRoutine;
+	g_KbdTimer.data = 1;
+	g_KbdTimer.expires = jiffies + MSECS_TO_JIFFIES( EP93XX_KEY_TIMER_PERIOD_MSEC );
+
+	add_timer(&g_KbdTimer);
+	
+	return(0);
+}
+
+static int SSP_Open(SSPDeviceType Device, SSPDataCallback Callback)
+{
+	int Handle;
+	
+	/*
+	 * Generate a handle and pass it back.
+	 *
+	 * Increment the last valid handle.
+	 * Check for wraparound (unlikely, but we like to be complete).
+	 */
+	iLastValidHandle++;
+	
+	if((iLastValidHandle & ~SSP_DEVICE_MASK) == 0)
+	{
+		/*
+		 * If we wrapped around start over.  Unlikely.
+		 */
+		iLastValidHandle = 1;
+	}
+	
+	Handle = iLastValidHandle | (Device << SSP_DEVICE_SHIFT);
+
+	switch (Device)
+	{
+		case PS2_KEYBOARD:
+		{
+			DPRINTK("SSP_Open - PS2_KEYBOARD\n");
+			if (KeyboardHandle)
+			{
+				return(-1);
+			}
+			else
+			{
+				DPRINTK("Handle:%08x  Callback:%08x  -- Success\n",
+					Handle, (unsigned int)Callback);
+
+				KeyboardHandle = Handle;
+				//
+				// Hook the interrupt if we have not yet.
+				//
+				HookInterrupt();
+				SetSSPtoPS2();
+				gKeyCallback = Callback;
+			}
+			break;
+		}
+		case I2S_CODEC:
+		{
+			DPRINTK("SSP_Open - I2S_CODEC\n");
+			if (I2SHandle)
+			{
+				return(-1);
+			}
+			else
+			{
+				DPRINTK("Handle:%08x  Callback:%08x  -- Success\n",
+					Handle, (unsigned int)Callback);
+
+				I2SHandle = Handle;
+			}
+			break;
+		}
+		case SERIAL_FLASH:
+		{
+			DPRINTK("SSP_Open - SERIAL_FLASH\n");
+			if (FlashHandle)
+			{
+				return(-1);
+			}
+			else
+			{
+				DPRINTK("Handle:%08x  Callback:%08x  -- Success\n",
+					Handle, (unsigned int)Callback);
+				FlashHandle = Handle;
+			}
+			break;
+		}
+		default:
+		{
+			return(-1);
+		}
+	}
+	
+	/*
+	 * Return the handle.
+	 */
+	return(Handle );
+}
+
+/*
+ * Release that Handle!
+ */
+static int SSP_Close(int Handle)
+{
+	//
+	// Find out which device this API was called for.
+	//
+	switch( CheckHandle(Handle) )
+	{
+		case PS2_KEYBOARD:
+		{
+			DPRINTK("SSP_Open - PS2_KEYBOARD\n");
+			del_timer(&g_KbdTimer);
+			free_irq(IRQ_EP93XX_SSP1RX, 0);
+			gKeyCallback = 0;
+			KeyboardHandle = 0;
+			gHookedInterrupt = 0;
+			break;
+		}
+		case I2S_CODEC:
+		{
+			DPRINTK("SSP_Open - I2S_CODEC\n");
+			I2SHandle = 0;
+			break;
+		}
+		case SERIAL_FLASH:
+		{
+			DPRINTK("SSP_Open - SERIAL_FLASH\n");
+			FlashHandle = 0;
+			break;
+		}
+		default:
+		{
+			return(-1);
+		}
+	}
+	return 0;
+}
+
+static int SSP_Read_FLASH
+(
+	int Handle,
+	unsigned int RegAddr,
+	unsigned int *pValue
+)
+{
+	SSPmodes_t saved_mode;
+
+	DPRINTK("SSP_Read_FLASH\n");
+
+	spin_lock(&ssp_spinlock);
+
+	/*
+	 * Save the SSP mode.  Switch to FLASH mode if we're not
+	 * already in FLASH mode.
+	 */
+	saved_mode = gSSPmode;
+	SetSSPtoFLASH();
+
+	/*
+	 * Let TX fifo clear out.  Poll the Transmit Fifo Empty bit.
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) )
+		barrier();
+
+	/*
+	 * Write the SPI read command.
+	 */
+	outl( 0x03, SSPDR );
+	outl( (RegAddr >> 16) & 255, SSPDR );
+	outl( (RegAddr >> 8) & 255, SSPDR );
+	outl( RegAddr & 255, SSPDR );
+
+	/*
+	 * Delay long enough for one byte to be transmitted.  It takes 7.6uS to
+	 * write a single byte.
+	 */
+	udelay(10);
+
+	/*
+	 * Read a byte to make sure the FIFO doesn't overrun.
+	 */
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+
+	/*
+	 * Write four more bytes so that we can read four bytes.
+	 */
+	outl( 0, SSPDR );
+	outl( 0, SSPDR );
+	outl( 0, SSPDR );
+	outl( 0, SSPDR );
+
+	/*
+	 * Delay long enough for three bytes to be transmitted.  It takes 7.6uS
+	 * to write a single byte.
+	 */
+	udelay(25);
+
+	/*
+	 * Read three and throw away the next tree bytes.
+	 */
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+
+	/*
+	 * Delay long enough for four bytes to be transmitted.  It takes 7.6uS
+	 * to write a single byte.
+	 */
+	udelay(30);
+
+	/*
+	 * Read the data word.
+	 */
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue = inl( SSPDR );
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue |= inl( SSPDR ) << 8;
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue |= inl( SSPDR ) << 16;
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue |= inl( SSPDR ) << 24;
+
+	/*
+	 * Wait until the transmit buffer is empty (it should be...).
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) )
+		barrier();
+
+	/*
+	 * Read any residual bytes in the receive buffer.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+		inl( SSPDR );
+	
+	/*
+	 * If we were in PS2 mode, switch back to PS2 mode.
+	 * If we weren't in PS2 mode, that means we didn't compile in
+	 * the PS2 keyboard support, so no need to switch to PS2 mode.
+	 */
+	if( saved_mode == SSP_MODE_PS2 )
+		SetSSPtoPS2();
+
+	spin_unlock(&ssp_spinlock);
+
+	/*
+	 * Return success.
+	 */
+	return 0;
+}
+
+static int SSP_Read(int Handle, unsigned int Addr, unsigned int *pValue)
+{
+	DPRINTK("SSP_Read\n");
+
+	/*
+	 * Find out which device this API was called for.
+	 */
+	switch( CheckHandle(Handle) )
+	{
+		case SERIAL_FLASH:
+		{
+			return SSP_Read_FLASH(Handle, Addr, pValue);
+		}
+		default:
+		{
+			return -1;
+		}
+	}
+}
+
+static int SSP_Write(int Handle, unsigned int Addr, unsigned int Value)
+{
+	int iRet = 0;
+	// DPRINTK("SSP_Write - Handle:0x%08x  Addr:0x%08x  Value:0x%08x\n",
+	//    Handle, Addr, Value );
+	
+	//
+	// Find out which device this API was called for.
+	//
+	switch( CheckHandle(Handle) )
+	{
+		case PS2_KEYBOARD:
+		{
+			break;
+		}
+		case I2S_CODEC:
+		{
+			iRet = SSP_Write_I2SCodec( Handle, Addr, Value );
+			break;
+		}
+		case SERIAL_FLASH:
+		{
+			break;
+		}
+		default:
+		{
+			return(-1);
+		}
+	}
+
+	return iRet;
+}
+
+static void SetSSPtoPS2(void)
+{
+	unsigned int uiRegTemp;
+	
+	if( gSSPmode == SSP_MODE_PS2 )
+	{
+		return;
+	}
+
+	/*
+	 * Disable the SSP, disable interrupts
+	 */
+	outl( 0, SSPCR1 );
+
+	/*
+	 * It takes almost a millisecond for a key to come in so
+	 * make sure we have completed all transactions.
+	 */
+	mdelay(1);
+
+	//
+	// Set EGPIO7 to disable EEPROM device on EDB9301, EDB9312, and EDB9315.
+	//
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x80, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x80, GPIO_PADR );
+
+	/*
+	 * Disable SFRM1 to I2S codec by setting EGPIO8 (port B, bit 0).
+	 * The EDB9315 board needs this but is harmless on the EDB9312 board.
+	 */
+#if defined(CONFIG_MACH_EDB9307) || defined(CONFIG_MACH_EDB9312) || defined(CONFIG_MACH_EDB9315)
+	uiRegTemp = inl(GPIO_PBDDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDR );
+	
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Disable SFRM1 to I2S codec I2S by setting EGPIO6 (port A, bit 6).
+	 * The EDB9301 board needs this
+	 */
+#if defined(CONFIG_MACH_EDB9301) || defined(CONFIG_MACH_EDB9302)|| \
+   defined(CONFIG_MACH_EDB9302A) || defined(CONFIG_MACH_EDB9307A) || defined(CONFIG_MACH_EDB9315A) 
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x40, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x40, GPIO_PADR );
+
+	uiRegTemp = inl(GPIO_PADR);
+#endif
+
+	/*
+	 * Still haven't enabled the keyboard.  So anything in
+	 * the rx fifo is garbage.  Time to take out the trash.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+	{
+		uiRegTemp = inl(SSPDR);
+	}
+
+	/*
+	 * SPICR0_SPO - SCLKOUT Polarity
+	 * SPICR0_SPH - SCLKOUT Phase
+	 * Motorola format, 11 bit, one start, 8 data, one bit for
+	 * parity, one stop bit.
+	 */
+	outl( (SSPCR0_FRF_MOTOROLA | SSPCR0_SPH | SSPCR0_SPO | SSPCR0_DSS_11BIT),
+	      SSPCR0 );
+	/*
+	 * Configure the device as a slave, Clear FIFO overrun interrupts,
+	 * enable interrupts and reset the device.
+	 */
+	outl( (SSPC1_MS | SSPC1_RIE | SSPC1_SOD), SSPCR1 );
+	outl( 0, SSPIIR );
+	outl( (SSPC1_MS | SSPC1_RIE | SSPC1_SOD | SSPC1_SSE), SSPCR1 );
+
+	/*
+	 * Configure EGPIO pins 12 and 14 as outputs because they are used
+	 * as buffer enables for the SPI interface to the ps2 keyboard.
+	 * Clear EGPIO pins 12 and 14, this will enable the SPI keyboard.
+	 */
+	uiRegTemp = inl(GPIO_PBDDR);
+	outl( uiRegTemp | 0x50, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR);
+	outl( uiRegTemp & ~0x50, GPIO_PBDR );
+
+	gSSPmode = SSP_MODE_PS2;
+}
+
+static void SetSSPtoI2S(void)
+{
+	unsigned int uiRegTemp;
+
+	if( gSSPmode == SSP_MODE_I2S )
+	{
+		return;
+	}
+	
+	/*
+	 * Disable recieve interrupts.
+	 */
+	outl( (SSPC1_MS | SSPC1_SSE), SSPCR1 );
+
+	/*
+	 * Set GPIO pins 12 and 14, this will bring the clock line low
+	 * which signals to the keyboard to buffer keystrokes.
+	 * Note that EGPIO 14 is the clock line and EGPIO 12 is data line.
+	 */
+	uiRegTemp = inl(GPIO_PBDR);
+	outl( 0x50 | uiRegTemp, GPIO_PBDR );
+
+	/*
+	 * It takes almost a millisecond for an partial keystrokes to come in.
+	 * Delay to make sure we have completed all transactions.
+	 */
+	mdelay(1);
+
+	/*
+	 * Anything we just recieved is garbage.  Time to take out the trash.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+	{
+		uiRegTemp = inl(SSPDR);
+	}
+	
+	/*
+	 * Disable the SSP and disable interrupts
+	 */
+	outl( 0, SSPCR1 );
+
+	/*
+	 * Clock will be 14.7 MHz divided by 4.
+	 */
+	outl( 2, SSPCPSR );
+
+	/*
+	 * Configure EGPIO7 as an output and set it.  This selects
+	 * I2S codec as the device on the SSP output instead of
+	 * the serial flash on EDB9312.  On EDB9301 and EDB9315 it
+	 * disables EEPROM but doesn't select anything.
+	 */
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x80, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x80, GPIO_PADR );
+
+	/*
+	 * Enable SFRM1 to I2S codec by clearing EGPIO8 (port B, bit 0).
+	 * The EDB9315 board needs this but is harmless on the EDB9312 board.
+	 */
+#if defined(CONFIG_MACH_EDB9307) || defined(CONFIG_MACH_EDB9312) || defined(CONFIG_MACH_EDB9315)
+	uiRegTemp = inl(GPIO_PBDDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR) & 0xfe;
+	outl( uiRegTemp, GPIO_PBDR );
+	
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Enable SFRM1 to I2S codec I2S by clearing EGPIO6 (port A, bit 6).
+	 * The EDB9301 board needs this
+	 */
+#if defined(CONFIG_MACH_EDB9301) || defined(CONFIG_MACH_EDB9302) || \
+    defined(CONFIG_MACH_EDB9302A) || defined(CONFIG_MACH_EDB9307A) || defined(CONFIG_MACH_EDB9315A)
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x40, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp & ~0x40, GPIO_PADR );
+
+	uiRegTemp = inl(GPIO_PADR);
+#endif
+
+	/*
+	 * Motorola format, 8 bit.
+	 */
+	outl( (SSPCR0_SPO | SSPCR0_SPH | SSPCR0_FRF_MOTOROLA | SSPCR0_DSS_8BIT),
+	      SSPCR0 );
+
+	/*
+	 * Configure the device as master, reenable the device.
+	 */
+	outl( SSPC1_SSE, SSPCR1 );
+
+	gSSPmode = SSP_MODE_I2S;
+
+	udelay(10);
+}
+
+static void SetSSPtoFLASH(void)
+{
+	unsigned int uiRegTemp;
+
+	if( gSSPmode == SSP_MODE_FLASH)
+		return;
+
+	/*
+	 * Disable recieve interrupts.
+	 */
+	outl( (SSPC1_MS | SSPC1_SSE), SSPCR1 );
+
+	/*
+	 * Set GPIO pins 12 and 14, this will bring the clock line low
+	 * which signals to the keyboard to buffer keystrokes.
+	 * Note that EGPIO 14 is the clock line and EGPIO 12 is data line.
+	 */
+	outl( inl(GPIO_PBDR) | 0x50, GPIO_PBDR );
+
+	/*
+	 * It takes almost a millisecond for an partial keystrokes to come in.
+	 * Delay to make sure we have completed all transactions.
+	 */
+	mdelay(1);
+
+	/*
+	 * Anything we just recieved is garbage.  Time to take out the trash.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+		inl(SSPDR);
+	
+	/*
+	 * Disable the SSP and disable interrupts
+	 */
+	outl( 0, SSPCR1 );
+
+	/*
+	 * Clock will be 14.7 MHz divided by 14.
+	 */
+	outl( 2, SSPCPSR );
+
+	/*
+	 * Configure EGPIO7 as an output and clear it.  This selects
+	 * serial flash as the device on the SSP output instead of
+	 * the I2S codec and is valid for EDB9301, EDB9312, and EDB9315.
+	 */
+	outl( inl(GPIO_PADDR) | 0x80, GPIO_PADDR );
+	outl( inl(GPIO_PADR) & ~0x80, GPIO_PADR );
+
+	/*
+	 * Disable SFRM1 to I2S codec by setting EGPIO8 (port B, bit 0).
+	 * The EDB9315 board needs this but is harmless on the EDB9312 board.
+	 */
+#if defined(CONFIG_MACH_EDB9307) || defined(CONFIG_MACH_EDB9312) || defined(CONFIG_MACH_EDB9315)
+	uiRegTemp = inl(GPIO_PBDDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDR );
+	
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Disable SFRM1 to I2S codec I2S by setting EGPIO6 (port A, bit 6).
+	 * The EDB9301 board needs this
+	 */
+#if defined(CONFIG_MACH_EDB9301) || defined(CONFIG_MACH_EDB9302) || \
+    defined(CONFIG_MACH_EDB9302A) || defined(CONFIG_MACH_EDB9307A) || defined(CONFIG_MACH_EDB9315A)
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x40, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x40, GPIO_PADR );
+
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Motorola format, 8 bit.
+	 */
+	outl( ((6 << SSPCR0_SCR_SHIFT) | SSPCR0_SPO | SSPCR0_SPH |
+	       SSPCR0_FRF_MOTOROLA | SSPCR0_DSS_8BIT),
+	      SSPCR0 );
+
+	/*
+	 * Configure the device as master, reenable the device.
+	 */
+	outl( SSPC1_SSE, SSPCR1 );
+
+	gSSPmode = SSP_MODE_FLASH;
+
+	udelay(10);
+}
+
+/*
+ *  CheckHandle
+ *
+ *  If Handle is valid, returns 0.  Otherwise it returns -1.
+ */
+static int CheckHandle(int Handle)
+{
+	int iRet;
+
+	if ((Handle != KeyboardHandle) &&
+	    (Handle != I2SHandle) &&
+	    (Handle != FlashHandle))
+	{
+		DPRINTK("OOPS! Invalid SSP Handle!\n");
+		return(-1);
+	}
+
+	/*
+	 * Get the SSP driver instance number from the handle.
+	 */
+	iRet = (((int)Handle & SSP_DEVICE_MASK) >> SSP_DEVICE_SHIFT);
+
+	return iRet;
+}
+
+/*
+ * ReadIntoBuffer
+ *
+ * Drains the SSP rx fifo into a buffer here.  If we overflow this buffer
+ * then something's wrong.
+ */
+static int ReadIntoBuffer(void)
+{
+	unsigned int count, index, saved_count, uiRegTemp;
+	
+	count = 0;
+	index = 0;
+
+
+	if( gSSPmode != SSP_MODE_PS2 )
+	{
+		return 0;
+	}
+	
+	/*
+	 * This spinlock will prevent I2S from grabbing the SSP to do a
+	 * write while we are using the SSP for PS2.
+	 *
+	 * There is a slight chance that we are in the beginning phase
+	 * of doing an I2S write but the mode flag hadn't yet switched
+	 * to I2S.  If that happens we will end up waiting on I2S to
+	 * finish a write.  Not great.
+	 */
+	spin_lock(&ssp_spinlock);
+
+	while( inl(SSPSR) & SSPSR_RNE)
+	{
+		/*
+		 * Read in the value from the SPI controller into
+		 * the partial key buffer.
+		 */
+		uiKeyBuffer[count] = inl(SSPDR);
+		if (((uiKeyBuffer[count] & 0x3fc) != 0x3e0) &&
+			((uiKeyBuffer[count] & 0x3fc) != 0x3c0))
+		{
+			/*
+			 * Set GPIO pins 12 and 14, this will bring the clock line low
+			 * which signals to the keyboard to buffer keystrokes.
+			 * Note that EGPIO 14 is the clock line and EGPIO 12 is data line.
+			 */
+			uiRegTemp = inl(GPIO_PBDR);
+			outl( 0x50 | uiRegTemp, GPIO_PBDR );
+
+			outl( 0, SSPCR1 );
+			outl( (SSPC1_MS | SSPC1_RIE | SSPC1_SSE), SSPCR1 );
+
+			/*
+			 * Clear EGPIO pins 12 and 14, this will enable the SPI keyboard.
+			 */
+			uiRegTemp = inl(GPIO_PBDR);
+			outl( uiRegTemp & ~0x50, GPIO_PBDR );
+
+			count++;
+			break;
+		}
+		count++;
+	}
+
+	saved_count = count;
+	index = 0;
+	while (count)
+	{
+		//
+		// No callback, dump data.
+		//
+		if (gKeyCallback)
+		{
+			gKeyCallback(uiKeyBuffer[index++]);
+		}
+		count--;
+	}
+
+	spin_unlock(&ssp_spinlock);
+
+	return saved_count;
+}
+
+/*
+ * SSP_Write_I2SCodec
+ *
+ */
+static int SSP_Write_I2SCodec
+(
+	int Handle,
+	unsigned int RegAddr,
+	unsigned int RegValue
+)
+{
+	SSPmodes_t saved_mode;
+
+	DPRINTK("SSP_Write_I2SCodec\n");
+
+	spin_lock(&ssp_spinlock);
+
+	/*
+	 * Save the SSP mode.  Switch to I2S mode if we're not
+	 * already in I2S mode.
+	 */
+	saved_mode = gSSPmode;
+	SetSSPtoI2S();
+
+	/*
+	 * Let TX fifo clear out.  Poll the Transmit Fifo Empty bit.
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) );
+	
+	/*
+	 * Write the data out to the tx fifo.
+	 */
+	outl( 0x20, SSPDR ); /* chip address for CS4228 */
+	outl( (RegAddr & 0xff), SSPDR );
+	outl( (RegValue & 0xff), SSPDR );
+
+	/*
+	 * Let TX fifo clear out.  Poll the Transmit Fifo Empty bit.
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) );
+
+	/*
+	 * Delay to let stuff make it out of the SR before doing
+	 * anthing else to the SSP.  It takes 6.8 uSec to do a
+	 * I2S codec register write.
+	 */
+	udelay(10);
+
+	/*
+	 * If we were in PS2 mode, switch back to PS2 mode.
+	 * If we weren't in PS2 mode, that means we didn't compile in
+	 * the PS2 keyboard support, so no need to switch to PS2 mode.
+	 */
+	if( saved_mode == SSP_MODE_PS2 )
+	{
+		SetSSPtoPS2();
+	}
+
+	spin_unlock(&ssp_spinlock);
+
+	/*
+	 * Return success.
+	 */
+	return 0;
+}
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/sound/arm/Kconfig linux-2.6.29.2.new/sound/arm/Kconfig
--- linux-2.6.29.2/sound/arm/Kconfig	2009-04-27 17:37:11.000000000 +0000
+++ linux-2.6.29.2.new/sound/arm/Kconfig	2009-05-06 06:52:19.000000000 +0000
@@ -22,6 +22,45 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-sa11xx-uda1341.
 
+config SND_EP93XX_IIS
+	tristate "EP93xx ALSA iis audio driver"
+	depends on ARCH_EP93XX && SND
+	select SND_PCM
+	help
+	  Say Y or M if you have a EP93xx board and want to use iis audio and
+	  to use CS4228A and CS4271.
+
+config CODEC_CS4228A
+	tristate "Cirrus cs4228a 6-channels sound"
+	depends on MACH_EDB9312 || MACH_EDB9315 || MACH_EDB9307
+	help
+	  This module drives the Cirrus Logic device CS4281A when wired
+	  as native sound drivers with I2S codecs. It olny work on
+	  EDB9307/12/15 with disable CS4202 driver.
+
+config CODEC_CS4271
+	tristate "Cirrus cs4271 2-channels sound"
+	depends on (MACH_EDB9301 || MACH_EDB9302 || MACH_EDB9315A || MACH_EDB9307A || MACH_EDB9302A)
+	help
+	  This module drives the Cirrus Logic device CS4271 when wired
+	  as native sound drivers with I2S codecs. It olny work on
+	  EDB9301/02/15A with disable CS4202 driver.
+
+config SND_EP93XX_AC97
+	tristate "AC97 driver for the Cirrus EP93xx chip"
+	depends on ARCH_EP93XX && SND
+	select SND_EP93XX_PCM
+	select SND_AC97_CODEC
+	help
+	  Say Y or M if you want to support any AC97 codec attached to
+	  the EP93xx AC97 interface.
+
+config SND_EP93XX_PCM
+	tristate
+	select SND_PCM
+	help
+	  Generic PCM module for EP93xx
+				      
 config SND_ARMAACI
 	tristate "ARM PrimeCell PL041 AC Link support"
 	depends on ARM_AMBA
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/sound/arm/Makefile linux-2.6.29.2.new/sound/arm/Makefile
--- linux-2.6.29.2/sound/arm/Makefile	2009-04-27 17:37:11.000000000 +0000
+++ linux-2.6.29.2.new/sound/arm/Makefile	2009-05-06 06:52:19.000000000 +0000
@@ -17,3 +17,9 @@
 
 obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
 snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
+
+obj-$(CONFIG_SND_EP93XX_IIS) 	+= snd-ep93xx-i2s.o
+snd-ep93xx-i2s-objs 		:= ep93xx-i2s.o
+
+obj-$(CONFIG_SND_EP93XX_AC97)   += snd-ep93xx-ac97.o
+snd-ep93xx-ac97-objs            := ep93xx-ac97.o
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/sound/arm/ep93xx-ac97.c linux-2.6.29.2.new/sound/arm/ep93xx-ac97.c
--- linux-2.6.29.2/sound/arm/ep93xx-ac97.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/sound/arm/ep93xx-ac97.c	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,3474 @@
+/*
+ * linux/sound/arm/ep93xx-i2s.c -- ALSA PCM interface for the edb93xx i2s audio
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/soundcard.h>
+#include <linux/semaphore.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/ac97_codec.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>                                                                                                                             
+#include <mach/dma.h>
+#include <mach/hardware.h>
+#include "ep93xx-ac97.h"
+
+#define	DRIVER_VERSION	"19/3/2007"
+#define	DRIVER_DESC	"EP93xx AC97 Audio driver"
+static int ac_link_enabled = 0;
+static int codec_supported_mixers;
+
+//#define DEBUG 1
+#ifdef DEBUG
+#define DPRINTK( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DPRINTK( fmt, arg... )
+#endif
+
+#define WL16 	0
+#define WL24	1
+
+#define AUDIO_NAME              	"ep93xx-i2s"
+#define AUDIO_SAMPLE_RATE_DEFAULT       44100
+#define AUDIO_DEFAULT_VOLUME            0
+#define AUDIO_MAX_VOLUME	        181
+#define AUDIO_DEFAULT_DMACHANNELS       3
+#define PLAYBACK_DEFAULT_DMACHANNELS    3
+#define CAPTURE_DEFAULT_DMACHANNELS     3
+
+#define CHANNEL_FRONT			(1<<0)
+#define CHANNEL_REAR                   	(1<<1)
+#define CHANNEL_CENTER_LFE              (1<<2)
+
+static void snd_ep93xx_dma_tx_callback(ep93xx_dma_int_t DMAInt,ep93xx_dma_dev_t device,unsigned int user_data);
+static void snd_ep93xx_dma_rx_callback(ep93xx_dma_int_t DMAInt,ep93xx_dma_dev_t device,unsigned int user_data);
+
+static const struct snd_pcm_hardware ep93xx_ac97_pcm_hardware = {
+
+
+    .info		= ( SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_PAUSE  ),
+    .formats		= ( SNDRV_PCM_FMTBIT_U8     | SNDRV_PCM_FMTBIT_S8     |
+			    SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+			    SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
+			    SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE ),
+    .rates		= ( SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 |
+			    SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |
+			    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+			    SNDRV_PCM_RATE_48000 ),
+    .rate_min		= 8000,
+    .rate_max		= 48000,
+    .channels_min	= 1,/*2,*/
+    .channels_max	= 2,
+					
+    .period_bytes_min	= 1 * 1024,
+    .period_bytes_max	= 32 * 1024,
+    .periods_min	= 1,
+    .periods_max	= 32,
+    .buffer_bytes_max	= 32 * 1024,
+    .fifo_size		= 0,
+};
+
+static audio_stream_t output_stream;
+static audio_stream_t input_stream;
+								
+static audio_state_t audio_state =
+{
+    .output_stream      	=&output_stream,
+    .output_dma[0]        	=DMATx_AAC1,
+    .output_id[0]          	="Ac97 out",
+	
+    .input_stream       	=&input_stream,
+    .input_dma[0]          	=DMARx_AAC1,
+    .input_id[0]           	="Ac97 in",
+	
+    .sem                    = __SEMAPHORE_INITIALIZER(audio_state.sem,1),
+    .codec_set_by_playback  = 0,
+    .codec_set_by_capture   = 0,
+    .DAC_bit_width		 =16,
+    .bCompactMode		 =0,
+};			
+		
+
+
+/*
+ * peek
+ *
+ * Reads an AC97 codec register.  Returns -1 if there was an error.
+ */
+static int peek(unsigned int uiAddress)
+{
+	unsigned int uiAC97RGIS;
+	
+	if( !ac_link_enabled )
+	{
+		printk("ep93xx ac97 peek: attempt to peek before enabling ac-link.\n");
+		return -1;
+	}
+	
+	/*
+	 * Check to make sure that the address is aligned on a word boundary 
+	 * and is 7E or less.
+	 */
+	if( ((uiAddress & 0x1)!=0) || (uiAddress > 0x007e))
+	{
+		return -1;
+	}
+
+	/*
+	 * How it is supposed to work is:
+	 *  - The ac97 controller sends out a read addr in slot 1.
+	 *  - In the next frame, the codec will echo that address back in slot 1
+	 *    and send the data in slot 2.  SLOT2RXVALID will be set to 1.
+	 *
+	 * Read until SLOT2RXVALID goes to 1.  Reading the data in AC97S2DATA
+	 * clears SLOT2RXVALID.
+	 */
+
+	/*
+	 * First, delay one frame in case of back to back peeks/pokes.
+	 */
+	mdelay( 1 );
+
+	/*
+	 * Write the address to AC97S1DATA, delay 1 frame, read the flags.
+	 */
+	outl( uiAddress, AC97S1DATA);
+	udelay( 21 * 4 );
+	uiAC97RGIS = inl( AC97RGIS );
+
+	/*
+	 * Return error if we timed out.
+	 */
+	if( ((uiAC97RGIS & AC97RGIS_SLOT1TXCOMPLETE) == 0 ) &&
+		((uiAC97RGIS & AC97RGIS_SLOT2RXVALID) == 0 ) )
+	{
+		printk( "ep93xx-ac97 - peek failed reading reg 0x%02x.\n", uiAddress ); 
+		return -1;
+	}
+	
+	return ( inl(AC97S2DATA) & 0x000fffff);
+}
+
+/*
+ * poke
+ *
+ * Writes an AC97 codec Register.  Return -1 if error.
+ */
+static int poke(unsigned int uiAddress, unsigned int uiValue)
+{
+	unsigned int uiAC97RGIS;
+
+	if( !ac_link_enabled )
+	{
+		printk("ep93xx ac97 poke: attempt to poke before enabling ac-link.\n");
+		return -1;
+	}
+	
+	/*
+	 * Check to make sure that the address is align on a word boundary and
+	 * is 7E or less.  And that the value is a 16 bit value.
+	 */
+	if( ((uiAddress & 0x1)!=0) || (uiAddress > 0x007e))
+	{
+		printk("ep93xx ac97 poke: address error.\n");
+		return -1;
+	}
+ 	
+	/*stop the audio loop from the input to the output directly*/
+
+	if((uiAddress==AC97_0E_MIC_VOL)||(uiAddress==AC97_10_LINE_IN_VOL))
+	{
+		uiValue = (uiValue | 0x8000);
+	
+	}
+	
+	/*
+	 * First, delay one frame in case of back to back peeks/pokes.
+	 */
+	mdelay( 1 );
+
+	/*
+	 * Write the data to AC97S2DATA, then the address to AC97S1DATA.
+	 */
+	outl( uiValue, AC97S2DATA );
+	outl( uiAddress, AC97S1DATA );
+	
+	/*
+	 * Wait for the tx to complete, get status.
+	 */
+	udelay( 30 );/*21*/
+	uiAC97RGIS = inl(AC97RGIS);
+
+	/*
+	 * Return error if we timed out.
+	 */
+	if( !(inl(AC97RGIS) & AC97RGIS_SLOT1TXCOMPLETE) )
+	{
+		printk( "ep93xx-ac97: poke failed writing reg 0x%02x  value 0x%02x.\n", uiAddress, uiValue ); 
+		return -1;
+	}
+
+	return 0;
+}
+
+
+/*
+ * When we get to the multichannel case the pre-fill and enable code
+ * will go to the dma driver's start routine.
+ */
+static void ep93xx_audio_enable( int input_or_output_stream )
+{
+	unsigned int uiTemp;
+
+	DPRINTK("ep93xx_audio_enable :%x\n",input_or_output_stream);
+
+	/*
+	 * Enable the rx or tx channel depending on the value of 
+	 * input_or_output_stream
+	 */
+	if( input_or_output_stream )
+	{
+		uiTemp = inl(AC97TXCR1);
+		outl( (uiTemp | AC97TXCR_TEN), AC97TXCR1 );
+	}
+	else
+	{
+		uiTemp = inl(AC97RXCR1);
+		outl( (uiTemp | AC97RXCR_REN), AC97RXCR1 );
+	}
+	
+	
+	//DDEBUG("ep93xx_audio_enable - EXIT\n");
+}
+
+static void ep93xx_audio_disable( int input_or_output_stream )
+{
+	unsigned int uiTemp;
+
+	DPRINTK("ep93xx_audio_disable\n");
+
+	/*
+	 * Disable the rx or tx channel depending on the value of 
+	 * input_or_output_stream
+	 */
+	if( input_or_output_stream )
+	{
+		uiTemp = inl(AC97TXCR1);
+		outl( (uiTemp & ~AC97TXCR_TEN), AC97TXCR1 );
+	}
+	else
+	{
+		uiTemp = inl(AC97RXCR1);
+		outl( (uiTemp & ~AC97RXCR_REN), AC97RXCR1 );
+	}
+
+	//DDEBUG("ep93xx_audio_disable - EXIT\n");
+}
+
+
+
+/*=======================================================================================*/
+/*
+ * ep93xx_setup_src
+ *
+ * Once the ac-link is up and all is good, we want to set the codec to a 
+ * usable mode.
+ */
+static void ep93xx_setup_src(void)
+{
+	int iTemp;
+
+	/*
+	 * Set the VRA bit to enable the SRC.
+	 */
+	iTemp = peek( AC97_2A_EXT_AUDIO_POWER );
+	poke( AC97_2A_EXT_AUDIO_POWER,  (iTemp | 0x1) );
+	
+	/*
+	 * Set the DSRC/ASRC bits to enable the variable rate SRC.
+	 */
+	iTemp = peek( AC97_60_MISC_CRYSTAL_CONTROL  );
+	poke( AC97_60_MISC_CRYSTAL_CONTROL, (iTemp  | 0x0300) );
+}
+
+/*
+ * ep93xx_set_samplerate
+ *
+ *   lFrequency       - Sample Rate in Hz
+ *   bCapture       - 0 to set Tx sample rate; 1 to set Rx sample rate
+ */
+static void ep93xx_set_samplerate( long lSampleRate, int bCapture )
+{
+	unsigned short usDivider, usPhase;
+
+	DPRINTK( "ep93xx_set_samplerate - Fs = %d\n", (int)lSampleRate );
+
+	if( (lSampleRate <  7200) || (lSampleRate > 48000)  )
+	{
+		printk( "ep93xx_set_samplerate - invalid Fs = %d\n", 
+				 (int)lSampleRate );
+		return;
+	}
+
+	/*
+	 * Calculate divider and phase increment.
+	 *
+	 * divider = round( 0x1770000 / lSampleRate )
+	 *  Note that usually rounding is done by adding 0.5 to a floating 
+	 *  value and then truncating.  To do this without using floating
+	 *  point, I multiply the fraction by two, do the division, then add one, 
+	 *  then divide the whole by 2 and then truncate.
+	 *  Same effect, no floating point math.
+	 *
+	 * Ph incr = trunc( (0x1000000 / usDivider) + 1 )
+	 */
+
+	usDivider = (unsigned short)( ((2 * 0x1770000 / lSampleRate) +  1) / 2 );
+
+	usPhase = (0x1000000 / usDivider) + 1;
+
+	/*
+	 * Write them in the registers.  Spec says divider must be
+	 * written after phase incr.
+	 */
+	if(!bCapture)
+	{
+		poke( AC97_2C_PCM_FRONT_DAC_RATE, usDivider);
+		poke( AC97_64_DAC_SRC_PHASE_INCR, usPhase);
+	}
+	else
+	{
+		
+		poke( AC97_32_PCM_LR_ADC_RATE,  usDivider);
+		poke( AC97_66_ADC_SRC_PHASE_INCR, usPhase);
+	}
+	
+	DPRINTK( "ep93xx_set_samplerate - phase = %d,  divider = %d\n",
+				(unsigned int)usPhase, (unsigned int)usDivider );
+
+	/*
+	 * We sorta should report the actual samplerate back to the calling
+	 * application.  But some applications freak out if they don't get
+	 * exactly what they asked for.  So we fudge and tell them what
+	 * they want to hear.
+	 */
+	//audio_samplerate = lSampleRate;
+
+	DPRINTK( "ep93xx_set_samplerate - EXIT\n" );
+}
+
+/*
+ * ep93xx_set_hw_format
+ *
+ * Sets up whether the controller is expecting 20 bit data in 32 bit words
+ * or 16 bit data compacted to have a stereo sample in each 32 bit word.
+ */
+static void ep93xx_set_hw_format( long format,long channel )
+{
+	int bCompactMode;
+	
+	switch( format )
+	{
+		/*
+		 * Here's all the <=16 bit formats.  We can squeeze both L and R
+		 * into one 32 bit sample so use compact mode.
+		 */
+		case SNDRV_PCM_FORMAT_U8:		   
+		case SNDRV_PCM_FORMAT_S8:		   
+		case SNDRV_PCM_FORMAT_S16_LE:
+		case SNDRV_PCM_FORMAT_U16_LE:
+			bCompactMode = 1;
+			break;
+
+		/*
+		 * Add any other >16 bit formats here...
+		 */
+		case SNDRV_PCM_FORMAT_S32_LE:
+		default:
+			bCompactMode = 0;
+			break;
+	}
+	
+	if( bCompactMode )
+	{
+		DPRINTK("ep93xx_set_hw_format - Setting serial mode to 16 bit compact.\n");
+	
+		/*
+		 * Turn on Compact Mode so we can fit each stereo sample into
+		 * a 32 bit word.  Twice as efficent for DMA and FIFOs.
+		 */
+		if(channel==2){
+			outl( 0x00008018, AC97RXCR1 );
+			outl( 0x00008018, AC97TXCR1 );
+		}
+		else {
+		        outl( 0x00008018, AC97RXCR1 );
+                        outl( 0x00008018, AC97TXCR1 );
+                }
+
+
+		audio_state.DAC_bit_width = 16;
+		audio_state.bCompactMode = 1;
+	}
+	else
+	{
+		DPRINTK("ep93xx_set_hw_format - Setting serial mode to 20 bit non-CM.\n");
+	
+		/*
+		 * Turn off Compact Mode so we can do > 16 bits per channel 
+		 */
+		if(channel==2){
+			outl( 0x00004018, AC97RXCR1 );
+			outl( 0x00004018, AC97TXCR1 );
+		}
+		else{
+                        outl( 0x00004018, AC97RXCR1 );
+                        outl( 0x00004018, AC97TXCR1 );
+		}
+
+		audio_state.DAC_bit_width = 20;
+		audio_state.bCompactMode = 0;
+	}
+
+}
+
+/*
+ * ep93xx_stop_loop
+ *
+ * Once the ac-link is up and all is good, we want to set the codec to a
+ * usable mode.
+ */
+static void ep93xx_stop_loop(void)
+{
+        int iTemp;
+                                                                                                                             
+        /*
+         * Set the AC97_0E_MIC_VOL MUTE bit to enable the LOOP.
+         */
+        iTemp = peek( AC97_0E_MIC_VOL );
+        poke( AC97_0E_MIC_VOL,  (iTemp | 0x8000) );
+                                                                                                                             
+        /*
+         * Set the AC97_10_LINE_IN_VOL MUTE bit to enable the LOOP.
+         */
+        iTemp = peek( AC97_10_LINE_IN_VOL  );
+        poke( AC97_10_LINE_IN_VOL, (iTemp  | 0x8000) );
+}
+
+/*
+ * ep93xx_init_ac97_controller
+ *
+ * This routine sets up the Ac'97 Controller.
+ */
+static void ep93xx_init_ac97_controller(void)
+{
+	unsigned int uiDEVCFG, uiTemp;
+
+	DPRINTK("ep93xx_init_ac97_controller - enter\n");
+
+	/*
+	 * Configure the multiplexed Ac'97 pins to be Ac97 not I2s.
+	 * Configure the EGPIO4 and EGPIO6 to be GPIOS, not to be  
+	 * SDOUT's for the second and third I2S controller channels.
+	 */
+	uiDEVCFG = inl(SYSCON_DEVCFG);
+	
+	uiDEVCFG &= ~(SYSCON_DEVCFG_I2SonAC97 | 
+				  SYSCON_DEVCFG_A1onG |
+				  SYSCON_DEVCFG_A2onG);
+		
+	SysconSetLocked(SYSCON_DEVCFG, uiDEVCFG);
+
+	/*
+	 * Disable the AC97 controller internal loopback.  
+	 * Disable Override codec ready.
+	 */
+	outl( 0, AC97GCR );
+
+	/*
+	 * Enable the AC97 Link.
+	 */
+	uiTemp = inl(AC97GCR);
+	outl( (uiTemp | AC97GSR_IFE), AC97GCR );
+
+	/*
+	 * Set the TIMEDRESET bit.  Will cause a > 1uSec reset of the ac-link.
+	 * This bit is self resetting.
+	 */
+	outl( AC97RESET_TIMEDRESET, AC97RESET );
+	
+	/*
+	 *  Delay briefly, but let's not hog the processor.
+	 */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout( 5 ); /* 50 mSec */
+
+	/*
+	 * Read the AC97 status register to see if we've seen a CODECREADY
+	 * signal from the AC97 codec.
+	 */
+	if( !(inl(AC97RGIS) & AC97RGIS_CODECREADY))
+	{
+		printk( "ep93xx-ac97 - FAIL: CODECREADY still low!\n");
+		return;
+	}
+
+	/*
+	 *  Delay for a second, not hogging the processor
+	 */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout( HZ ); /* 1 Sec */
+	
+	/*
+	 * Now the Ac-link is up.  We can read and write codec registers.
+	 */
+	ac_link_enabled = 1;
+
+	/*
+	 * Set up the rx and tx channels
+	 * Set the CM bit, data size=16 bits, enable tx slots 3 & 4.
+	 */
+	ep93xx_set_hw_format( EP93XX_DEFAULT_FORMAT,EP93XX_DEFAULT_NUM_CHANNELS );
+
+	DPRINTK( "ep93xx-ac97 -- AC97RXCR1:  %08x\n", inl(AC97RXCR1) ); 
+	DPRINTK( "ep93xx-ac97 -- AC97TXCR1:  %08x\n", inl(AC97TXCR1) ); 
+
+	DPRINTK("ep93xx_init_ac97_controller - EXIT - success\n");
+
+}
+
+#ifdef alsa_ac97_debug
+static void ep93xx_dump_ac97_regs(void)
+{
+	int i;
+	unsigned int reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
+	
+	DPRINTK( "---------------------------------------------\n");
+	DPRINTK( "   :   0    2    4    6    8    A    C    E\n" ); 
+	
+	for( i=0 ; i < 0x80 ; i+=0x10 )
+	{
+		reg0 = 0xffff & (unsigned int)peek( i );
+		reg1 = 0xffff & (unsigned int)peek( i + 0x2 );
+		reg2 = 0xffff & (unsigned int)peek( i + 0x4 );
+		reg3 = 0xffff & (unsigned int)peek( i + 0x6 );
+		reg4 = 0xffff & (unsigned int)peek( i + 0x8 );
+		reg5 = 0xffff & (unsigned int)peek( i + 0xa );
+		reg6 = 0xffff & (unsigned int)peek( i + 0xc );
+		reg7 = 0xffff & (unsigned int)peek( i + 0xe );
+
+		DPRINTK( " %02x : %04x %04x %04x %04x %04x %04x %04x %04x\n", 
+				 i, reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7);
+	}
+
+	DPRINTK( "---------------------------------------------\n");
+}
+#endif
+
+
+#define supported_mixer(FOO) \
+        ( (FOO >= 0) && \
+        (FOO < SOUND_MIXER_NRDEVICES) && \
+        codec_supported_mixers & (1<<FOO) )
+                                                                                                                             
+/*
+ * Available record sources.
+ * LINE1 refers to AUX in.
+ * IGAIN refers to input gain which means stereo mix.
+ */
+#define AC97_RECORD_MASK \
+        (SOUND_MASK_MIC | SOUND_MASK_CD | SOUND_MASK_IGAIN | SOUND_MASK_VIDEO |\
+        SOUND_MASK_LINE1 | SOUND_MASK_LINE | SOUND_MASK_PHONEIN)
+                                                                                                                             
+#define AC97_STEREO_MASK \
+        (SOUND_MASK_VOLUME | SOUND_MASK_PCM | SOUND_MASK_LINE | SOUND_MASK_CD | \
+        SOUND_MASK_ALTPCM | SOUND_MASK_IGAIN | SOUND_MASK_LINE1 | SOUND_MASK_VIDEO)
+                                                                                                                             
+#define AC97_SUPPORTED_MASK \
+        (AC97_STEREO_MASK | SOUND_MASK_BASS | SOUND_MASK_TREBLE | \
+        SOUND_MASK_SPEAKER | SOUND_MASK_MIC | \
+        SOUND_MASK_PHONEIN | SOUND_MASK_PHONEOUT)
+
+
+
+
+/* this table has default mixer values for all OSS mixers. */
+typedef struct  {
+	int mixer;
+	unsigned int value;
+} mixer_defaults_t;
+
+/*
+ * Default mixer settings that are set up during boot.
+ *
+ * These values are 16 bit numbers in which the upper byte is right volume
+ * and the lower byte is left volume or mono volume for mono controls.
+ *
+ * OSS Range for each of left and right volumes is 0 to 100 (0x00 to 0x64).
+ * 
+ */
+static mixer_defaults_t mixer_defaults[SOUND_MIXER_NRDEVICES] = 
+{
+	/* Outputs */
+	{SOUND_MIXER_VOLUME,	0x6464},   /* 0 dB */  /* -46.5dB to  0 dB */
+	{SOUND_MIXER_ALTPCM,	0x6464},   /* 0 dB */  /* -46.5dB to  0 dB */
+	{SOUND_MIXER_PHONEOUT,	0x6464},   /* 0 dB */  /* -46.5dB to  0 dB */
+
+	/* PCM playback gain */
+	{SOUND_MIXER_PCM,		0x4b4b},   /* 0 dB */  /* -34.5dB to +12dB */
+
+	/* Record gain */
+	{SOUND_MIXER_IGAIN,		0x0000},   /* 0 dB */  /* -34.5dB to +12dB */
+
+	/* Inputs */
+	{SOUND_MIXER_MIC,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_LINE,		0x4b4b},   /* 0 dB */  /* -34.5dB to +12dB */
+
+	/* Inputs that are not connected. */
+	{SOUND_MIXER_SPEAKER,	0x0000},   /* mute */  /* -45dB   to   0dB */
+	{SOUND_MIXER_PHONEIN,	0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_CD,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_VIDEO,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_LINE1,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+
+	{-1,0} /* last entry */
+};
+
+/* table to scale scale from OSS mixer value to AC97 mixer register value */	
+typedef struct {
+	unsigned int offset;
+	int scale;
+} ac97_mixer_hw_t; 
+
+static ac97_mixer_hw_t ac97_hw[SOUND_MIXER_NRDEVICES] = 
+{
+	[SOUND_MIXER_VOLUME]		=  	{AC97_02_MASTER_VOL,	64},
+	[SOUND_MIXER_BASS]			=	{0, 0},
+	[SOUND_MIXER_TREBLE]		=	{0, 0},
+	[SOUND_MIXER_SYNTH]			=  	{0,	0},
+	[SOUND_MIXER_PCM]			=  	{AC97_18_PCM_OUT_VOL,	32},
+	[SOUND_MIXER_SPEAKER]		=  	{AC97_0A_PC_BEEP_VOL,	32},
+	[SOUND_MIXER_LINE]			=  	{AC97_10_LINE_IN_VOL,	32},
+	[SOUND_MIXER_MIC]			=  	{AC97_0E_MIC_VOL,		32},
+	[SOUND_MIXER_CD]			=  	{AC97_12_CD_VOL,		32},
+	[SOUND_MIXER_IMIX]			=  	{0,	0},
+	[SOUND_MIXER_ALTPCM]		=  	{AC97_04_HEADPHONE_VOL,	64},
+	[SOUND_MIXER_RECLEV]		=  	{0,	0},
+	[SOUND_MIXER_IGAIN]			=  	{AC97_1C_RECORD_GAIN,	16},
+	[SOUND_MIXER_OGAIN]			=  	{0,	0},
+	[SOUND_MIXER_LINE1]			=  	{AC97_16_AUX_VOL,		32},
+	[SOUND_MIXER_LINE2]			=  	{0,	0},
+	[SOUND_MIXER_LINE3]			=  	{0,	0},
+	[SOUND_MIXER_DIGITAL1]		=  	{0,	0},
+	[SOUND_MIXER_DIGITAL2]		=  	{0,	0},
+	[SOUND_MIXER_DIGITAL3]		=  	{0,	0},
+	[SOUND_MIXER_PHONEIN]		=  	{AC97_0C_PHONE_VOL,		32},
+	[SOUND_MIXER_PHONEOUT]		=  	{AC97_06_MONO_VOL,		64},
+	[SOUND_MIXER_VIDEO]			=  	{AC97_14_VIDEO_VOL,		32},
+	[SOUND_MIXER_RADIO]			=  	{0,	0},
+	[SOUND_MIXER_MONITOR]		=  	{0,	0},
+};
+
+
+/* the following tables allow us to go from OSS <-> ac97 quickly. */
+enum ac97_recsettings 
+{
+	AC97_REC_MIC=0,
+	AC97_REC_CD,
+	AC97_REC_VIDEO,
+	AC97_REC_AUX,
+	AC97_REC_LINE,
+	AC97_REC_STEREO, /* combination of all enabled outputs..  */
+	AC97_REC_MONO,	      /*.. or the mono equivalent */
+	AC97_REC_PHONE
+};
+
+static const unsigned int ac97_rm2oss[] = 
+{
+	[AC97_REC_MIC] 	 = SOUND_MIXER_MIC,
+	[AC97_REC_CD] 	 = SOUND_MIXER_CD,
+	[AC97_REC_VIDEO] = SOUND_MIXER_VIDEO,
+	[AC97_REC_AUX] 	 = SOUND_MIXER_LINE1,
+	[AC97_REC_LINE]  = SOUND_MIXER_LINE,
+	[AC97_REC_STEREO]= SOUND_MIXER_IGAIN,
+	[AC97_REC_PHONE] = SOUND_MIXER_PHONEIN
+};
+
+/* indexed by bit position */
+static const unsigned int ac97_oss_rm[] = 
+{
+	[SOUND_MIXER_MIC] 	= AC97_REC_MIC,
+	[SOUND_MIXER_CD] 	= AC97_REC_CD,
+	[SOUND_MIXER_VIDEO] = AC97_REC_VIDEO,
+	[SOUND_MIXER_LINE1] = AC97_REC_AUX,
+	[SOUND_MIXER_LINE] 	= AC97_REC_LINE,
+	[SOUND_MIXER_IGAIN]	= AC97_REC_STEREO,
+	[SOUND_MIXER_PHONEIN] 	= AC97_REC_PHONE
+};
+
+
+/*
+ * ep93xx_write_mixer
+ *
+ */
+static void ep93xx_write_mixer
+( 
+	int oss_channel,
+	unsigned int left, 
+	unsigned int right
+)
+{
+	u16 val = 0;
+	ac97_mixer_hw_t * mh = &ac97_hw[oss_channel];
+
+	DPRINTK("ac97_codec: wrote OSS %2d (ac97 0x%02x), "
+	       "l:%2d, r:%2d:",
+	       oss_channel, mh->offset, left, right);
+
+	if( !mh->scale )
+	{
+		printk( "ep93xx-ac97.c: ep93xx_write_mixer - not a valid OSS channel\n");
+		return;
+	}
+
+	if( AC97_STEREO_MASK & (1 << oss_channel) ) 
+	{
+		/* stereo mixers */
+		if (left == 0 && right == 0) 
+		{
+			val = 0x8000;
+		} 
+		else 
+		{
+			if (oss_channel == SOUND_MIXER_IGAIN) 
+			{
+				right = (right * mh->scale) / 100;
+				left = (left * mh->scale) / 100;
+				if (right >= mh->scale)
+					right = mh->scale-1;
+				if (left >= mh->scale)
+					left = mh->scale-1;
+			} 
+			else 
+			{
+				right = ((100 - right) * mh->scale) / 100;
+				left = ((100 - left) * mh->scale) / 100;
+				if (right >= mh->scale)
+					right = mh->scale-1;
+				if (left >= mh->scale)
+					left = mh->scale-1;
+			}
+			val = (left << 8) | right;
+		}
+	} 
+	else if(left == 0) 
+	{
+		val = 0x8000;
+	} 
+	else if( (oss_channel == SOUND_MIXER_SPEAKER) ||
+			(oss_channel == SOUND_MIXER_PHONEIN) ||
+			(oss_channel == SOUND_MIXER_PHONEOUT) )
+	{
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val = left;
+	} 
+	else if (oss_channel == SOUND_MIXER_MIC) 
+	{
+		val = peek( mh->offset) & ~0x801f;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= left;
+	} 
+	/*  
+	 * For bass and treble, the low bit is optional.  Masking it
+	 * lets us avoid the 0xf 'bypass'.
+	 * Do a read, modify, write as we have two contols in one reg. 
+	 */
+	else if (oss_channel == SOUND_MIXER_BASS) 
+	{
+		val = peek( mh->offset) & ~0x0f00;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= (left << 8) & 0x0e00;
+	} 
+	else if (oss_channel == SOUND_MIXER_TREBLE) 
+	{
+		val = peek( mh->offset) & ~0x000f;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= left & 0x000e;
+	}
+	
+	DPRINTK(" 0x%04x", val);
+
+	poke( mh->offset, val );
+
+#ifdef alsa_ac97_debug
+	val = peek( mh->offset );
+	DEBUG(" -> 0x%04x\n", val);
+#endif
+
+}
+
+/* a thin wrapper for write_mixer */
+static void ep93xx_set_mixer
+(
+	unsigned int oss_mixer, 
+	unsigned int val 
+) 
+{
+	unsigned int left,right;
+
+	/* cleanse input a little */
+	right = ((val >> 8)  & 0xff) ;
+	left = (val  & 0xff) ;
+
+	if (right > 100) right = 100;
+	if (left > 100) left = 100;
+
+	/*mixer_state[oss_mixer] = (right << 8) | left;*/
+	ep93xx_write_mixer( oss_mixer, left, right);
+}
+
+static void ep93xx_init_mixer(void)
+{
+	u16 cap;
+	int i;
+
+	/* mixer masks */
+	codec_supported_mixers 	= AC97_SUPPORTED_MASK;
+	
+	cap = peek( AC97_00_RESET );
+	if( !(cap & 0x04) )
+	{
+		codec_supported_mixers &= ~(SOUND_MASK_BASS|SOUND_MASK_TREBLE);
+	}
+	if( !(cap & 0x10) )
+	{
+		codec_supported_mixers &= ~SOUND_MASK_ALTPCM;
+	}
+
+	/* 
+	 * Detect bit resolution of output volume controls by writing to the
+	 * 6th bit (not unmuting yet)
+	 */
+	poke( AC97_02_MASTER_VOL, 0xa020 );
+	if( peek( AC97_02_MASTER_VOL) != 0xa020 )
+	{
+		ac97_hw[SOUND_MIXER_VOLUME].scale = 32;
+	}
+
+	poke( AC97_04_HEADPHONE_VOL, 0xa020 );
+	if( peek( AC97_04_HEADPHONE_VOL) != 0xa020 )
+	{
+		ac97_hw[AC97_04_HEADPHONE_VOL].scale = 32;
+	}
+
+	poke( AC97_06_MONO_VOL, 0x8020 );
+	if( peek( AC97_06_MONO_VOL) != 0x8020 )
+	{
+		ac97_hw[AC97_06_MONO_VOL].scale = 32;
+	}
+
+	/* initialize mixer channel volumes */
+	for( i = 0; 
+		(i < SOUND_MIXER_NRDEVICES) && (mixer_defaults[i].mixer != -1) ; 
+		i++ ) 
+	{
+		if( !supported_mixer( mixer_defaults[i].mixer) )
+		{ 
+			continue;
+		}
+		
+		ep93xx_set_mixer( mixer_defaults[i].mixer, mixer_defaults[i].value);
+	}
+
+}
+
+static int ep93xx_set_recsource( int mask ) 
+{
+	unsigned int val;
+
+	/* Arg contains a bit for each recording source */
+	if( mask == 0 ) 
+	{
+		return 0;
+	}
+	
+	mask &= AC97_RECORD_MASK;
+	
+	if( mask == 0 ) 
+	{
+		return -EINVAL;
+	}
+				
+	/*
+	 * May have more than one bit set.  So clear out currently selected
+	 * record source value first (AC97 supports only 1 input) 
+	 */
+	val = (1 << ac97_rm2oss[peek( AC97_1A_RECORD_SELECT ) & 0x07]);
+	if (mask != val)
+	    mask &= ~val;
+       
+	val = ffs(mask); 
+	val = ac97_oss_rm[val-1];
+	val |= val << 8;  /* set both channels */
+
+	/*
+	 *
+	 */
+        val = peek( AC97_1A_RECORD_SELECT ) & 0x0707;
+        if ((val&0x0404)!=0)
+          val=0x0404;
+        else if((val&0x0000)!=0)
+          val=0x0101;
+
+
+	DPRINTK("ac97_codec: setting ac97 recmask to 0x%04x\n", val);
+
+	poke( AC97_1A_RECORD_SELECT, val);
+
+	return 0;
+}
+
+/*
+ * ep93xx_init_ac97_codec
+ *
+ * Program up the external Ac97 codec.
+ *
+ */
+static void ep93xx_init_ac97_codec( void )
+{
+	DPRINTK("ep93xx_init_ac97_codec - enter\n");
+
+	ep93xx_setup_src();
+	ep93xx_set_samplerate( AUDIO_SAMPLE_RATE_DEFAULT, 0 );
+	ep93xx_set_samplerate( AUDIO_SAMPLE_RATE_DEFAULT, 1 );
+	ep93xx_init_mixer();
+
+	DPRINTK("ep93xx_init_ac97_codec - EXIT\n");
+	
+}
+
+
+/*
+ * ep93xx_audio_init
+ * Audio interface
+ */
+static void ep93xx_audio_init(void)
+{
+	DPRINTK("ep93xx_audio_init - enter\n");
+	/*
+	 * Init the controller, enable the ac-link.
+	 * Initialize the codec.
+	 */	 
+	ep93xx_init_ac97_controller();
+	ep93xx_init_ac97_codec();
+	/*stop the audio loop from the input to the output directly*/
+	ep93xx_stop_loop();
+	
+#ifdef alsa_ac97_debug
+	ep93xx_dump_ac97_regs();
+#endif
+	DPRINTK("ep93xx_audio_init - EXIT\n");
+}
+                     
+/*====================================================================================*/                     
+
+
+static void print_audio_format( long format )
+{
+    switch( format ){
+	case SNDRV_PCM_FORMAT_S8:
+		DPRINTK( "AFMT_S8\n" );		   
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:		   
+		DPRINTK( "AFMT_U8\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		DPRINTK( "AFMT_S16_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_BE:
+		DPRINTK( "AFMT_S16_BE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U16_LE:
+		DPRINTK( "AFMT_U16_LE\n" );		   
+		break;
+	case SNDRV_PCM_FORMAT_U16_BE:
+		DPRINTK( "AFMT_U16_BE\n" );
+		break;
+			
+	case SNDRV_PCM_FORMAT_S24_LE:
+		DPRINTK( "AFMT_S24_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_BE:
+		DPRINTK( "AFMT_S24_BE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U24_LE:
+		DPRINTK( "AFMT_U24_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U24_BE:
+		DPRINTK( "AFMT_U24_BE\n" );		   
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		DPRINTK( "AFMT_S24_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_BE:
+		DPRINTK( "AFMT_S24_BE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U32_LE:
+		DPRINTK( "AFMT_U24_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U32_BE:
+		DPRINTK( "AFMT_U24_BE\n" );		   
+		break;		
+	default:
+		DPRINTK( "ep93xx_i2s_Unsupported Audio Format\n" );		   
+		break;
+    }
+}
+
+static void audio_set_format( audio_stream_t * s, long val )
+{
+    DPRINTK( "ep93xx_i2s_audio_set_format enter.  Format requested (%d) %d ", 
+				(int)val,SNDRV_PCM_FORMAT_S16_LE);
+    print_audio_format( val );
+	
+    switch( val ){
+	case SNDRV_PCM_FORMAT_S8:
+		s->audio_format = SNDRV_PCM_FORMAT_S8;
+		s->audio_stream_bitwidth = 8;
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:		   
+		s->audio_format = SNDRV_PCM_FORMAT_U8;
+		s->audio_stream_bitwidth = 8;
+		break;
+			
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S16_BE:
+		s->audio_format = SNDRV_PCM_FORMAT_S16_LE;
+		s->audio_stream_bitwidth = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_U16_LE:
+	case SNDRV_PCM_FORMAT_U16_BE:
+		s->audio_format = SNDRV_PCM_FORMAT_U16_LE;
+		s->audio_stream_bitwidth = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S24_BE:		
+		s->audio_format = SNDRV_PCM_FORMAT_S24_LE;
+		s->audio_stream_bitwidth = 24;
+		break;
+
+	case SNDRV_PCM_FORMAT_U24_LE:
+	case SNDRV_PCM_FORMAT_U24_BE:		
+        	s->audio_format = SNDRV_PCM_FORMAT_U24_LE;
+		s->audio_stream_bitwidth = 24;
+		break;
+		
+	case SNDRV_PCM_FORMAT_U32_LE:
+	case SNDRV_PCM_FORMAT_U32_BE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+	case SNDRV_PCM_FORMAT_S32_BE:				
+        	s->audio_format = SNDRV_PCM_FORMAT_S32_LE;
+		s->audio_stream_bitwidth = 32;
+		break;		
+	default:
+		DPRINTK( "ep93xx_i2s_Unsupported Audio Format\n" );	
+		break;
+    }
+
+    DPRINTK( "ep93xx_i2s_audio_set_format EXIT format set to be (%d) ", (int)s->audio_format );
+    print_audio_format( (long)s->audio_format );
+}
+
+static __inline__ unsigned long copy_to_user_S24_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+			    
+    int total_to_count = to_count;
+    int *user_ptr = (int *)to;	/* 32 bit user buffer */
+    int count;
+    	
+    count = 8 * stream->dma_num_channels;
+	
+    while (to_count > 0){
+    
+	__put_user( (int)( *dma_buffer_0++ ), user_ptr++ );
+	__put_user( (int)( *dma_buffer_0++ ), user_ptr++ );
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (int)( *dma_buffer_1++ ), user_ptr++ );
+	    __put_user( (int)( *dma_buffer_1++ ), user_ptr++ );
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (int)( *dma_buffer_2++ ), user_ptr++ );
+	    __put_user( (int)( *dma_buffer_2++ ), user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U24_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+			
+    int total_to_count = to_count;
+    unsigned int * user_ptr = (unsigned int *)to;	/* 32 bit user buffer */
+    int count;
+	
+    count = 8 * stream->dma_num_channels;
+	
+    while (to_count > 0){ 
+	__put_user( ((unsigned int)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+	__put_user( ((unsigned int)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( ((unsigned int)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned int)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( ((unsigned int)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned int)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_S16_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int total_to_count = to_count;
+    short * user_ptr = (short *)to;	/* 16 bit user buffer */
+    int count;
+    	
+    count = 4 * stream->dma_num_channels;
+		
+    while (to_count > 0){
+
+	__put_user( (short)( *dma_buffer_0++ ), user_ptr++ );
+	__put_user( (short)( *dma_buffer_0++ ), user_ptr++ );
+
+        if( stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (short)( *dma_buffer_1++ ), user_ptr++ );
+	    __put_user( (short)( *dma_buffer_1++ ), user_ptr++ );
+	}
+
+        if( stream->audio_channels_flag  & CHANNEL_CENTER_LFE ){
+	    __put_user( (short)( *dma_buffer_2++ ), user_ptr++ );
+	    __put_user( (short)( *dma_buffer_2++ ), user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U16_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    short * user_ptr = (short *)to;	/* 16 bit user buffer */
+
+    count = 4 * stream->dma_num_channels;
+		
+    while (to_count > 0){
+
+	__put_user( ((unsigned short)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+	__put_user( ((unsigned short)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( ((unsigned short)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned short)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( ((unsigned short)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned short)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_S8
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    char * user_ptr = (char *)to;  /*  8 bit user buffer */
+
+    count = 2 * stream->dma_num_channels;
+	
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+		
+    while (to_count > 0){
+
+	__put_user( (char)( *dma_buffer_0 ), user_ptr++ );
+	dma_buffer_0 += 4;
+	__put_user( (char)( *dma_buffer_0 ), user_ptr++ );
+	dma_buffer_0 += 4;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (char)( *dma_buffer_1 ), user_ptr++ );
+            dma_buffer_1 += 4;
+	    __put_user( (char)( *dma_buffer_1 ), user_ptr++ );
+	    dma_buffer_1 += 4;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (char)( *dma_buffer_2 ), user_ptr++ );
+	    dma_buffer_2 += 4;
+	    __put_user( (char)( *dma_buffer_2 ), user_ptr++ );
+	    dma_buffer_2 += 4;
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U8
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    char * user_ptr = (char *)to;  /*  8 bit user buffer */
+
+    count = 2 * stream->dma_num_channels;
+		
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+	
+    while (to_count > 0){
+	
+	__put_user( (char)( *dma_buffer_0 ) ^ 0x80, user_ptr++ );
+	dma_buffer_0 += 4;
+	__put_user( (char)( *dma_buffer_0 ) ^ 0x80, user_ptr++ );
+	dma_buffer_0 += 4;
+				
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (char)( *dma_buffer_1 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_1 += 4;
+	    __put_user( (char)( *dma_buffer_1 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_1 += 4;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (char)( *dma_buffer_2 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_2 += 4;
+	    __put_user( (char)( *dma_buffer_2 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_2 += 4;
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+
+
+
+static __inline__ unsigned long copy_to_user_S16_LE_CM
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    short *dma_buffer_0 = (short *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int total_to_count = to_count;
+    short * user_ptr = (short *)to;	/* 16 bit user buffer */
+    int count;
+    
+    	
+    count = 4 * stream->dma_num_channels;
+		
+    while (to_count > 0){
+    	if(stream->audio_num_channels == 2){
+		__put_user( (short)( *dma_buffer_0++ ), user_ptr++ );
+		__put_user( (short)( *dma_buffer_0++ ), user_ptr++ );
+		to_count -= count;
+	}
+	else{
+		dma_buffer_0++; 
+		__put_user( (short)( *dma_buffer_0++ ), user_ptr++ );
+		to_count -= 2;
+	}
+	
+        if( stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (short)( *dma_buffer_1++ ), user_ptr++ );
+	    __put_user( (short)( *dma_buffer_1++ ), user_ptr++ );
+	}
+
+        if( stream->audio_channels_flag  & CHANNEL_CENTER_LFE ){
+	    __put_user( (short)( *dma_buffer_2++ ), user_ptr++ );
+	    __put_user( (short)( *dma_buffer_2++ ), user_ptr++ );
+	}
+	//to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U16_LE_CM
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    unsigned short *dma_buffer_0 = (unsigned short *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    unsigned short * user_ptr = (unsigned short *)to;	/* 16 bit user buffer */
+
+    count = 4 * stream->dma_num_channels;
+		
+    while (to_count > 0){
+
+	if(stream->audio_num_channels == 2){
+		__put_user( ((unsigned short)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+		__put_user( ((unsigned short)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+		to_count -= count;
+	}
+	else{
+		dma_buffer_0++;
+		__put_user( ((unsigned short)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+		to_count -= 2;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( ((unsigned short)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned short)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( ((unsigned short)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned short)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	}
+	//to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_S8_CM
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    unsigned short *dma_buffer_0 = (unsigned short *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    char * user_ptr = (char *)to;  /*  8 bit user buffer */
+
+    count = 2 * stream->dma_num_channels;
+	
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+		
+    while (to_count > 0){	
+	if(stream->audio_num_channels == 2){
+		__put_user( (char)( *dma_buffer_0++ >> 8), user_ptr++ );
+		//dma_buffer_0 += 4;
+		__put_user( (char)( *dma_buffer_0++ >> 8), user_ptr++ );
+		//dma_buffer_0 += 4;
+		to_count -= count;
+	}
+	else{
+		dma_buffer_0++ ;
+		__put_user( (char)( *dma_buffer_0++ >> 8), user_ptr++ );
+		
+		to_count -= 1;
+	}
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (char)( *dma_buffer_1 ), user_ptr++ );
+            dma_buffer_1 += 4;
+	    __put_user( (char)( *dma_buffer_1 ), user_ptr++ );
+	    dma_buffer_1 += 4;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (char)( *dma_buffer_2 ), user_ptr++ );
+	    dma_buffer_2 += 4;
+	    __put_user( (char)( *dma_buffer_2 ), user_ptr++ );
+	    dma_buffer_2 += 4;
+	}
+	//to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U8_CM
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    unsigned short *dma_buffer_0 = (unsigned short *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    char * user_ptr = (char *)to;  /*  8 bit user buffer */
+
+    count = 2 * stream->dma_num_channels;
+		
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+	
+    while (to_count > 0){
+	if(stream->audio_num_channels == 2){
+		__put_user( (char)( *dma_buffer_0++  >>8) ^ 0x80, user_ptr++ );
+		//dma_buffer_0 += 4;
+		__put_user( (char)( *dma_buffer_0++  >>8) ^ 0x80, user_ptr++ );
+		//dma_buffer_0 += 4;
+		to_count -= count;
+	}
+	else{
+		dma_buffer_0++;
+		__put_user( (char)( *dma_buffer_0++  >>8) ^ 0x80, user_ptr++ );
+		//dma_buffer_0 += 4;
+		to_count--;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (char)( *dma_buffer_1 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_1 += 4;
+	    __put_user( (char)( *dma_buffer_1 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_1 += 4;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (char)( *dma_buffer_2 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_2 += 4;
+	    __put_user( (char)( *dma_buffer_2 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_2 += 4;
+	}
+	//to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U32
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+
+    if(__copy_to_user( (char *)to, dma_buffer_0, to_count))
+    {
+	return -EFAULT;
+    }
+    return to_count;
+}
+
+static __inline__ int copy_to_user_with_conversion
+(
+    audio_stream_t *stream,
+    const char *to, 
+    int toCount,
+    int bCompactMode
+)
+{
+    int ret = 0;
+	
+    if( toCount == 0 ){
+	DPRINTK("ep93xx_i2s_copy_to_user_with_conversion - nothing to copy!\n");
+    }
+    
+    if( bCompactMode == 1 ){
+        
+        switch( stream->audio_format ){
+
+	case SNDRV_PCM_FORMAT_S8:
+		ret = copy_to_user_S8_CM( stream, to, toCount );
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:
+		ret = copy_to_user_U8_CM( stream, to, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		ret = copy_to_user_S16_LE_CM( stream, to, toCount );
+		break;
+		
+	case SNDRV_PCM_FORMAT_U16_LE:
+		ret = copy_to_user_U16_LE_CM( stream, to, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		//ret = copy_to_user_S24_LE( stream, to, toCount );
+		//break;
+		
+	case SNDRV_PCM_FORMAT_U24_LE:
+		//ret = copy_to_user_U24_LE( stream, to, toCount );
+		//break;
+		
+	case SNDRV_PCM_FORMAT_S32_LE:	
+        default:
+                DPRINTK( "ep93xx_i2s copy to user unsupported audio format %x\n",stream->audio_format );
+		break;
+        }
+        	
+    }
+    else{
+     
+        switch( stream->audio_format ){
+
+	case SNDRV_PCM_FORMAT_S8:
+		ret = copy_to_user_S8( stream, to, toCount );
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:
+		ret = copy_to_user_U8( stream, to, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		ret = copy_to_user_S16_LE( stream, to, toCount );
+		break;
+		
+	case SNDRV_PCM_FORMAT_U16_LE:
+		ret = copy_to_user_U16_LE( stream, to, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		//ret = copy_to_user_S24_LE( stream, to, toCount );
+		//break;
+		
+	case SNDRV_PCM_FORMAT_U24_LE:
+		//ret = copy_to_user_U24_LE( stream, to, toCount );
+		//break;
+		DPRINTK( "ep93xx_i2s copy to user unsupported audio format %x\n",stream->audio_format );
+		break;
+		
+	case SNDRV_PCM_FORMAT_S32_LE:
+	
+		//__copy_to_user( (char *)to, from, toCount);
+		ret = copy_to_user_U32( stream, to, toCount );
+		break;	
+        default:
+                DPRINTK( "ep93xx_i2s copy to user unsupported audio format\n" );
+		break;
+        }
+    
+    }
+    return ret;
+}
+
+static __inline__ int copy_from_user_S24_LE
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+
+    unsigned int * user_buffer = (unsigned int *)from;
+    unsigned int data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = (unsigned int)data;
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = (unsigned int)data;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = (unsigned int)data;
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = (unsigned int)data;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = (unsigned int)data;
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = (unsigned int)data;
+        }
+	toCount -= count;
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_U24_LE
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    unsigned int * user_buffer = (unsigned int *)from;
+    unsigned int data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	}
+	toCount -= count;
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_S16_LE
+(
+	audio_stream_t *stream,
+	const char *from, 
+	int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    unsigned short *user_buffer = (unsigned short *)from;
+    unsigned short data;
+	
+    int toCount0 = toCount;
+    int count;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+    
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = data;
+	if(stream->audio_num_channels == 2){
+	    __get_user(data, user_buffer++);
+	}
+	*dma_buffer_0++ = data;
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+    	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = data;
+    	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = data;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = data;
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = data;
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+    	return toCount0 / 4;	
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_U16_LE
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    unsigned short * user_buffer = (unsigned short *)from;
+    unsigned short data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+    
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+	if(stream->audio_num_channels == 2){
+	    __get_user(data, user_buffer++);
+	}
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+    	    __get_user(data, user_buffer++);
+            *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+        return toCount0 / 4;
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_S8
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    unsigned char * user_buffer = (unsigned char *)from;
+    unsigned char data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+
+    while (toCount > 0){
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = data;
+	dma_buffer_0 += 4;
+	if(stream->audio_num_channels == 2){
+	    __get_user(data, user_buffer++);
+	}
+	*dma_buffer_0 = data;
+	dma_buffer_0 += 4;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1 = data;
+            dma_buffer_1 += 4;
+	    __get_user(data, user_buffer++);
+            *dma_buffer_1 = data;
+	    dma_buffer_1 += 4;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2 = data;
+	    dma_buffer_2 += 4;
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2 = data;
+            dma_buffer_2 += 4;
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+    	return toCount0 / 8;
+    }
+    return toCount0 / 4;
+}
+
+static __inline__ int copy_from_user_U8
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    unsigned char *user_buffer = (unsigned char *)from;
+    unsigned char data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    dma_buffer_0 ++;
+    dma_buffer_1 ++;
+    dma_buffer_2 ++;
+			
+    while (toCount > 0){
+
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = ((unsigned char)data ^ 0x80);
+	dma_buffer_0 += 4;
+	if(stream->audio_num_channels == 2){
+	    __get_user(data, user_buffer++);
+	}
+	*dma_buffer_0 = ((unsigned char)data ^ 0x80);
+	dma_buffer_0 += 4;
+        
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1 = ((unsigned char)data ^ 0x80);
+            dma_buffer_1 += 4;
+	    __get_user(data, user_buffer++);
+            *dma_buffer_1 = ((unsigned char)data ^ 0x80);
+            dma_buffer_1 += 4;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2 = ((unsigned char)data ^ 0x80);
+    	    dma_buffer_2 += 4;
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2 = ((unsigned char)data ^ 0x80);
+            dma_buffer_2 += 4;
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+    	return toCount0 / 8;
+    }
+    return toCount0 / 4;
+}
+
+static __inline__ int copy_from_user_S16_LE_CM
+(
+	audio_stream_t *stream,
+	const char *from, 
+	int toCount 
+)
+{
+    unsigned int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    unsigned int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    unsigned int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    unsigned short *user_buffer = (unsigned short *)from;
+    short data;
+    unsigned int val;	
+    int toCount0 = toCount;
+    int count;
+    count = 4 * stream->dma_num_channels;
+
+	//printk("count=%x tocount\n",count,toCount);	
+    while (toCount > 0){
+    
+	__get_user(data, user_buffer++);
+	//*dma_buffer_0++ = data;
+	val = (unsigned int)data & 0x0000ffff;
+	if(stream->audio_num_channels == 2){
+	    __get_user(data, user_buffer++);
+        }
+	*dma_buffer_0++ = ((unsigned int)data << 16) | val;
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+    	    __get_user(data, user_buffer++);
+	    //*dma_buffer_1++ = data;
+	    val = (unsigned int)data & 0x0000ffff;
+    	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = ((unsigned int)data << 16) | val;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    //*dma_buffer_2++ = data;
+	    val = (unsigned int)data & 0x0000ffff;
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = ((unsigned int)data << 16) | val;
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+        return toCount0 /2 ;
+    }
+    
+    return toCount0 ;
+}
+
+static __inline__ int copy_from_user_U16_LE_CM
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    unsigned short * user_buffer = (unsigned short *)from;
+    unsigned short data;
+    unsigned int val;	
+    int toCount0 = toCount;
+    count = 4 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+    
+	__get_user(data, user_buffer++);
+	//*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+	val = (unsigned int)data & 0x0000ffff;
+	if(stream->audio_num_channels == 2){
+	    __get_user(data, user_buffer++);
+        }
+	//*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+        *dma_buffer_0++ = (((unsigned int)data << 16) | val) ^ 0x80008000;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    //*dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+	    val = (unsigned int)data & 0x0000ffff;
+    	    __get_user(data, user_buffer++);
+            //*dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+            *dma_buffer_1++ = (((unsigned int)data << 16) | val) ^ 0x80008000;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    //*dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	    val = (unsigned int)data & 0x0000ffff;
+	    __get_user(data, user_buffer++);
+    	    //*dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+    	    *dma_buffer_2++ = (((unsigned int)data << 16) | val) ^ 0x80008000;
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+        return toCount0/2;
+    }
+    return toCount0 ;
+}
+
+static __inline__ int copy_from_user_S8_CM
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    unsigned char * user_buffer = (unsigned char *)from;
+    unsigned char data;	
+    int toCount0 = toCount;
+    count = 4 * stream->dma_num_channels;
+
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+
+    while (toCount > 0){
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = data;
+	*(dma_buffer_0 +1 ) = 0;
+	dma_buffer_0 += 2;
+	
+	if(stream->audio_num_channels == 2){
+	    __get_user(data, user_buffer++);
+	}
+	*dma_buffer_0 = data;
+	*(dma_buffer_0 +1 ) = 0;
+	dma_buffer_0 += 2;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1 = data;
+	    dma_buffer_1 += 2;
+	    __get_user(data, user_buffer++);
+            *dma_buffer_1 = data;
+            dma_buffer_1 += 2;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2 = data;
+	    dma_buffer_2 += 2;
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2 = data;
+    	    dma_buffer_2 += 2;
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+        return toCount0 / 4;
+    }
+    
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_U8_CM
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    unsigned char *dma_buffer_0 = (unsigned char *)stream->hwbuf[0];
+    unsigned char *dma_buffer_1 = (unsigned char *)stream->hwbuf[1];
+    unsigned char *dma_buffer_2 = (unsigned char *)stream->hwbuf[2];
+    int count;
+    unsigned char *user_buffer = (unsigned char *)from;
+    unsigned char data;
+	
+    int toCount0 = toCount;
+    count = 4 * stream->dma_num_channels;
+	
+    dma_buffer_0 ++;
+    dma_buffer_1 ++;
+    dma_buffer_2 ++;
+			
+    while (toCount > 0){
+
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = ((unsigned char)data ^ 0x80);
+	*(dma_buffer_0 +1 ) = 0;
+	dma_buffer_0 += 2;
+	
+	if(stream->audio_num_channels == 2){	
+	    __get_user(data, user_buffer++);
+	}
+	*dma_buffer_0 = ((unsigned char)data ^ 0x80);
+	*(dma_buffer_0 +1 ) = 0;
+	dma_buffer_0 += 2;
+
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1 = ((unsigned char)data ^ 0x80);
+	    dma_buffer_1 += 2;
+	    __get_user(data, user_buffer++);
+            *dma_buffer_1 = ((unsigned char)data ^ 0x80);
+            dma_buffer_1 += 2;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2 = ((unsigned char)data ^ 0x80);
+    	    dma_buffer_2 += 2;
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2 = ((unsigned char)data ^ 0x80);
+            dma_buffer_2 += 2;
+	}
+	toCount -= count;
+    }
+    
+    if(stream->audio_num_channels == 1){
+        return toCount0 / 4;
+    }
+    
+    return toCount0 / 2;
+}
+
+static int copy_from_user_U32
+(
+	audio_stream_t *stream,
+	const char *from, 
+	int toCount 
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+	
+    if (copy_from_user( (char *)dma_buffer_0, from, toCount)) 
+    {
+	return -EFAULT;
+    }
+
+    return toCount;
+    
+}
+
+/*
+ * Returns negative for error
+ * Returns # of bytes transferred out of the from buffer
+ * for success.
+ */
+static __inline__ int copy_from_user_with_conversion
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount,
+    int bCompactMode 
+)
+{
+    int ret = 0;
+//    DPRINTK("copy_from_user_with_conversion\n");	
+    if( toCount == 0 ){
+    	DPRINTK("ep93xx_i2s_copy_from_user_with_conversion - nothing to copy!\n");
+    }
+
+    if( bCompactMode == 1){
+    	
+    	switch( stream->audio_format ){
+
+		case SNDRV_PCM_FORMAT_S8:
+			DPRINTK("SNDRV_PCM_FORMAT_S8 CM\n");
+			ret = copy_from_user_S8_CM( stream, from, toCount );
+			break;
+			
+		case SNDRV_PCM_FORMAT_U8:
+			DPRINTK("SNDRV_PCM_FORMAT_U8 CM\n");
+			ret = copy_from_user_U8_CM( stream, from, toCount );
+			break;
+
+		case SNDRV_PCM_FORMAT_S16_LE:
+			DPRINTK("SNDRV_PCM_FORMAT_S16_LE CM\n");
+			ret = copy_from_user_S16_LE_CM( stream, from, toCount );
+			break;
+				
+		case SNDRV_PCM_FORMAT_U16_LE:
+			DPRINTK("SNDRV_PCM_FORMAT_U16_LE CM\n");
+			ret = copy_from_user_U16_LE_CM( stream, from, toCount );
+			break;
+
+		case SNDRV_PCM_FORMAT_S24_LE:
+			DPRINTK("SNDRV_PCM_FORMAT_S24_LE CM\n");
+			//ret = copy_from_user_S24_LE( stream, from, toCount );
+			//break;
+		
+		case SNDRV_PCM_FORMAT_U24_LE:
+			DPRINTK("SNDRV_PCM_FORMAT_U24_LE CM\n");
+			//ret = copy_from_user_U24_LE( stream, from, toCount );
+			//break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			DPRINTK("SNDRV_PCM_FORMAT_S32_LE CM\n");
+			//break;
+        	default:
+                	DPRINTK( "ep93xx_i2s copy from user unsupported audio format\n" );
+			break;			
+    	}
+    }
+    else{
+        switch( stream->audio_format ){
+
+	case SNDRV_PCM_FORMAT_S8:
+		DPRINTK("SNDRV_PCM_FORMAT_S8\n");
+		ret = copy_from_user_S8( stream, from, toCount );
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:
+		DPRINTK("SNDRV_PCM_FORMAT_U8\n");
+		ret = copy_from_user_U8( stream, from, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		DPRINTK("SNDRV_PCM_FORMAT_S16_LE\n");
+		ret = copy_from_user_S16_LE( stream, from, toCount );
+		break;
+				
+	case SNDRV_PCM_FORMAT_U16_LE:
+		DPRINTK("SNDRV_PCM_FORMAT_U16_LE\n");
+		ret = copy_from_user_U16_LE( stream, from, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		DPRINTK("SNDRV_PCM_FORMAT_S24_LE\n");
+		//ret = copy_from_user_S24_LE( stream, from, toCount );
+		//break;
+		
+	case SNDRV_PCM_FORMAT_U24_LE:
+		DPRINTK("SNDRV_PCM_FORMAT_U24_LE\n");
+		//ret = copy_from_user_U24_LE( stream, from, toCount );
+		//break;
+		DPRINTK( "ep93xx_i2s copy from user unsupported audio format\n" );
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		DPRINTK("SNDRV_PCM_FORMAT_S32_LE\n");
+		ret = copy_from_user_U32( stream, from, toCount );
+		break;
+        default:
+                DPRINTK( "ep93xx_i2s copy from user unsupported audio format\n" );
+		break;			
+    	}
+    }
+	
+    return ret;
+}
+
+
+
+/*
+ *  For audio playback, we convert samples of arbitrary format to be 32 bit 
+ *  for our hardware. We're scaling a user buffer to a dma buffer.  So when
+ *  report byte counts, we scale them acording to the ratio of DMA sample
+ *  size to user buffer sample size.  When we report # of DMA fragments,
+ *  we don't scale that.  So:
+ *
+ *  Also adjust the size and number of dma fragments if sample size changed.
+ *
+ *  Input format       Input sample     Output sample size    ratio (out:in)
+ *  bits   channels    size (bytes)       CM   non-CM          CM   non-CM
+ *   8      stereo         2		   4      8            2:1   4:1
+ *   16     stereo         4		   4      8            1:1   2:1
+ *   24     stereo         6		   4      8             X    8:6 not a real case
+ *
+ */
+static void snd_ep93xx_dma2usr_ratio( audio_stream_t * stream,int bCompactMode )
+{
+    unsigned int dma_sample_size, user_sample_size;
+	
+    if(bCompactMode == 1){	    	
+	dma_sample_size = 4;	/* each stereo sample is 2 * 32 bits */    
+    }    
+    else{    	
+    	dma_sample_size = 8;    
+    }
+	
+    // If stereo 16 bit, user sample is 4 bytes.
+    // If stereo  8 bit, user sample is 2 bytes.
+    if(stream->audio_num_channels == 1){
+    	user_sample_size = stream->audio_stream_bitwidth / 8;
+    }
+    else{
+    	user_sample_size = stream->audio_stream_bitwidth / 4;
+    }
+	
+    stream->dma2usr_ratio = dma_sample_size / user_sample_size;
+}
+
+static int snd_ep93xx_dma_free(struct snd_pcm_substream *substream ){
+
+    
+    audio_state_t *state = substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                              state->output_stream:state->input_stream;
+    int i;
+    DPRINTK("snd_ep93xx_dma_free - enter\n");
+
+    for( i = 0 ; i < stream->dma_num_channels ;i++ ){
+	ep93xx_dma_free( stream->dmahandles[i] );
+    }
+    DPRINTK("snd_ep93xx_dma_free - exit\n");
+    return 0;	       
+}
+
+static int snd_ep93xx_dma_config(struct snd_pcm_substream *substream ){
+
+    audio_state_t *state = substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                               state->output_stream:state->input_stream;
+    int i,err = 0;
+	
+    DPRINTK("snd_ep93xx_dma_config - enter\n");
+
+    for( i = 0 ; i < stream->dma_num_channels ;i++ ){
+    
+        err = ep93xx_dma_request(&stream->dmahandles[i],
+	                        stream->devicename,
+	                        (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+				state->output_dma[i]:state->input_dma[i] );
+        if (err){
+	    printk("snd_ep93xx_dma_config - exit ERROR dma request failed\n");
+	    return err;
+        }
+	err = ep93xx_dma_config( stream->dmahandles[i],
+    				IGNORE_CHANNEL_ERROR,
+				0,
+				(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? 
+				snd_ep93xx_dma_tx_callback:snd_ep93xx_dma_rx_callback,
+				(unsigned int)substream );
+        if (err){
+	    printk("snd_ep93xx_dma_config - exit ERROR dma request failed\n");
+	    return err;
+	}
+    }
+
+    DPRINTK("snd_ep93xx_dma_config - enter\n");
+    return err;
+}
+
+static void snd_ep93xx_dma_start( audio_state_t * state, audio_stream_t * stream )
+{
+    int err,i;
+
+    DPRINTK("snd_ep93xx_dma_start - enter\n");
+
+    for(i = 0 ;i < stream->dma_num_channels;i++)
+	err = ep93xx_dma_start( stream->dmahandles[i], 1,(unsigned int *) stream->dmahandles );
+	
+    stream->active = 1;
+    
+    DPRINTK("snd_ep93xx_dma_start - exit\n");
+}
+
+static void snd_ep93xx_dma_pause( audio_state_t * state, audio_stream_t * stream )
+{
+    int i;
+ 
+    DPRINTK("snd_ep93xx_dma_pause - enter\n");
+
+    for(i = 0 ;i < stream->dma_num_channels;i++)
+	ep93xx_dma_pause( stream->dmahandles[i], 1,(unsigned int *)stream->dmahandles );
+
+    stream->active = 0;
+    DPRINTK("snd_ep93xx_dma_pause - exit\n");
+
+}
+
+static void snd_ep93xx_dma_flush( audio_state_t * state, audio_stream_t * stream ){
+
+    int i;
+    
+    DPRINTK("snd_ep93xx_dma_flush - enter\n");
+	
+    for( i = 0 ; i < stream->dma_num_channels ; i++ )
+	ep93xx_dma_flush( stream->dmahandles[i] );
+	   
+    DPRINTK("snd_ep93xx_dma_flush - exit\n");
+}
+
+static void snd_ep93xx_deallocate_buffers(struct snd_pcm_substream *substream, audio_stream_t *stream )
+{
+    int i;
+    audio_channel_t *dma_chan;
+    
+    DPRINTK("snd_ep93xx_deallocate_buffers - enter\n");
+    
+    if( stream->dma_channels ){
+
+        for(i = 0;i < stream->dma_num_channels;i++){
+
+	    dma_chan = &stream->dma_channels[i];
+
+	    if( dma_chan->area ){
+	    	    
+		if( dma_chan->audio_buffers ){
+
+		    kfree(dma_chan->audio_buffers);
+		    dma_chan->audio_buffers = NULL;
+		    
+		}
+
+		kfree(dma_chan->area);
+		dma_chan->area = NULL;
+	    }    
+	}
+	kfree(stream->dma_channels);
+	stream->dma_channels = NULL;
+    }
+    DPRINTK("snd_ep93xx_deallocate_buffers - exit\n");
+}
+
+static int snd_ep93xx_allocate_buffers( struct snd_pcm_substream *substream, audio_stream_t *stream)
+{
+    audio_channel_t *channel;
+    unsigned int size,tmpsize,bufsize,bufextsize;
+    int i,j;
+    
+        
+    DPRINTK("snd_ep93xx_allocate_buffers - enter\n" );
+
+    if (stream->dma_channels){
+	printk("ep93xx_i2s  %s BUSY\n",__FUNCTION__);
+        return -EBUSY;
+    }
+							       
+    stream->dma_channels = (audio_channel_t *)kmalloc(sizeof(audio_channel_t) * stream->dma_num_channels , GFP_KERNEL);
+	    
+    if (!stream->dma_channels){
+	printk(AUDIO_NAME ": unable to allocate dma_channels memory\n");
+	return - ENOMEM;
+    }
+    
+    size = ( stream->dmasize / stream->dma_num_channels ) * stream->dma2usr_ratio; 
+
+    for( i = 0; i < stream->dma_num_channels;i++){
+	channel = &stream->dma_channels[i];
+
+	channel->area = kmalloc( size, GFP_DMA );
+			
+	if(!channel->area){
+	    printk(AUDIO_NAME ": unable to allocate audio memory\n");
+	    return -ENOMEM;
+	}	
+	channel->bytes = size;
+	channel->addr = __virt_to_phys((int) channel->area);
+        memset( channel->area, 0, channel->bytes );
+
+	bufsize = ( stream->fragsize / stream->dma_num_channels ) * stream->dma2usr_ratio;
+	channel->audio_buff_count = size / bufsize;
+	bufextsize = size % bufsize;
+
+	if( bufextsize > 0 ){
+	    channel->audio_buff_count++;
+	}
+	
+	channel->audio_buffers = (audio_buf_t *)kmalloc(sizeof(audio_buf_t) * channel->audio_buff_count , GFP_KERNEL);
+		    
+	if (!channel->audio_buffers){
+	    printk(AUDIO_NAME ": unable to allocate audio memory\n ");
+	    return -ENOMEM;
+	}
+
+	tmpsize = size;
+
+	for( j = 0; j < channel->audio_buff_count; j++){
+
+	    channel->audio_buffers[j].dma_addr = channel->addr + j * bufsize;		
+
+	    if( tmpsize >= bufsize ){
+		tmpsize -= bufsize;
+		channel->audio_buffers[j].bytes = bufsize;
+		channel->audio_buffers[j].reportedbytes = bufsize / stream->dma2usr_ratio; 
+	    }
+	    else{
+                channel->audio_buffers[j].bytes = bufextsize;
+                channel->audio_buffers[j].reportedbytes = bufextsize / stream->dma2usr_ratio;
+	    }
+	}								
+    }
+
+    DPRINTK("snd_ep93xx_allocate_buffers -- exit SUCCESS\n" );
+    return 0;
+}
+
+/*
+ * DMA callback functions
+ */
+ 
+static void snd_ep93xx_dma_tx_callback
+( 
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+    int handle;
+    int i,chan;
+    unsigned int buf_id;
+	    		
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)user_data;
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    audio_stream_t *stream = state->output_stream;
+    audio_buf_t *buf;
+
+    switch( device )              
+    {
+	case DMATx_I2S3:
+	    DPRINTK( "snd_ep93xx_dma_tx_callback - DMATx_I2S3\n");
+	    i = 2;
+	    break;
+    	case DMATx_I2S2:
+	    DPRINTK( "snd_ep93xx_dma_tx_callback - DMATx_I2S2\n");
+       	    i = 1;
+	    break;
+	case DMATx_I2S1:
+	    default:
+	    DPRINTK( "snd_ep93xx_dma_tx_callback - DMATx_I2S1\n");
+       	    i = 0;
+	    break;
+    }
+    
+    if(stream->audio_num_channels == 1){
+    	chan = 0;
+    }
+    else{
+        chan = stream->audio_num_channels / 2 - 1;
+    } 
+    handle = stream->dmahandles[i];
+
+    if(stream->stopped == 0){
+
+	if( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0 ){
+
+	    buf = (audio_buf_t *)buf_id;
+            stream->bytecount += buf->reportedbytes;
+	    ep93xx_dma_add_buffer( stream->dmahandles[i],
+				    (unsigned int)buf->dma_addr,
+				    0,
+				    buf->bytes,
+				    0,
+				    (unsigned int) buf );
+
+            if(chan == i)
+	        snd_pcm_period_elapsed(substream);
+	}
+    }
+}
+
+static void snd_ep93xx_dma_rx_callback
+(
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+    int handle,i,chan;
+    unsigned int buf_id;
+    audio_buf_t *buf;
+		
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)user_data;
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    audio_stream_t *stream = state->input_stream;
+
+    switch( device ){
+		
+	case DMARx_I2S3:
+    	    DPRINTK( "snd_ep93xx_dma_rx_callback - DMARx_I2S3\n");
+	    i = 2;
+	    break;
+    	case DMARx_I2S2:
+          DPRINTK( "snd_ep93xx_dma_rx_callback - DMARx_I2S2\n");
+	    i = 1;
+	    break;
+	case DMARx_I2S1:
+	    default:
+	    DPRINTK( "snd_ep93xx_dma_rx_callback - DMARx_I2S1\n");
+	    i = 0;
+	    break;
+    }
+    
+    if(stream->audio_num_channels == 1){
+    	chan = 0;
+    }
+    else{
+        chan = stream->audio_num_channels / 2 - 1;
+    } 
+    handle = stream->dmahandles[i];
+    
+    if( stream->stopped == 0 ){
+	
+        if( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0 ){
+
+    	    buf = (audio_buf_t *)buf_id;
+	    stream->bytecount += buf->reportedbytes;
+	    ep93xx_dma_add_buffer( stream->dmahandles[i],
+				    (unsigned int)buf->dma_addr,
+				    0, 
+				    buf->bytes,
+				    0,
+				    (unsigned int) buf );
+
+            if( i == chan )
+                snd_pcm_period_elapsed(substream);
+	}
+    } 
+}
+
+static int snd_ep93xx_release(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                             state->output_stream : state->input_stream;
+    
+    DPRINTK("snd_ep93xx_release - enter\n");
+
+    down(&state->sem);
+    stream->active = 0;
+    stream->stopped = 0;
+    snd_ep93xx_deallocate_buffers(substream, stream);
+    up(&state->sem);
+
+    DPRINTK("snd_ep93xx_release - exit\n");
+
+    return 0;
+}
+
+static int ep93xx_ac97_pcm_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int r;
+	int iTempMasterVol,iTempHeadphoneVol,iTempMonoVol,iTempRecordSelect;
+        /*save the old mixer*/
+      	iTempRecordSelect 	= peek(AC97_1A_RECORD_SELECT);
+        iTempMasterVol		= peek( AC97_02_MASTER_VOL);
+        iTempHeadphoneVol	= peek( AC97_04_HEADPHONE_VOL);
+        iTempMonoVol		= peek( AC97_06_MONO_VOL);
+
+	runtime->hw.channels_min = 1;
+	runtime->hw.channels_max = 2;
+
+ 	ep93xx_audio_init();
+	/*ep93xx_init_ac97_controller();*/
+
+        /*reset the old output mixer*/
+        poke( AC97_02_MASTER_VOL, iTempMasterVol);
+        poke( AC97_04_HEADPHONE_VOL,iTempHeadphoneVol );
+        poke( AC97_06_MONO_VOL, iTempMonoVol);
+	poke( AC97_1A_RECORD_SELECT,iTempRecordSelect);
+		
+	r = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+	    AC97_RATES_FRONT_DAC : AC97_RATES_ADC;
+	
+	DPRINTK(" ep93xx_ac97_pcm_startup=%x\n",r);
+
+		return 0;
+}
+
+
+static int snd_ep93xx_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+        DPRINTK("snd_ep93xx_pcm_hw_params - enter\n");
+	return snd_pcm_lib_malloc_pages(substream,params_buffer_bytes(params));
+}
+
+static int snd_ep93xx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+
+	DPRINTK("snd_ep93xx_pcm_hw_free - enter\n");
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/*
+ *snd_ep93xx_pcm_prepare: need to finish these functions as lower
+ *chip_set_sample_format
+ *chip_set_sample_rate
+ *chip_set_channels
+ *chip_set_dma_setup
+ */
+
+static int snd_ep93xx_pcm_prepare_playback( struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *) substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->output_stream;
+
+    DPRINTK("snd_ep93xx_pcm_prepare_playback - enter\n");
+    
+    ep93xx_audio_disable(1);
+    ep93xx_ac97_pcm_startup(substream);
+	        
+    snd_ep93xx_deallocate_buffers(substream,stream);
+			
+    //if(runtime->channels % 2 != 0)
+    //	return -1;
+		   	
+    DPRINTK("The runtime item : \n");
+    DPRINTK("runtime->dma_addr    = 0x%x\n", runtime->dma_addr);
+    DPRINTK("runtime->dma_area    = 0x%x\n", runtime->dma_area);
+    DPRINTK("runtime->dma_bytes   = %d\n",   runtime->dma_bytes);
+    DPRINTK("runtime->frame_bits  = %d\n",   runtime->frame_bits);
+    DPRINTK("runtime->buffer_size = %d\n",   runtime->buffer_size);
+    DPRINTK("runtime->period_size = %d\n",   runtime->period_size);
+    DPRINTK("runtime->periods     = %d\n",   runtime->periods);
+    DPRINTK("runtime->rate        = %d\n",   runtime->rate);
+    DPRINTK("runtime->format      = %d\n",   runtime->format);
+    DPRINTK("runtime->channels    = %d\n",   runtime->channels);
+	
+    /* set requestd format when available */
+    stream->audio_num_channels = runtime->channels;
+    if(stream->audio_num_channels == 1){
+    	stream->dma_num_channels = 1;
+    }
+    else{
+    	stream->dma_num_channels = runtime->channels / 2;
+    }
+
+    stream->audio_channels_flag = CHANNEL_FRONT;
+    if(stream->dma_num_channels == 2)
+        stream->audio_channels_flag |= CHANNEL_REAR;
+    if(stream->dma_num_channels == 3)
+        stream->audio_channels_flag |= CHANNEL_REAR | CHANNEL_CENTER_LFE;
+			    
+    stream->dmasize = runtime->dma_bytes;
+    stream->nbfrags = runtime->periods;
+    stream->fragsize = frames_to_bytes (runtime, runtime->period_size);
+    stream->bytecount = 0;
+
+    if( !state->codec_set_by_capture ){
+	state->codec_set_by_playback = 1;
+	
+	if( stream->audio_rate != runtime->rate ){
+	    ep93xx_set_samplerate( runtime->rate,0 );
+	}    
+	//if( stream->audio_format != runtime->format ){
+    	//    snd_ep93xx_i2s_init((stream->audio_stream_bitwidth == 24));
+	//}
+    }
+    else{
+        audio_stream_t *s = state->input_stream;
+        if( runtime->format != s->audio_format)
+    	    return -1;
+	if( runtime->rate != s->audio_rate )
+	    return -1;
+    }
+    
+    stream->audio_format = runtime->format ;	
+    ep93xx_set_hw_format(stream->audio_format,stream->audio_num_channels);
+    
+    
+    stream->audio_rate = runtime->rate;
+    audio_set_format( stream, runtime->format );
+    snd_ep93xx_dma2usr_ratio( stream,state->bCompactMode );
+	
+    if( snd_ep93xx_allocate_buffers( substream, stream ) != 0 ){
+        snd_ep93xx_deallocate_buffers( substream, stream );
+        return -1;
+    }
+    
+    ep93xx_audio_enable(1);
+												 
+    DPRINTK("snd_ep93xx_pcm_prepare_playback - exit\n");
+    return 0;	
+}
+
+static int snd_ep93xx_pcm_prepare_capture( struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *) substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->input_stream;
+    
+    ep93xx_audio_disable(0);
+    ep93xx_ac97_pcm_startup(substream);
+	
+    snd_ep93xx_deallocate_buffers(substream,stream);
+
+    //if(runtime->channels % 2 != 0)
+	//return -1;
+		   		       
+    DPRINTK("snd_ep93xx_pcm_prepare_capture - enter\n");
+			
+//    printk("The runtime item : \n");
+//    printk("runtime->dma_addr    = 0x%x\n", runtime->dma_addr);
+//    printk("runtime->dma_area    = 0x%x\n", runtime->dma_area);
+//    printk("runtime->dma_bytes   = %d\n",   runtime->dma_bytes);
+//    printk("runtime->frame_bits  = %d\n",   runtime->frame_bits);
+//    printk("runtime->buffer_size = %d\n",   runtime->buffer_size);
+//    printk("runtime->period_size = %d\n",   runtime->period_size);
+//    printk("runtime->periods     = %d\n",   runtime->periods);
+//    printk("runtime->rate        = %d\n",   runtime->rate);
+//    printk("runtime->format      = %d\n",   runtime->format);
+//    printk("runtime->channels    = %d\n",   runtime->channels);
+	
+    /* set requestd format when available */
+    stream->audio_num_channels = runtime->channels;
+    if(stream->audio_num_channels == 1){
+    	stream->dma_num_channels = 1;
+    }
+    else{
+    	stream->dma_num_channels = runtime->channels / 2;
+    }
+
+    stream->audio_channels_flag = CHANNEL_FRONT;
+    if(stream->dma_num_channels == 2)
+	stream->audio_channels_flag |= CHANNEL_REAR;
+    if(stream->dma_num_channels == 3)
+	stream->audio_channels_flag |= CHANNEL_REAR | CHANNEL_CENTER_LFE;
+			    
+    stream->dmasize = runtime->dma_bytes;
+    stream->nbfrags = runtime->periods;
+    stream->fragsize = frames_to_bytes (runtime, runtime->period_size);
+    stream->bytecount = 0;
+
+    if( !state->codec_set_by_playback ){
+	state->codec_set_by_capture = 1;
+	
+	/*rate*/
+	if( stream->audio_rate != runtime->rate ){
+    	    ep93xx_set_samplerate( runtime->rate,1 );
+	}
+	
+	/*mixer*/
+	ep93xx_set_recsource(SOUND_MASK_MIC|SOUND_MASK_LINE1 | SOUND_MASK_LINE);
+	poke( AC97_1C_RECORD_GAIN, 0);
+	
+	/*format*/	
+        //if( stream->audio_format != runtime->format ){
+    	//    snd_ep93xx_i2s_init((stream->audio_stream_bitwidth == 24));
+	//}
+    }
+    else{
+        audio_stream_t *s = state->output_stream;
+        if( runtime->format != s->audio_format)
+    	    return -1;
+	if( runtime->rate != s->audio_rate )
+    	    return -1;
+    }
+    
+    stream->audio_format = runtime->format ;	
+    ep93xx_set_hw_format(stream->audio_format,stream->audio_num_channels);
+    
+    
+    stream->audio_rate = runtime->rate;
+    audio_set_format( stream, runtime->format );
+    snd_ep93xx_dma2usr_ratio( stream,state->bCompactMode );
+
+    if( snd_ep93xx_allocate_buffers( substream, stream ) != 0 ){
+        snd_ep93xx_deallocate_buffers( substream, stream );
+	return -1;
+    }
+    
+    ep93xx_audio_enable(0);
+												 
+    DPRINTK("snd_ep93xx_pcm_prepare_capture - exit\n");
+    return 0;	
+}
+/*
+ *start/stop/pause dma translate
+ */
+static int snd_ep93xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{	
+    audio_state_t  *state = (audio_state_t *)substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+				state->output_stream:state->input_stream;
+    audio_buf_t *buf; 
+    audio_channel_t *dma_channel;
+    int i,count,ret = 0;
+    unsigned long flags;
+
+    DPRINTK("snd_ep93xx_pcm_triger %d - enter \n",cmd);
+					
+    switch (cmd){
+    
+	case SNDRV_PCM_TRIGGER_START:
+				
+	    snd_ep93xx_dma_config( substream );
+
+            stream->stopped = 0;
+		
+            if( !stream->active && !stream->stopped ){
+	        stream->active = 1;
+    		snd_ep93xx_dma_start( state, stream );
+            }
+
+            local_irq_save(flags);
+    
+	    for (i = 0; i < stream->dma_num_channels; i++){
+		dma_channel = &stream->dma_channels[i];
+
+		for(count = 0 ;count < dma_channel->audio_buff_count; count++){
+		
+		    buf = &dma_channel->audio_buffers[count];																	
+    		    ep93xx_dma_add_buffer( stream->dmahandles[i],
+					    (unsigned int)buf->dma_addr,
+		            		    0,
+		                	    buf->bytes,
+					    0,
+					    (unsigned int) buf );
+		}
+	    }	
+						
+	    local_irq_restore(flags);
+	    break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	    stream->stopped = 1;
+	    snd_ep93xx_dma_pause( state, stream );
+	    snd_ep93xx_dma_flush( state, stream );
+	    snd_ep93xx_dma_free( substream );
+	    break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	    break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	    break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	    break;
+
+	    default:
+	    ret = -EINVAL;
+    }
+    DPRINTK("snd_ep93xx_pcm_triger %d - exit \n",cmd);
+    return ret;
+}
+
+static snd_pcm_uframes_t snd_ep93xx_pcm_pointer_playback(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->output_stream;
+    snd_pcm_uframes_t pointer = 0;
+
+    pointer = bytes_to_frames( runtime,stream->bytecount );
+
+    if (pointer >= runtime->buffer_size){
+	pointer = 0;
+	stream->bytecount = 0;
+    }
+			    
+    DPRINTK("snd_ep93xx_pcm_pointer_playback - exit\n");
+    return pointer;
+}
+
+static snd_pcm_uframes_t snd_ep93xx_pcm_pointer_capture(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->input_stream;
+    snd_pcm_uframes_t pointer = 0;
+	
+    pointer = bytes_to_frames( runtime,stream->bytecount );
+	
+    if (pointer >= runtime->buffer_size){
+	pointer = 0;
+	stream->bytecount = 0;
+    }
+	
+    DPRINTK("snd_ep93xx_pcm_pointer_capture - exit\n");
+    return pointer;
+}
+
+static int snd_ep93xx_pcm_open(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                                state->output_stream:state->input_stream;
+
+    DPRINTK("snd_ep93xx_pcm_open - enter\n");
+
+    down(&state->sem);
+            
+    runtime->hw = ep93xx_ac97_pcm_hardware;
+
+    stream->dma_num_channels = AUDIO_DEFAULT_DMACHANNELS;
+    stream->dma_channels = NULL;
+    stream->audio_rate = 0;
+    stream->audio_stream_bitwidth = 0;
+    	    
+    up(&state->sem);
+	
+    DPRINTK("snd_ep93xx_pcm_open - exit\n");
+    return 0;		
+}
+
+/*
+ *free the HW dma channel
+ *free the HW dma buffer
+ *free the Hw dma decrotion using function :kfree
+ */
+static int snd_ep93xx_pcm_close(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+
+    DPRINTK("snd_ep93xx_pcm_close - enter\n");
+
+    snd_ep93xx_release(substream);
+
+    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	state->codec_set_by_playback = 0;
+    else
+	state->codec_set_by_capture = 0;
+
+    DPRINTK("snd_ep93xx_pcm_close - exit\n");
+    return 0;
+}
+
+static int snd_ep93xx_pcm_copy_playback(struct snd_pcm_substream * substream,int channel, 
+				snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+
+    audio_state_t *state = (audio_state_t *)substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->output_stream ;
+    audio_channel_t *dma_channel;
+    int i;
+    int tocount = frames_to_bytes(runtime,count);
+    
+    for( i = 0; i < stream->dma_num_channels; i++ ){
+
+	dma_channel = &stream->dma_channels[i];	
+	stream->hwbuf[i] = dma_channel->area + ( frames_to_bytes(runtime,pos) * stream->dma2usr_ratio / stream->dma_num_channels );
+    
+    }
+
+    if(copy_from_user_with_conversion(stream ,(const char*)src,(tocount * stream->dma2usr_ratio),state->bCompactMode) <=0 ){
+	DPRINTK(KERN_ERR "copy_from_user_with_conversion() failed\n");
+	return -EFAULT;
+    }
+					
+    DPRINTK("snd_ep93xx_pcm_copy_playback - exit\n");
+    return 0;
+}
+
+
+static int snd_ep93xx_pcm_copy_capture(struct snd_pcm_substream * substream,int channel, 
+				snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+    audio_state_t *state = (audio_state_t *)substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->input_stream ;
+    audio_channel_t *dma_channel;
+    int i;
+		       
+    int tocount = frames_to_bytes(runtime,count);
+			   
+    for( i = 0; i < stream->dma_num_channels; i++ ){
+  
+	dma_channel = &stream->dma_channels[i];
+	stream->hwbuf[i] = dma_channel->area + ( frames_to_bytes(runtime,pos) * stream->dma2usr_ratio / stream->dma_num_channels );
+
+    }
+
+    if(copy_to_user_with_conversion(stream,(const char*)src,tocount,state->bCompactMode) <=0 ){
+
+	DPRINTK(KERN_ERR "copy_to_user_with_conversion() failed\n");
+	return -EFAULT;
+    }
+										       
+    DPRINTK("snd_ep93xx_pcm_copy_capture - exit\n");
+    return 0;
+}
+
+/*----------------------------------------------------------------------------------*/
+static unsigned short ep93xx_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
+{
+	int val = -1;
+	/*volatile u32 *reg_addr;*/
+
+	DPRINTK(" number of codec:%x reg=%x\n",ac97->num,reg);
+	val=peek(reg);
+	if(val==-1){
+		printk(KERN_ERR "%s: read error (ac97_reg=%d )val=%x\n",
+				__FUNCTION__, reg, val);
+		return 0;
+	}
+
+	return val;
+}
+
+static void ep93xx_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
+{
+	/*volatile u32 *reg_addr;*/
+	int ret;
+
+	DPRINTK(" number of codec:%x rge=%x val=%x\n",ac97->num,reg,val);
+	ret=poke(reg, val);
+	if(ret!=0){
+		printk(KERN_ERR "%s: write error (ac97_reg=%d val=%x)\n",
+				__FUNCTION__, reg, val);
+	}
+
+}
+
+static void ep93xx_ac97_reset(struct snd_ac97 *ac97)
+{
+
+	DPRINTK(" ep93xx_ac97_reset\n");
+	ep93xx_audio_init();
+
+}
+
+static struct snd_ac97_bus_ops ep93xx_ac97_ops = {
+	.read	= ep93xx_ac97_read,
+	.write	= ep93xx_ac97_write,
+	.reset	= ep93xx_ac97_reset,
+};
+
+static struct snd_pcm *ep93xx_ac97_pcm;
+static struct snd_ac97 *ep93xx_ac97_ac97;																					     
+
+static struct snd_pcm_ops snd_ep93xx_pcm_playback_ops = {
+	.open		= snd_ep93xx_pcm_open,
+	.close		= snd_ep93xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_ep93xx_pcm_hw_params,
+	.hw_free	= snd_ep93xx_pcm_hw_free,
+	.prepare	= snd_ep93xx_pcm_prepare_playback,
+	.trigger	= snd_ep93xx_pcm_trigger,
+	.pointer	= snd_ep93xx_pcm_pointer_playback,
+	.copy		= snd_ep93xx_pcm_copy_playback,
+	
+};
+
+static struct snd_pcm_ops snd_ep93xx_pcm_capture_ops = {
+	.open		= snd_ep93xx_pcm_open,
+	.close		= snd_ep93xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_ep93xx_pcm_hw_params,
+	.hw_free	= snd_ep93xx_pcm_hw_free,
+	.prepare	= snd_ep93xx_pcm_prepare_capture,
+	.trigger	= snd_ep93xx_pcm_trigger,
+	.pointer	= snd_ep93xx_pcm_pointer_capture,
+	.copy 		= snd_ep93xx_pcm_copy_capture,
+};
+
+/*--------------------------------------------------------------------------*/
+
+
+static int snd_ep93xx_pcm_new(struct snd_card *card, audio_state_t *state, struct snd_pcm **rpcm)
+{
+    struct snd_pcm *pcm;
+    int play = state->output_stream? 1 : 0;/*SNDRV_PCM_STREAM_PLAYBACK*/
+    int capt = state->input_stream ? 1 : 0;/*SNDRV_PCM_STREAM_CAPTURE*/
+    int ret = 0;
+
+    DPRINTK("snd_ep93xx_pcm_new - enter\n");
+	
+    /* Register the new pcm device interface */
+    ret = snd_pcm_new(card, "EP93xx-AC97-PCM", 0, play, capt, &pcm);
+
+    if (ret){
+	DPRINTK("%s--%x:card=%x,play=%x,capt=%x,&pcm=%x\n",__FUNCTION__,ret,(int)card,play,capt,(int)pcm);
+	goto out;
+    }
+
+    /* allocate the pcm(DMA) memory */
+    ret = snd_pcm_lib_preallocate_pages_for_all(pcm, /*SNDRV_DMA_TYPE_DEV,0,*/SNDRV_DMA_TYPE_CONTINUOUS,snd_dma_continuous_data(GFP_KERNEL),128*1024,128*1024);
+
+    DPRINTK("The substream item : \n");
+    DPRINTK("pcm->streams[0].substream->dma_buffer.addr  = 0x%x\n", pcm->streams[0].substream->dma_buffer.addr);
+    DPRINTK("pcm->streams[0].substream->dma_buffer.area  = 0x%x\n", pcm->streams[0].substream->dma_buffer.area);
+    DPRINTK("pcm->streams[0].substream->dma_buffer.bytes = 0x%x\n", pcm->streams[0].substream->dma_buffer.bytes);
+    DPRINTK("pcm->streams[1].substream->dma_buffer.addr  = 0x%x\n", pcm->streams[1].substream->dma_buffer.addr);
+    DPRINTK("pcm->streams[1].substream->dma_buffer.area  = 0x%x\n", pcm->streams[1].substream->dma_buffer.area);
+    DPRINTK("pcm->streams[1].substream->dma_buffer.bytes = 0x%x\n", pcm->streams[1].substream->dma_buffer.bytes);	
+
+    pcm->private_data = state;
+	
+    /* seem to free the pcm data struct-->self dma buffer */
+    pcm->private_free = (void*) snd_pcm_lib_preallocate_free_for_all;
+
+    /* alsa pcm ops setting for SNDRV_PCM_STREAM_PLAYBACK */
+    if (play) {
+	int stream = SNDRV_PCM_STREAM_PLAYBACK;
+	snd_pcm_set_ops(pcm, stream, &snd_ep93xx_pcm_playback_ops);
+    }
+
+    /* alsa pcm ops setting for SNDRV_PCM_STREAM_CAPTURE */	
+    if (capt) {
+	int stream = SNDRV_PCM_STREAM_CAPTURE;
+	snd_pcm_set_ops(pcm, stream, &snd_ep93xx_pcm_capture_ops);
+    }
+
+    if (rpcm)
+	*rpcm = pcm;
+    DPRINTK("snd_ep93xx_pcm_new - exit\n");
+out:
+    return ret;
+}
+
+#ifdef CONFIG_PM
+
+int ep93xx_ac97_do_suspend(struct snd_card *card, pm_message_t state)
+{
+	if (card->power_state != SNDRV_CTL_POWER_D3cold) {
+		snd_pcm_suspend_all(ep93xx_ac97_pcm);
+		snd_ac97_suspend(ep93xx_ac97_ac97);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D3cold);
+	}
+
+	return 0;
+}
+
+int ep93xx_ac97_do_resume(struct snd_card *card)
+{
+	if (card->power_state != SNDRV_CTL_POWER_D0) {
+
+		snd_ac97_resume(ep93xx_ac97_ac97);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	}
+
+	return 0;
+}
+
+int ep93xx_ac97_suspend(struct platform_device *_dev, pm_message_t state)
+{
+	snd_card_t *card = platform_get_drvdata(_dev);
+	int ret = 0;
+
+	if (card /*&& level == SUSPEND_DISABLE*/)
+		ret = ep93xx_ac97_do_suspend(card, PMSG_SUSPEND);
+
+	return ret;
+}
+
+int ep93xx_ac97_resume(struct platform_device *_dev)
+{
+	snd_card_t *card = platform_get_drvdata(_dev);
+	int ret = 0;
+
+	if (card /*&& level == RESUME_ENABLE*/)
+		ret = ep93xx_ac97_do_resume(card, SNDRV_CTL_POWER_D0);
+
+	return ret;
+}
+
+#else
+/*
+#define ep93xx_ac97_do_suspend		NULL
+#define ep93xx_ac97_do_resume		NULL
+#define ep93xx_ac97_suspend		NULL
+#define ep93xx_ac97_resume		NULL
+*/
+
+int ep93xx_ac97_do_suspend(struct snd_card *card, pm_message_t state)
+{                                                                                                                            
+        return 0;
+}
+                                                                                                                             
+int ep93xx_ac97_do_resume(struct snd_card *card)
+{                                                                                                                     
+        return 0;
+}
+
+int ep93xx_ac97_resume(struct platform_device *_dev)
+{
+        struct snd_card *card = platform_get_drvdata(_dev);
+        int ret = 0;
+                                                                                                                             
+        if (card /*&& level == RESUME_ENABLE*/)
+                ret = ep93xx_ac97_do_resume(card);
+                                                                                                                             
+        return ret;
+}
+
+int ep93xx_ac97_suspend(struct platform_device *_dev, pm_message_t state)
+{
+        struct snd_card *card = platform_get_drvdata(_dev);
+        int ret = 0;
+                                                                                                                             
+        if (card /*&& level == SUSPEND_DISABLE*/)
+                ret = ep93xx_ac97_do_suspend(card, PMSG_SUSPEND);
+                                                                                                                             
+        return ret;
+}
+
+#endif
+
+
+
+/* module init & exit */
+static int ep93xx_ac97_probe(struct platform_device *dev)
+{
+    struct snd_card *card;
+    struct snd_ac97_bus *ac97_bus;
+    struct snd_ac97_template ac97_template;
+    int err = -ENOMEM;
+    struct resource *res = NULL;
+            
+    printk("snd_ep93xx_probe - enter\n");
+	
+    /* Enable audio early on, give the DAC time to come up. */ 
+    res = platform_get_resource( dev, IORESOURCE_MEM, 0);
+
+    if(!res) {
+	printk("error : platform_get_resource \n");
+        return -ENODEV;
+    }
+
+    if (!request_mem_region(res->start,res->end - res->start + 1, "snd-ac97-cs4202" )){
+    	printk("error : request_mem_region\n");
+        return -EBUSY;
+    }
+									    
+    /*enable ac97 codec*/
+    ep93xx_audio_init();
+			    
+    /* register the soundcard */
+    card = snd_card_new(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			    THIS_MODULE, 0);
+    if (!card){
+	printk("AC97: snd_card_new error\n");
+	goto error;
+    }
+    
+    card->dev = &dev->dev;
+    /*regist the new pcm device*/
+    err = snd_ep93xx_pcm_new(card, &audio_state, &ep93xx_ac97_pcm);
+    if (err){
+	printk("AC97: ep93xx_ac97_pcm_new error\n");
+	goto error;
+    }
+    if (card == NULL) {
+	DPRINTK(KERN_ERR "snd_card_new() failed\n");
+	goto error;
+    }
+
+    /*driver name*/
+    strcpy(card->driver, "CS4202A");
+    strcpy(card->shortname, "Cirrus Logic AC97 Audio ");
+    strcpy(card->longname, "Cirrus Logic AC97 Audio with CS4202A");
+
+    /*regist the new ac97 device*/
+    err = snd_ac97_bus(card, 0, &ep93xx_ac97_ops, NULL, &ac97_bus);
+    if (err){
+	printk("AC97: snd_ac97_bus error\n");
+	goto error;
+    }
+    
+    memset(&ac97_template, 0, sizeof(ac97_template));
+    err = snd_ac97_mixer(ac97_bus, &ac97_template, &ep93xx_ac97_ac97);
+    if (err){
+	printk("AC97: snd_ac97_mixer error\n");
+	goto error;
+    }
+   
+    /**/
+    ep93xx_audio_init();	 
+    /*setting the card device callback*/
+    //err = snd_card_set_pm_callback(card, ep93xx_ac97_do_suspend,ep93xx_ac97_do_resume, (void*)NULL);
+    //if(err != 0){
+    //	printk("snd_card_set_pm_callback error\n");
+    //}
+
+    /*regist the new CARD device*/
+    err = snd_card_register(card);
+    if (err == 0) {
+	printk( KERN_INFO "Cirrus Logic ep93xx ac97 audio initialized\n" );
+	platform_set_drvdata(dev,card);
+	DPRINTK("snd_ep93xx_probe - exit\n");
+    	return 0;
+    }
+
+error:
+    snd_card_free(card);
+    printk("snd_ep93xx_probe - error\n");
+    return err;
+
+return 0;
+}
+
+static int ep93xx_ac97_remove(struct platform_device *dev)
+{
+    struct resource *res;
+    struct snd_card *card = platform_get_drvdata(dev);
+
+    res = platform_get_resource( dev, IORESOURCE_MEM, 0);
+    release_mem_region(res->start, res->end - res->start + 1);
+	
+    DPRINTK("snd_ep93xx_ac97_remove - enter\n");
+    
+    if (card) {
+	snd_card_free(card);
+	platform_set_drvdata(dev, NULL);
+    }
+    DPRINTK("snd_ep93xx_remove - exit\n");
+
+return 0;
+}
+
+
+static struct platform_driver ep93xx_ac97_driver = {
+	.probe		= ep93xx_ac97_probe,
+	.remove		= ep93xx_ac97_remove,
+	.suspend	= ep93xx_ac97_suspend,
+	.resume		= ep93xx_ac97_resume,
+	.driver		= {
+		.name	= "ep93xx-ac97",
+	},
+};						
+						
+
+static int __init ep93xx_ac97_init(void)
+{
+    int ret;
+    
+    DPRINTK(KERN_INFO "%s: version %s\n", DRIVER_DESC, DRIVER_VERSION);
+    DPRINTK("snd_ep93xx_AC97_init - enter\n");	
+    ret = platform_driver_register(&ep93xx_ac97_driver);
+    DPRINTK("snd_ep93xx_AC97_init - exit\n");
+    return ret;										
+}
+
+static void __exit ep93xx_ac97_exit(void)
+{
+    DPRINTK("ep93xx_ac97_exit  - enter\n");
+    return platform_driver_unregister(&ep93xx_ac97_driver);
+}
+
+module_init(ep93xx_ac97_init);
+module_exit(ep93xx_ac97_exit);
+
+MODULE_DESCRIPTION("Cirrus Logic audio module");
+MODULE_LICENSE("GPL");
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/sound/arm/ep93xx-ac97.h linux-2.6.29.2.new/sound/arm/ep93xx-ac97.h
--- linux-2.6.29.2/sound/arm/ep93xx-ac97.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/sound/arm/ep93xx-ac97.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,89 @@
+/*
+ * linux/sound/arm/ep93xx-i2s.c -- ALSA PCM interface for the edb93xx i2s audio
+ *
+ * Author:      Fred Wei
+ * Created:     July 19, 2005
+ * Copyright:   Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define EP93XX_DEFAULT_NUM_CHANNELS     2
+#define EP93XX_DEFAULT_FORMAT           SNDRV_PCM_FORMAT_S16_LE
+#define EP93XX_DEFAULT_BIT_WIDTH        16
+#define MAX_DEVICE_NAME 		20
+
+/*
+ * Buffer Management
+ */
+				
+typedef struct {
+
+    unsigned char	*area;    	/* virtual pointer */
+    dma_addr_t 		dma_addr;       /* physical address */
+    size_t 		bytes;      
+    size_t 		reportedbytes;	/* buffer size */
+    int 		sent;		/* indicates that dma has the buf */
+    char		*start;		/* points to actual buffer */
+
+} audio_buf_t;
+
+
+typedef struct {
+
+    unsigned char	*area;  		/* virtual pointer */
+    dma_addr_t 		addr;        		/* physical address */
+    size_t 		bytes;          	/* buffer size in bytes */
+    unsigned char      	*buff_pos;              /* virtual pointer */
+    audio_buf_t        	*audio_buffers; 	/* array of audio buffer structures */
+    int 		audio_buff_count;
+		
+
+} audio_channel_t;
+
+typedef struct audio_stream_s {
+
+    /* dma stuff */
+    int			dmahandles[3];		/* handles for dma driver instances */
+    char		devicename[MAX_DEVICE_NAME]; /* string - name of device */
+    int			dma_num_channels;		/* 1, 2, or 3 DMA channels */
+    audio_channel_t	*dma_channels;
+    u_int 		nbfrags;		/* nbr of fragments i.e. buffers */
+    u_int		fragsize;		/* fragment i.e. buffer size */
+    u_int		dmasize;
+    int 		bytecount;		/* nbr of processed bytes */
+    int 		externedbytecount;	/* nbr of processed bytes */
+    volatile int        active;                 /* actually in progress                 */
+    volatile int        stopped;                /* might be active but stopped          */
+    char 		*hwbuf[3];
+    long		audio_rate;
+    long 		audio_num_channels;		/* Range: 1 to 6 */
+    int			audio_channels_flag;
+    long 		audio_format;
+    long 		audio_stream_bitwidth;		/* Range: 8, 16, 24 */
+    int			dma2usr_ratio;
+
+} audio_stream_t;
+
+
+/*
+ * State structure for one instance
+ */
+typedef struct {
+	    
+    audio_stream_t 	*output_stream;
+    audio_stream_t 	*input_stream;
+    ep93xx_dma_dev_t	output_dma[3];
+    ep93xx_dma_dev_t	input_dma[3];
+    char 		*output_id[3];
+    char 		*input_id[3];
+    struct              semaphore sem;          /* to protect against races in attach() */
+    int			codec_set_by_playback;
+    int                 codec_set_by_capture;
+    int                 DAC_bit_width;          /* 16, 20, 24 bits */
+    int                 bCompactMode;           /* set if 32bits = a stereo sample */
+	
+} audio_state_t;
+
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/sound/arm/ep93xx-i2s.c linux-2.6.29.2.new/sound/arm/ep93xx-i2s.c
--- linux-2.6.29.2/sound/arm/ep93xx-i2s.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/sound/arm/ep93xx-i2s.c	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,2978 @@
+/*
+ * linux/sound/arm/ep93xx-i2s.c -- ALSA PCM interface for the edb93xx i2s audio
+ */
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/semaphore.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>                                                                                                                             
+#include <mach/hardware.h>
+#include <mach/dma.h>
+#include <mach/regs_i2s.h>
+#include <mach/ssp.h>
+
+#include "ep93xx-i2s.h"
+
+
+//#define DEBUG 1
+#ifdef DEBUG
+#define DPRINTK( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DPRINTK( fmt, arg... )
+#endif
+
+#define WL16 	0
+#define WL24	1
+
+#define AUDIO_NAME              	"ep93xx-i2s"
+#define AUDIO_SAMPLE_RATE_DEFAULT       44100
+#define AUDIO_DEFAULT_VOLUME            0
+#define AUDIO_MAX_VOLUME	        181
+#define AUDIO_DEFAULT_DMACHANNELS       3
+#define PLAYBACK_DEFAULT_DMACHANNELS    3
+#define CAPTURE_DEFAULT_DMACHANNELS     3
+
+#define CHANNEL_FRONT			(1<<0)
+#define CHANNEL_REAR                   	(1<<1)
+#define CHANNEL_CENTER_LFE              (1<<2)
+
+#ifdef CONFIG_CODEC_CS4271
+static int 	mute = 0;
+#endif
+
+static int 	index = SNDRV_DEFAULT_IDX1;          /* Index 0-MAX */
+static char 	*id = SNDRV_DEFAULT_STR1;            /* ID for this card */
+static int 	SSP_Handle = -1;
+
+static void snd_ep93xx_dma_tx_callback( ep93xx_dma_int_t DMAInt,
+					ep93xx_dma_dev_t device,
+					unsigned int user_data);
+static void snd_ep93xx_dma_rx_callback( ep93xx_dma_int_t DMAInt,
+					ep93xx_dma_dev_t device,
+					unsigned int user_data);
+
+static const struct snd_pcm_hardware ep93xx_i2s_pcm_hardware = {
+
+
+    .info		= ( SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_PAUSE  ),
+    .formats		= ( SNDRV_PCM_FMTBIT_U8     | SNDRV_PCM_FMTBIT_S8     |
+			    SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+			    SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_S24_LE |
+			    SNDRV_PCM_FMTBIT_U24_BE | SNDRV_PCM_FMTBIT_S24_BE ),
+    .rates		= ( SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 |
+			    SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |
+			    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+			    SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000),
+    .rate_min		= 8000,
+    .rate_max		= 96000,
+    .channels_min	= 1,/*2,*/
+#ifdef CONFIG_CODEC_CS4271
+    .channels_max	= 2,
+#else//CONFIG_CODEC_CS4228A
+    .channels_max	= 6,
+#endif
+					
+    .period_bytes_min	= 1 * 1024,
+    .period_bytes_max	= 32 * 1024,
+    .periods_min	= 1,
+    .periods_max	= 32,
+    .buffer_bytes_max	= /*32*/128 * 1024,
+    .fifo_size		= 0,
+};
+
+static int ep93xx_calc_closest_freq
+(
+    ulong   ulPLLFreq, 
+    ulong   ulRequestedMClkFreq,
+    ulong * pulActualMClkFreq,
+    ulong * pulI2SDiv
+);
+
+static audio_stream_t output_stream;
+static audio_stream_t input_stream;
+								
+static audio_state_t audio_state =
+{
+    .output_stream          = &output_stream,
+    .output_dma[0]          = DMATx_I2S1,
+    .output_id[0]           = "I2S_OUT1",
+    .output_dma[1]          = DMATx_I2S2,
+    .output_id[1]           = "I2S_OUT2",
+    .output_dma[2]          = DMATx_I2S3,
+    .output_id[2]           = "I2S_OUT3",
+	       
+	       	       
+    .input_stream           = &input_stream,
+    .input_dma[0]           = DMARx_I2S1,
+    .input_id[0]            = "I2S_IN1",
+    .input_dma[1]           = DMARx_I2S2,
+    .input_id[1]            = "I2S_IN2",
+    .input_dma[2]           = DMARx_I2S3,
+    .input_id[2]            = "I2S_IN3",
+	
+    .sem                    = __SEMAPHORE_INITIALIZER(audio_state.sem,1),
+    .codec_set_by_playback  = 0,
+    .codec_set_by_capture   = 0,
+};			
+		
+static struct snd_pcm *ep93xx_i2s_pcm;
+
+typedef struct {
+    ulong   ulTotalDiv;
+    ulong   ulI2SDiv;
+} DIV_TABLE;
+
+static const DIV_TABLE I2SDivTable[] =
+{
+    {   6, SYSCON_I2SDIV_PDIV_2  | (  2 & SYSCON_I2SDIV_MDIV_MASK) },
+    {   8, SYSCON_I2SDIV_PDIV_2  | (  2 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  10, SYSCON_I2SDIV_PDIV_25 | (  2 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  12, SYSCON_I2SDIV_PDIV_3  | (  2 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  15, SYSCON_I2SDIV_PDIV_25 | (  3 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  16, SYSCON_I2SDIV_PDIV_2  | (  4 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  18, SYSCON_I2SDIV_PDIV_3  | (  3 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  20, SYSCON_I2SDIV_PDIV_25 | (  4 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  24, SYSCON_I2SDIV_PDIV_3  | (  4 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  25, SYSCON_I2SDIV_PDIV_25 | (  5 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  28, SYSCON_I2SDIV_PDIV_2  | (  7 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  30, SYSCON_I2SDIV_PDIV_3  | (  5 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  32, SYSCON_I2SDIV_PDIV_2  | (  8 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  35, SYSCON_I2SDIV_PDIV_25 | (  7 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  36, SYSCON_I2SDIV_PDIV_3  | (  6 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  40, SYSCON_I2SDIV_PDIV_25 | (  8 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  42, SYSCON_I2SDIV_PDIV_3  | (  7 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  44, SYSCON_I2SDIV_PDIV_2  | ( 11 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  45, SYSCON_I2SDIV_PDIV_25 | (  9 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  48, SYSCON_I2SDIV_PDIV_3  | (  8 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  50, SYSCON_I2SDIV_PDIV_25 | ( 10 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  52, SYSCON_I2SDIV_PDIV_2  | ( 13 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  54, SYSCON_I2SDIV_PDIV_3  | (  9 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  55, SYSCON_I2SDIV_PDIV_25 | ( 11 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  56, SYSCON_I2SDIV_PDIV_2  | ( 14 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  60, SYSCON_I2SDIV_PDIV_3  | ( 10 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  64, SYSCON_I2SDIV_PDIV_2  | ( 16 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  65, SYSCON_I2SDIV_PDIV_25 | ( 13 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  66, SYSCON_I2SDIV_PDIV_3  | ( 11 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  68, SYSCON_I2SDIV_PDIV_2  | ( 17 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  70, SYSCON_I2SDIV_PDIV_25 | ( 14 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  72, SYSCON_I2SDIV_PDIV_3  | ( 12 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  75, SYSCON_I2SDIV_PDIV_25 | ( 15 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  76, SYSCON_I2SDIV_PDIV_2  | ( 19 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  78, SYSCON_I2SDIV_PDIV_3  | ( 13 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  80, SYSCON_I2SDIV_PDIV_25 | ( 16 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  84, SYSCON_I2SDIV_PDIV_3  | ( 14 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  85, SYSCON_I2SDIV_PDIV_25 | ( 17 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  88, SYSCON_I2SDIV_PDIV_2  | ( 22 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  90, SYSCON_I2SDIV_PDIV_3  | ( 15 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  92, SYSCON_I2SDIV_PDIV_2  | ( 23 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  95, SYSCON_I2SDIV_PDIV_25 | ( 19 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  96, SYSCON_I2SDIV_PDIV_3  | ( 16 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 100, SYSCON_I2SDIV_PDIV_25 | ( 20 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 102, SYSCON_I2SDIV_PDIV_3  | ( 17 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 104, SYSCON_I2SDIV_PDIV_2  | ( 26 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 105, SYSCON_I2SDIV_PDIV_25 | ( 21 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 108, SYSCON_I2SDIV_PDIV_3  | ( 18 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 110, SYSCON_I2SDIV_PDIV_25 | ( 22 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 112, SYSCON_I2SDIV_PDIV_2  | ( 28 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 114, SYSCON_I2SDIV_PDIV_3  | ( 19 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 115, SYSCON_I2SDIV_PDIV_25 | ( 23 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 116, SYSCON_I2SDIV_PDIV_2  | ( 29 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 120, SYSCON_I2SDIV_PDIV_3  | ( 20 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 124, SYSCON_I2SDIV_PDIV_2  | ( 31 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 125, SYSCON_I2SDIV_PDIV_25 | ( 25 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 126, SYSCON_I2SDIV_PDIV_3  | ( 21 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 128, SYSCON_I2SDIV_PDIV_2  | ( 32 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 130, SYSCON_I2SDIV_PDIV_25 | ( 26 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 132, SYSCON_I2SDIV_PDIV_3  | ( 22 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 135, SYSCON_I2SDIV_PDIV_25 | ( 27 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 136, SYSCON_I2SDIV_PDIV_2  | ( 34 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 138, SYSCON_I2SDIV_PDIV_3  | ( 23 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 140, SYSCON_I2SDIV_PDIV_25 | ( 28 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 144, SYSCON_I2SDIV_PDIV_3  | ( 24 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 145, SYSCON_I2SDIV_PDIV_25 | ( 29 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 148, SYSCON_I2SDIV_PDIV_2  | ( 37 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 150, SYSCON_I2SDIV_PDIV_3  | ( 25 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 152, SYSCON_I2SDIV_PDIV_2  | ( 38 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 155, SYSCON_I2SDIV_PDIV_25 | ( 31 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 156, SYSCON_I2SDIV_PDIV_3  | ( 26 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 160, SYSCON_I2SDIV_PDIV_25 | ( 32 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 162, SYSCON_I2SDIV_PDIV_3  | ( 27 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 164, SYSCON_I2SDIV_PDIV_2  | ( 41 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 165, SYSCON_I2SDIV_PDIV_25 | ( 33 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 168, SYSCON_I2SDIV_PDIV_3  | ( 28 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 170, SYSCON_I2SDIV_PDIV_25 | ( 34 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 172, SYSCON_I2SDIV_PDIV_2  | ( 43 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 174, SYSCON_I2SDIV_PDIV_3  | ( 29 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 175, SYSCON_I2SDIV_PDIV_25 | ( 35 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 176, SYSCON_I2SDIV_PDIV_2  | ( 44 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 180, SYSCON_I2SDIV_PDIV_3  | ( 30 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 184, SYSCON_I2SDIV_PDIV_2  | ( 46 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 185, SYSCON_I2SDIV_PDIV_25 | ( 37 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 186, SYSCON_I2SDIV_PDIV_3  | ( 31 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 188, SYSCON_I2SDIV_PDIV_2  | ( 47 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 190, SYSCON_I2SDIV_PDIV_25 | ( 38 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 192, SYSCON_I2SDIV_PDIV_3  | ( 32 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 195, SYSCON_I2SDIV_PDIV_25 | ( 39 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 196, SYSCON_I2SDIV_PDIV_2  | ( 49 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 198, SYSCON_I2SDIV_PDIV_3  | ( 33 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 200, SYSCON_I2SDIV_PDIV_25 | ( 40 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 204, SYSCON_I2SDIV_PDIV_3  | ( 34 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 205, SYSCON_I2SDIV_PDIV_25 | ( 41 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 208, SYSCON_I2SDIV_PDIV_2  | ( 52 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 210, SYSCON_I2SDIV_PDIV_3  | ( 35 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 212, SYSCON_I2SDIV_PDIV_2  | ( 53 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 215, SYSCON_I2SDIV_PDIV_25 | ( 43 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 216, SYSCON_I2SDIV_PDIV_3  | ( 36 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 220, SYSCON_I2SDIV_PDIV_25 | ( 44 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 222, SYSCON_I2SDIV_PDIV_3  | ( 37 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 224, SYSCON_I2SDIV_PDIV_2  | ( 56 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 225, SYSCON_I2SDIV_PDIV_25 | ( 45 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 228, SYSCON_I2SDIV_PDIV_3  | ( 38 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 230, SYSCON_I2SDIV_PDIV_25 | ( 46 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 232, SYSCON_I2SDIV_PDIV_2  | ( 58 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 234, SYSCON_I2SDIV_PDIV_3  | ( 39 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 235, SYSCON_I2SDIV_PDIV_25 | ( 47 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 236, SYSCON_I2SDIV_PDIV_2  | ( 59 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 240, SYSCON_I2SDIV_PDIV_3  | ( 40 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 244, SYSCON_I2SDIV_PDIV_2  | ( 61 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 245, SYSCON_I2SDIV_PDIV_25 | ( 49 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 246, SYSCON_I2SDIV_PDIV_3  | ( 41 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 248, SYSCON_I2SDIV_PDIV_2  | ( 62 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 250, SYSCON_I2SDIV_PDIV_25 | ( 50 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 252, SYSCON_I2SDIV_PDIV_3  | ( 42 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 255, SYSCON_I2SDIV_PDIV_25 | ( 51 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 256, SYSCON_I2SDIV_PDIV_2  | ( 64 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 258, SYSCON_I2SDIV_PDIV_3  | ( 43 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 260, SYSCON_I2SDIV_PDIV_25 | ( 52 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 264, SYSCON_I2SDIV_PDIV_3  | ( 44 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 265, SYSCON_I2SDIV_PDIV_25 | ( 53 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 268, SYSCON_I2SDIV_PDIV_2  | ( 67 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 270, SYSCON_I2SDIV_PDIV_3  | ( 45 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 272, SYSCON_I2SDIV_PDIV_2  | ( 68 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 275, SYSCON_I2SDIV_PDIV_25 | ( 55 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 276, SYSCON_I2SDIV_PDIV_3  | ( 46 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 280, SYSCON_I2SDIV_PDIV_25 | ( 56 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 282, SYSCON_I2SDIV_PDIV_3  | ( 47 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 284, SYSCON_I2SDIV_PDIV_2  | ( 71 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 285, SYSCON_I2SDIV_PDIV_25 | ( 57 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 288, SYSCON_I2SDIV_PDIV_3  | ( 48 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 290, SYSCON_I2SDIV_PDIV_25 | ( 58 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 292, SYSCON_I2SDIV_PDIV_2  | ( 73 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 294, SYSCON_I2SDIV_PDIV_3  | ( 49 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 295, SYSCON_I2SDIV_PDIV_25 | ( 59 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 296, SYSCON_I2SDIV_PDIV_2  | ( 74 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 300, SYSCON_I2SDIV_PDIV_3  | ( 50 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 304, SYSCON_I2SDIV_PDIV_2  | ( 76 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 305, SYSCON_I2SDIV_PDIV_25 | ( 61 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 306, SYSCON_I2SDIV_PDIV_3  | ( 51 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 308, SYSCON_I2SDIV_PDIV_2  | ( 77 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 310, SYSCON_I2SDIV_PDIV_25 | ( 62 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 312, SYSCON_I2SDIV_PDIV_3  | ( 52 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 315, SYSCON_I2SDIV_PDIV_25 | ( 63 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 316, SYSCON_I2SDIV_PDIV_2  | ( 79 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 318, SYSCON_I2SDIV_PDIV_3  | ( 53 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 320, SYSCON_I2SDIV_PDIV_25 | ( 64 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 324, SYSCON_I2SDIV_PDIV_3  | ( 54 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 325, SYSCON_I2SDIV_PDIV_25 | ( 65 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 328, SYSCON_I2SDIV_PDIV_2  | ( 82 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 330, SYSCON_I2SDIV_PDIV_3  | ( 55 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 332, SYSCON_I2SDIV_PDIV_2  | ( 83 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 335, SYSCON_I2SDIV_PDIV_25 | ( 67 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 336, SYSCON_I2SDIV_PDIV_3  | ( 56 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 340, SYSCON_I2SDIV_PDIV_25 | ( 68 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 342, SYSCON_I2SDIV_PDIV_3  | ( 57 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 344, SYSCON_I2SDIV_PDIV_2  | ( 86 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 345, SYSCON_I2SDIV_PDIV_25 | ( 69 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 348, SYSCON_I2SDIV_PDIV_3  | ( 58 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 350, SYSCON_I2SDIV_PDIV_25 | ( 70 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 352, SYSCON_I2SDIV_PDIV_2  | ( 88 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 354, SYSCON_I2SDIV_PDIV_3  | ( 59 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 355, SYSCON_I2SDIV_PDIV_25 | ( 71 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 356, SYSCON_I2SDIV_PDIV_2  | ( 89 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 360, SYSCON_I2SDIV_PDIV_3  | ( 60 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 364, SYSCON_I2SDIV_PDIV_2  | ( 91 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 365, SYSCON_I2SDIV_PDIV_25 | ( 73 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 366, SYSCON_I2SDIV_PDIV_3  | ( 61 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 368, SYSCON_I2SDIV_PDIV_2  | ( 92 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 370, SYSCON_I2SDIV_PDIV_25 | ( 74 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 372, SYSCON_I2SDIV_PDIV_3  | ( 62 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 375, SYSCON_I2SDIV_PDIV_25 | ( 75 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 376, SYSCON_I2SDIV_PDIV_2  | ( 94 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 378, SYSCON_I2SDIV_PDIV_3  | ( 63 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 380, SYSCON_I2SDIV_PDIV_25 | ( 76 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 384, SYSCON_I2SDIV_PDIV_3  | ( 64 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 385, SYSCON_I2SDIV_PDIV_25 | ( 77 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 388, SYSCON_I2SDIV_PDIV_2  | ( 97 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 390, SYSCON_I2SDIV_PDIV_3  | ( 65 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 392, SYSCON_I2SDIV_PDIV_2  | ( 98 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 395, SYSCON_I2SDIV_PDIV_25 | ( 79 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 396, SYSCON_I2SDIV_PDIV_3  | ( 66 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 400, SYSCON_I2SDIV_PDIV_25 | ( 80 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 402, SYSCON_I2SDIV_PDIV_3  | ( 67 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 404, SYSCON_I2SDIV_PDIV_2  | (101 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 405, SYSCON_I2SDIV_PDIV_25 | ( 81 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 408, SYSCON_I2SDIV_PDIV_3  | ( 68 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 410, SYSCON_I2SDIV_PDIV_25 | ( 82 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 412, SYSCON_I2SDIV_PDIV_2  | (103 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 414, SYSCON_I2SDIV_PDIV_3  | ( 69 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 415, SYSCON_I2SDIV_PDIV_25 | ( 83 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 416, SYSCON_I2SDIV_PDIV_2  | (104 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 420, SYSCON_I2SDIV_PDIV_3  | ( 70 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 424, SYSCON_I2SDIV_PDIV_2  | (106 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 425, SYSCON_I2SDIV_PDIV_25 | ( 85 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 426, SYSCON_I2SDIV_PDIV_3  | ( 71 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 428, SYSCON_I2SDIV_PDIV_2  | (107 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 430, SYSCON_I2SDIV_PDIV_25 | ( 86 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 432, SYSCON_I2SDIV_PDIV_3  | ( 72 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 435, SYSCON_I2SDIV_PDIV_25 | ( 87 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 436, SYSCON_I2SDIV_PDIV_2  | (109 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 438, SYSCON_I2SDIV_PDIV_3  | ( 73 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 440, SYSCON_I2SDIV_PDIV_25 | ( 88 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 444, SYSCON_I2SDIV_PDIV_3  | ( 74 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 445, SYSCON_I2SDIV_PDIV_25 | ( 89 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 448, SYSCON_I2SDIV_PDIV_2  | (112 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 450, SYSCON_I2SDIV_PDIV_3  | ( 75 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 452, SYSCON_I2SDIV_PDIV_2  | (113 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 455, SYSCON_I2SDIV_PDIV_25 | ( 91 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 456, SYSCON_I2SDIV_PDIV_3  | ( 76 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 460, SYSCON_I2SDIV_PDIV_25 | ( 92 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 462, SYSCON_I2SDIV_PDIV_3  | ( 77 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 464, SYSCON_I2SDIV_PDIV_2  | (116 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 465, SYSCON_I2SDIV_PDIV_25 | ( 93 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 468, SYSCON_I2SDIV_PDIV_3  | ( 78 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 470, SYSCON_I2SDIV_PDIV_25 | ( 94 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 472, SYSCON_I2SDIV_PDIV_2  | (118 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 474, SYSCON_I2SDIV_PDIV_3  | ( 79 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 475, SYSCON_I2SDIV_PDIV_25 | ( 95 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 476, SYSCON_I2SDIV_PDIV_2  | (119 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 480, SYSCON_I2SDIV_PDIV_3  | ( 80 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 484, SYSCON_I2SDIV_PDIV_2  | (121 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 485, SYSCON_I2SDIV_PDIV_25 | ( 97 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 486, SYSCON_I2SDIV_PDIV_3  | ( 81 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 488, SYSCON_I2SDIV_PDIV_2  | (122 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 490, SYSCON_I2SDIV_PDIV_25 | ( 98 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 492, SYSCON_I2SDIV_PDIV_3  | ( 82 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 495, SYSCON_I2SDIV_PDIV_25 | ( 99 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 496, SYSCON_I2SDIV_PDIV_2  | (124 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 498, SYSCON_I2SDIV_PDIV_3  | ( 83 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 500, SYSCON_I2SDIV_PDIV_25 | (100 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 504, SYSCON_I2SDIV_PDIV_3  | ( 84 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 505, SYSCON_I2SDIV_PDIV_25 | (101 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 508, SYSCON_I2SDIV_PDIV_2  | (127 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 510, SYSCON_I2SDIV_PDIV_3  | ( 85 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 515, SYSCON_I2SDIV_PDIV_25 | (103 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 516, SYSCON_I2SDIV_PDIV_3  | ( 86 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 520, SYSCON_I2SDIV_PDIV_25 | (104 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 522, SYSCON_I2SDIV_PDIV_3  | ( 87 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 525, SYSCON_I2SDIV_PDIV_25 | (105 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 528, SYSCON_I2SDIV_PDIV_3  | ( 88 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 530, SYSCON_I2SDIV_PDIV_25 | (106 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 534, SYSCON_I2SDIV_PDIV_3  | ( 89 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 535, SYSCON_I2SDIV_PDIV_25 | (107 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 540, SYSCON_I2SDIV_PDIV_3  | ( 90 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 545, SYSCON_I2SDIV_PDIV_25 | (109 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 546, SYSCON_I2SDIV_PDIV_3  | ( 91 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 550, SYSCON_I2SDIV_PDIV_25 | (110 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 552, SYSCON_I2SDIV_PDIV_3  | ( 92 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 555, SYSCON_I2SDIV_PDIV_25 | (111 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 558, SYSCON_I2SDIV_PDIV_3  | ( 93 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 560, SYSCON_I2SDIV_PDIV_25 | (112 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 564, SYSCON_I2SDIV_PDIV_3  | ( 94 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 565, SYSCON_I2SDIV_PDIV_25 | (113 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 570, SYSCON_I2SDIV_PDIV_3  | ( 95 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 575, SYSCON_I2SDIV_PDIV_25 | (115 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 576, SYSCON_I2SDIV_PDIV_3  | ( 96 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 580, SYSCON_I2SDIV_PDIV_25 | (116 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 582, SYSCON_I2SDIV_PDIV_3  | ( 97 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 585, SYSCON_I2SDIV_PDIV_25 | (117 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 588, SYSCON_I2SDIV_PDIV_3  | ( 98 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 590, SYSCON_I2SDIV_PDIV_25 | (118 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 594, SYSCON_I2SDIV_PDIV_3  | ( 99 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 595, SYSCON_I2SDIV_PDIV_25 | (119 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 600, SYSCON_I2SDIV_PDIV_3  | (100 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 605, SYSCON_I2SDIV_PDIV_25 | (121 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 606, SYSCON_I2SDIV_PDIV_3  | (101 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 610, SYSCON_I2SDIV_PDIV_25 | (122 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 612, SYSCON_I2SDIV_PDIV_3  | (102 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 615, SYSCON_I2SDIV_PDIV_25 | (123 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 618, SYSCON_I2SDIV_PDIV_3  | (103 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 620, SYSCON_I2SDIV_PDIV_25 | (124 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 624, SYSCON_I2SDIV_PDIV_3  | (104 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 625, SYSCON_I2SDIV_PDIV_25 | (125 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 630, SYSCON_I2SDIV_PDIV_3  | (105 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 635, SYSCON_I2SDIV_PDIV_25 | (127 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 636, SYSCON_I2SDIV_PDIV_3  | (106 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 642, SYSCON_I2SDIV_PDIV_3  | (107 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 648, SYSCON_I2SDIV_PDIV_3  | (108 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 654, SYSCON_I2SDIV_PDIV_3  | (109 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 660, SYSCON_I2SDIV_PDIV_3  | (110 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 666, SYSCON_I2SDIV_PDIV_3  | (111 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 672, SYSCON_I2SDIV_PDIV_3  | (112 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 678, SYSCON_I2SDIV_PDIV_3  | (113 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 684, SYSCON_I2SDIV_PDIV_3  | (114 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 690, SYSCON_I2SDIV_PDIV_3  | (115 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 696, SYSCON_I2SDIV_PDIV_3  | (116 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 702, SYSCON_I2SDIV_PDIV_3  | (117 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 708, SYSCON_I2SDIV_PDIV_3  | (118 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 714, SYSCON_I2SDIV_PDIV_3  | (119 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 720, SYSCON_I2SDIV_PDIV_3  | (120 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 726, SYSCON_I2SDIV_PDIV_3  | (121 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 732, SYSCON_I2SDIV_PDIV_3  | (122 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 738, SYSCON_I2SDIV_PDIV_3  | (123 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 744, SYSCON_I2SDIV_PDIV_3  | (124 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 750, SYSCON_I2SDIV_PDIV_3  | (125 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 756, SYSCON_I2SDIV_PDIV_3  | (126 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 762, SYSCON_I2SDIV_PDIV_3  | (127 & SYSCON_I2SDIV_MDIV_MASK) }
+};
+
+/*
+ * When we get to the multichannel case the pre-fill and enable code
+ * will go to the dma driver's start routine.
+ */
+static void snd_ep93xx_i2s_enable_transmit(void){
+    
+    int i;
+    unsigned long ulTemp;
+    
+    outl( 0, I2STX0En );
+    outl( 0, I2STX1En );
+    outl( 0, I2STX2En );
+    ulTemp = inl( I2STX2En ); /* input to push the outl's past the wrapper */
+    
+    for( i = 0 ; i < 8 ; i++ ){
+	outl( 0, I2STX0Lft );
+	outl( 0, I2STX0Rt );
+	outl( 0, I2STX1Lft );
+	outl( 0, I2STX1Rt );
+	outl( 0, I2STX2Lft );
+	outl( 0, I2STX2Rt );
+	ulTemp = inl( I2SRX2En ); /* input to push the outl's past the wrapper */
+    }
+    outl( 1, I2STX0En );
+    outl( 1, I2STX1En );
+    outl( 1, I2STX2En );
+    ulTemp = inl( I2STX2En ); /* input to push the outl's past the wrapper */
+}
+
+static void snd_ep93xx_i2s_disable_transmit( void )
+{
+    unsigned long ulTemp;
+         
+    outl( 0, I2STX0En );
+    outl( 0, I2STX1En );
+    outl( 0, I2STX2En );
+    ulTemp = inl( I2SRX2En ); /* input to push the outl's past the wrapper */
+    					
+}
+					    
+ 
+static void snd_ep93xx_i2s_enable_receive(void)
+{
+    unsigned long ulTemp;
+	
+    outl( 1, I2SRX0En );
+    outl( 1, I2SRX1En );
+    outl( 1, I2SRX2En );
+    ulTemp = inl( I2SRX2En );
+
+}
+
+static void snd_ep93xx_i2s_disable_receive( void )
+{
+    unsigned long ulTemp;
+
+    outl( 0, I2SRX0En );
+    outl( 0, I2SRX1En );
+    outl( 0, I2SRX2En );
+    ulTemp = inl( I2SRX2En );
+}
+
+static void snd_ep93xx_i2s_enable( void )
+{
+    unsigned long ulTemp;
+        
+    outl(1, I2SGlCtrl );
+    ulTemp = inl( I2SGlCtrl );
+}
+
+static void snd_ep93xx_i2s_disable( void )
+{
+    unsigned long ulTemp;
+    
+    outl(0, I2SGlCtrl );
+    ulTemp = inl( I2SGlCtrl );
+}
+
+
+/*
+ * ep93xx_calc_closest_freq
+ * 
+ *   Return            0 - Failure
+ *                     1 - Success
+ */
+static int ep93xx_calc_closest_freq
+(
+    ulong   ulPLLFreq, 
+    ulong   ulRequestedMClkFreq,
+    ulong * pulActualMClkFreq,
+    ulong * pulI2SDiv
+)
+{
+    ulong   ulLower;
+    ulong   ulUpper;
+    ulong   ulDiv;
+    int     x;
+    
+    /* Calculate the closest divisor. */
+    ulDiv =  (ulPLLFreq * 2)/ ulRequestedMClkFreq;
+
+    for(x = 1; x < sizeof(I2SDivTable)/sizeof(DIV_TABLE); x++){
+
+	/* Calculate the next greater and lower value. */
+	ulLower = I2SDivTable[x - 1].ulTotalDiv;     
+	ulUpper = I2SDivTable[x].ulTotalDiv;     
+
+	/* Check to see if it is in between the two values. */
+	if(ulLower <= ulDiv && ulDiv < ulUpper)
+	    break;
+    }
+
+    /* Return if we did not find a divisor. */
+    if(x == sizeof(I2SDivTable)/sizeof(DIV_TABLE)){
+	
+	DPRINTK("ep93xx_i2s couldn't find a divisor.\n");
+
+	*pulActualMClkFreq  = 0;
+	*pulI2SDiv          = 0;
+	return -1;
+    }
+
+    /* See which is closer, the upper or the lower case. */
+    if(ulUpper * ulRequestedMClkFreq - ulPLLFreq * 2 >  
+		ulPLLFreq * 2 - ulLower * ulRequestedMClkFreq){
+	x-=1;
+    }
+
+    *pulActualMClkFreq  = (ulPLLFreq * 2)/ I2SDivTable[x].ulTotalDiv;
+    *pulI2SDiv          = I2SDivTable[x].ulI2SDiv;
+
+    return 0;
+}
+
+/*
+ * ep93xx_get_PLL_frequency
+ *
+ * Given a value for ClkSet1 or ClkSet2, calculate the PLL1 or PLL2 frequency.
+ */
+static ulong ep93xx_get_PLL_frequency( ulong ulCLKSET )
+{
+    ulong ulX1FBD, ulX2FBD, ulX2IPD, ulPS, ulPLL_Freq;
+
+    ulPS = (ulCLKSET & SYSCON_CLKSET1_PLL1_PS_MASK) >> SYSCON_CLKSET1_PLL1_PS_SHIFT;
+    ulX1FBD = (ulCLKSET & SYSCON_CLKSET1_PLL1_X1FBD1_MASK) >> SYSCON_CLKSET1_PLL1_X1FBD1_SHIFT;
+    ulX2FBD = (ulCLKSET & SYSCON_CLKSET1_PLL1_X2FBD2_MASK) >> SYSCON_CLKSET1_PLL1_X2FBD2_SHIFT;
+    ulX2IPD = (ulCLKSET & SYSCON_CLKSET1_PLL1_X2IPD_MASK) >> SYSCON_CLKSET1_PLL1_X2IPD_SHIFT;
+                                                                                                                             
+    ulPLL_Freq = (((0x00e10000 * (ulX1FBD+1)) / (ulX2IPD+1)) * (ulX2FBD+1)) >> ulPS;
+    return ulPLL_Freq;
+}
+
+/*
+ * SetSampleRate
+ * disables i2s channels and sets up i2s divisors
+ * in syscon for the requested sample rate.
+  * lFrequency - Sample Rate in Hz
+ */
+static void ep93xx_set_samplerate(long lFrequency)
+{
+    ulong ulRequestedMClkFreq, ulPLL1_CLOCK, ulPLL2_CLOCK;
+    ulong ulMClkFreq1, ulMClkFreq2, ulClkSet1, ulClkSet2;
+    ulong ulI2SDiv, ulI2SDiv1, ulI2SDiv2, ulI2SDIV, actual_samplerate;
+    
+    /* Clock ratios: MCLK to SCLK and SCLK to LRCK */
+    ulong ulM2SClock  = 4;
+    ulong ulS2LRClock = 64;
+
+    DPRINTK( "ep93xx_set_samplerate = %d Hz.\n", (int)lFrequency );
+    /*
+     * Read CLKSET1 and CLKSET2 in the System Controller and calculate
+     * the PLL frequencies from that.
+     */
+    ulClkSet1 =	inl(SYSCON_CLKSET1);
+    ulClkSet2 =	inl(SYSCON_CLKSET2);
+    ulPLL1_CLOCK = ep93xx_get_PLL_frequency( ulClkSet1 );
+    ulPLL2_CLOCK = ep93xx_get_PLL_frequency( ulClkSet2 );
+
+    DPRINTK( "ep93xx_i2s_ClkSet1=0x%08x Clkset2=0x%08x  PLL1=%d Hz  PLL2=%d Hz\n", 
+    	(int)ulClkSet1, (int)ulClkSet2, (int)ulPLL1_CLOCK, (int)ulPLL2_CLOCK );
+
+    ulRequestedMClkFreq = ( lFrequency * ulM2SClock * ulS2LRClock);
+
+    ep93xx_calc_closest_freq
+    (
+    	ulPLL1_CLOCK, 
+    	ulRequestedMClkFreq,
+	&ulMClkFreq1,
+	&ulI2SDiv1
+    );
+    ep93xx_calc_closest_freq
+    (
+    	ulPLL2_CLOCK, 
+    	ulRequestedMClkFreq,
+	&ulMClkFreq2,
+	&ulI2SDiv2
+    );
+
+    /* See which is closer, MClk rate 1 or MClk rate 2. */
+    if(abs(ulMClkFreq1 - ulRequestedMClkFreq) < abs(ulMClkFreq2 -ulRequestedMClkFreq)){
+	ulI2SDiv = ulI2SDiv1;
+	actual_samplerate = ulMClkFreq1/ (ulM2SClock * ulS2LRClock);
+	DPRINTK( "ep93xx_set_samplerate - using PLL1\n" );
+    }
+    else{
+	ulI2SDiv = ulI2SDiv2 | SYSCON_I2SDIV_PSEL;
+	actual_samplerate = ulMClkFreq1 / (ulM2SClock * ulS2LRClock);
+	DPRINTK( "ep93xx_set_samplerate - using PLL2\n" );
+    }
+        
+    /* Calculate the new I2SDIV register value and write it out. */
+    ulI2SDIV = ulI2SDiv | SYSCON_I2SDIV_SENA |  SYSCON_I2SDIV_ORIDE |
+	    SYSCON_I2SDIV_SPOL| SYSCON_I2SDIV_LRDIV_64 |
+	    SYSCON_I2SDIV_SDIV | SYSCON_I2SDIV_MENA | SYSCON_I2SDIV_ESEL;
+
+DPRINTK("I2SDIV set to 0x%08x\n", (unsigned int)ulI2SDIV );									
+    SysconSetLocked(SYSCON_I2SDIV, ulI2SDIV);
+DPRINTK("I2SDIV set to 0x%08x\n", inl(SYSCON_I2SDIV));
+}
+
+/*
+ * BringUpI2S
+ * This routine sets up the I2S Controller.
+ */
+static void snd_ep93xx_i2s_init( char wordlenght )
+{
+    unsigned int uiDEVCFG;
+
+    DPRINTK("snd_ep93xx_i2s_init - enter\n");
+
+    if(wordlenght)
+	DPRINTK("i2s_controller set to 24bit lenght\n");
+    else
+        DPRINTK("i2s_controller set to 16bit lenght\n");
+			
+    /*
+     * Configure 
+     * EGPIO[4,5,6,13] to be SDIN's and SDOUT's for the second and third
+     * I2S stereo channels if the codec is a 6 channel codec.
+     */
+    uiDEVCFG = inl(SYSCON_DEVCFG/*EP93XX_SYSCON_DEVICE_CONFIG*/);
+ DPRINTK("snd_ep93xx_i2s_init =%x - 0\n",uiDEVCFG);
+#ifdef CONFIG_CODEC_CS4271
+    uiDEVCFG |= SYSCON_DEVCFG_I2SonAC97;
+ DPRINTK("snd_ep93xx_i2s_init =%x- 0 0\n",uiDEVCFG);
+#else /* CONFIG_CODEC_CS4228A */
+    uiDEVCFG |= SYSCON_DEVCFG_I2SonAC97 | SYSCON_DEVCFG_A1onG | SYSCON_DEVCFG_A2onG;
+#endif
+ DPRINTK("snd_ep93xx_i2s_init - 0 1\n");
+    SysconSetLocked(SYSCON_DEVCFG/*EP93XX_SYSCON_DEVICE_CONFIG*/, uiDEVCFG);
+
+uiDEVCFG = inl(SYSCON_DEVCFG/*EP93XX_SYSCON_DEVICE_CONFIG*/);
+ DPRINTK("snd_ep93xx_i2s_init=%x - 1\n",uiDEVCFG);
+    /* Configure I2S Tx channel */
+    /* Justify Left, MSB first */
+    outl( 0, I2STXLinCtrlData );
+	
+    /* WL = 24 bits */
+    outl( wordlenght, I2STXWrdLen );
+
+    /*
+     * Set the I2S control block to master mode.
+     * Tx bit clk rate determined by word legnth 
+     * Do gate off last 8 clks (24 bit samples in a 32 bit field)
+     * LRclk = I2S timing; LRck = 0 for left
+     */
+		 
+    outl( ( i2s_txcc_mstr | i2s_txcc_trel), I2STxClkCfg );
+    /* Configure I2S rx channel */
+    /* First, clear all config bits. */
+    outl( 0, I2SRXLinCtrlData );
+    outl( wordlenght, I2SRXWrdLen );
+
+    /* 
+     * Set the I2S control block to master mode.
+     * Rx bit clk rate determined by word legnth 
+     * Do gate off last 8 clks 
+     * setting i2s_rxcc_rrel gives us I2S timing
+     * clearing i2s_rlrs gives us LRck = 0 for left, 1 for right
+     * setting i2s_rxcc_nbcg specifies to not gate off extra 8 clocks 
+     */
+    outl( (i2s_rxcc_bcr_64x | i2s_rxcc_nbcg |i2s_rxcc_mstr | i2s_rxcc_rrel), I2SRxClkCfg );
+	
+    /* Do an input to push the outl's past the wrapper */
+    uiDEVCFG = inl(SYSCON_DEVCFG/*EP93XX_SYSCON_DEVICE_CONFIG*/);
+    
+    DPRINTK("snd_ep93xx_i2s_init =%x- EXIT\n",uiDEVCFG);
+}
+
+/*
+ * ep93xx_init_i2s_codec
+ *
+ * Note that codec must be getting i2s clocks for any codec
+ * register writes to work.
+ */
+static void snd_ep93xx_codec_init( void )
+{
+
+#if defined(CONFIG_MACH_EDB9301) || defined(CONFIG_MACH_EDB9302)
+	unsigned int uiPADR, uiPADDR;
+#endif
+
+#if defined(CONFIG_MACH_EDB9315A)
+	unsigned int uiPBDR, uiPBDDR;
+#endif
+
+#if defined(CONFIG_MACH_EDB9307A) || defined(CONFIG_MACH_EDB9302A)
+	unsigned int uiPHDR, uiPHDDR, uiDEVCFG;;
+#endif
+
+
+#ifdef CONFIG_CODEC_CS4271
+	/*
+	 * Some EDB9301 boards use EGPIO1 (port 1, bit 1) for the I2S reset.
+	 * EGPIO1 has a pulldown so if it isn't configured as an output, it is low.
+	 */
+#if defined(CONFIG_MACH_EDB9301) || defined(CONFIG_MACH_EDB9302)
+	uiPADR  = inl(GPIO_PADR);
+	uiPADDR = inl(GPIO_PADDR);
+   	DPRINTK("%s 01 02\n",__FUNCTION__); 
+	/* Clear bit 1 of the data register */
+	outl( (uiPADR & 0xfd), GPIO_PADR );
+	uiPADR  = inl(GPIO_PADR);
+
+	/* Set bit 1 of the DDR to set it to output
+	 * Now we are driving the reset pin low.
+	 */
+	outl( (uiPADDR | 0x02), GPIO_PADDR );
+	uiPADDR = inl(GPIO_PADDR);
+
+	udelay( 2 );  /* plenty of time */
+
+	/* Set bit 1 of the data reg.  Now we drive the reset pin high. */
+	outl( (uiPADR | 0x02),  GPIO_PADR );
+	uiPADR  = inl(GPIO_PADR);
+#endif
+
+#if defined(CONFIG_MACH_EDB9315A)
+        DPRINTK("%s EDB15A\n",__FUNCTION__);
+	//outl( 0xa3, GPIO_PBDR );
+	//outl( 0,GPIO_PBDDR);
+	uiPBDR  = inl(GPIO_PBDR);
+	uiPBDDR = inl(GPIO_PBDDR);
+   	DPRINTK("uiPBDR=%x,uiPBDDR=%x\n",uiPBDR,uiPBDDR); 
+	/* Clear bit 1 of the data register */
+	outl( (uiPBDR & 0xbf), GPIO_PBDR );
+	uiPBDR  = inl(GPIO_PBDR);
+
+	/* Set bit 1 of the DDR to set it to output
+	 * Now we are driving the reset pin low.
+	 */
+	outl( (uiPBDDR | 0x40), GPIO_PBDDR );
+	uiPBDDR = inl(GPIO_PBDDR);
+
+        //uiPBDR  = inl(GPIO_PBDR);
+        //uiPBDDR = inl(GPIO_PBDDR);
+	//DPRINTK("uiPBDR=%x,uiPBDDR=%x\n",uiPBDR,uiPBDDR);
+	udelay( 2 );  /* plenty of time */
+
+	/* Set bit 1 of the data reg.  Now we drive the reset pin high. */
+	outl( (uiPBDR | 0x40),  GPIO_PBDR );
+	uiPBDR  = inl(GPIO_PBDR);
+
+        //uiPBDR  = inl(GPIO_PBDR);
+        //uiPBDDR = inl(GPIO_PBDDR);
+	//DPRINTK("uiPBDR=%x,uiPBDDR=%x\n",uiPBDR,uiPBDDR);
+#endif
+
+#if defined(CONFIG_MACH_EDB9307A) || defined(CONFIG_MACH_EDB9302A)
+    
+	/* Setup bit 11 in DEV_CONFIG for Port HonIDE to do GPIO */
+	uiDEVCFG = inl(SYSCON_DEVCFG);
+	uiDEVCFG |= SYSCON_DEVCFG_HonIDE;
+	
+	/* Unlock SYSCON_DEVCFG */
+	SysconSetLocked(SYSCON_DEVCFG, uiDEVCFG);
+	
+	uiPHDR  = inl(GPIO_PHDR);
+	uiPHDDR = inl(GPIO_PHDDR);
+    
+	/* Clear bit 3 of the data register */
+	outl( (uiPHDR & 0xfb), GPIO_PHDR );
+	uiPHDR  = inl(GPIO_PHDR);
+
+	/* Set bit 3 of the DDR to set it to output
+	 * Now we are driving the reset pin low.
+	 */
+	outl( (uiPHDDR | 0x04), GPIO_PHDDR );
+	uiPHDDR = inl(GPIO_PHDDR);
+
+	udelay( 2 );  /* plenty of time */
+
+	/* Set bit 3 of the data reg.  Now we drive the reset pin high. */
+	outl( (uiPHDR | 0x04),  GPIO_PHDR );
+	uiPHDR  = inl(GPIO_PHDR);
+#endif
+	/*
+	 * Write to the control port, setting the enable control port bit
+	 * so that we can write to the control port.  OK?
+	 */
+	SSPDriver->Write( SSP_Handle, 7, 0x02 );
+
+	/* Select slave, 24Bit I2S serial mode */
+	SSPDriver->Write( SSP_Handle, 1, 0x01 );
+
+	SSPDriver->Write( SSP_Handle, 6, 0x10 );
+
+	/* Set AMUTE (auto-mute) bit. */
+	SSPDriver->Write( SSP_Handle, 2, 0x00 );
+
+#else // CONFIG_CODEC_CS4228A
+    SSPDriver->Write( SSP_Handle, 0x01, 0x04 );
+    SSPDriver->Write( SSP_Handle, 0x0D, 0x84 );
+
+#endif
+
+}
+
+static int snd_ep93xx_codec_setvolume( int value )
+{
+#ifdef CONFIG_CODEC_CS4271
+        int iMute = 0;
+#endif
+
+	DPRINTK("snd_ep93xx_codec_setvolume %x- enter\n",value);
+
+#ifdef CONFIG_CODEC_CS4271
+        /*
+         * CS4271 DAC attenuation is 0 to 127 dB in 1 dB steps
+         */
+        if( mute )
+        {
+                iMute = 0x80;
+        }
+        DPRINTK("%x---%x\n",iMute,mute);
+        /*
+         * Write the volume for DAC1 and DAC2 (reg 4 and 5)
+         */
+        SSPDriver->Write( SSP_Handle, 4, (value | iMute) );
+        SSPDriver->Write( SSP_Handle, 5, (value | iMute) );
+
+
+#else // CONFIG_CODEC_CS4228A
+    /*
+     * CS4228A DAC attenuation is 0 to 90.5 dB in 0.5 dB steps
+     */
+    SSPDriver->Write( SSP_Handle, 0x07, value );
+    SSPDriver->Write( SSP_Handle, 0x08, value );
+    SSPDriver->Write( SSP_Handle, 0x09, value );
+    SSPDriver->Write( SSP_Handle, 0x0A, value );
+    SSPDriver->Write( SSP_Handle, 0x0B, value );
+    SSPDriver->Write( SSP_Handle, 0x0C, value );
+
+#endif
+    DPRINTK("snd_ep93xx_codec_setvolume - exit\n");
+    return 0;
+}
+
+/*
+ * ep93xx_automute_i2s_codec
+ *
+ * Note that codec must be getting i2s clocks for any codec
+ * register writes to work.
+ */
+static void snd_ep93xx_codec_automute (audio_state_t *state)
+{
+	DPRINTK("snd_ep93xx_codec_automute - enter\n");	
+#ifdef CONFIG_CODEC_CS4271
+	/*
+	 * The automute bit is set by default for the CS4271.
+	 * Clear the driver's mute flag and use the set_volume routine
+	 * to write the current volume out with the mute bit cleared.
+	 */
+    mute = 0;
+    snd_ep93xx_codec_setvolume(0);
+    
+    state->playback_volume[0][0] = 127 ;
+    state->playback_volume[0][0] = 127 ;
+
+
+#else // CONFIG_CODEC_CS4228A	
+    SSPDriver->Write( SSP_Handle, 4, 0 );
+		
+    /* Unmute the DACs */
+    SSPDriver->Write( SSP_Handle, 5, 0x80 );
+    /* Unmute the MUTEC pin, turn on automute. */
+    SSPDriver->Write( SSP_Handle, 5, 0x40 );
+    
+    state->playback_volume[0][0] = 181 ;
+    state->playback_volume[0][1] = 181 ;
+    state->playback_volume[1][0] = 181 ;
+    state->playback_volume[1][1] = 181 ;
+    state->playback_volume[2][0] = 181 ;
+    state->playback_volume[2][1] = 181 ;
+
+#endif    
+    DPRINTK("snd_ep93xx_codec_automute - exit\n");
+}
+
+
+/*
+ * ep93xx_audio_init
+ * Note that the codec powers up with its DAC's muted and
+ * the serial format set to 24 bit I2S mode.
+ */
+static void snd_ep93xx_audio_init(audio_state_t *state)
+{
+    DPRINTK("snd_ep93xx_audio_init - enter\n");
+    /* Mute the DACs. Disable all audio channels. */  
+    /* Must do this to change sample rate. */
+
+    snd_ep93xx_i2s_disable_transmit();
+    snd_ep93xx_i2s_disable_receive();
+    snd_ep93xx_i2s_disable();
+    
+    /*Set up the i2s clocks in syscon.  Enable them. */ 
+    ep93xx_set_samplerate( AUDIO_SAMPLE_RATE_DEFAULT );
+
+    /* Set i2s' controller serial format, and enable */ 
+    snd_ep93xx_i2s_init(WL16);
+
+    /* Initialize codec serial format, etc. */
+    snd_ep93xx_codec_init();
+
+    /* Clear the fifo and enable the tx0 channel. */
+    snd_ep93xx_i2s_enable_transmit();
+    snd_ep93xx_i2s_enable_receive();
+    snd_ep93xx_i2s_enable();
+
+    /* Set the volume for the first time. */
+    snd_ep93xx_codec_setvolume( AUDIO_DEFAULT_VOLUME );
+
+    /* Unmute the DAC and set the mute pin MUTEC to automute. */
+    snd_ep93xx_codec_automute(state);
+	
+    DPRINTK("snd_ep93xx_audio_init - exit\n");
+}
+
+static void print_audio_format( long format )
+{
+    switch( format ){
+	case SNDRV_PCM_FORMAT_S8:
+		DPRINTK( "AFMT_S8\n" );		   
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:		   
+		DPRINTK( "AFMT_U8\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		DPRINTK( "AFMT_S16_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_BE:
+		DPRINTK( "AFMT_S16_BE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U16_LE:
+		DPRINTK( "AFMT_U16_LE\n" );		   
+		break;
+	case SNDRV_PCM_FORMAT_U16_BE:
+		DPRINTK( "AFMT_U16_BE\n" );
+		break;
+			
+	case SNDRV_PCM_FORMAT_S24_LE:
+		DPRINTK( "AFMT_S24_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_BE:
+		DPRINTK( "AFMT_S24_BE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U24_LE:
+		DPRINTK( "AFMT_U24_LE\n" );		   
+		break;
+
+	case SNDRV_PCM_FORMAT_U24_BE:
+		DPRINTK( "AFMT_U24_BE\n" );		   
+		break;
+	default:
+		DPRINTK( "ep93xx_i2s_Unsupported Audio Format\n" );		   
+		break;
+    }
+}
+
+static void audio_set_format( audio_stream_t * s, long val )
+{
+    DPRINTK( "ep93xx_i2s_audio_set_format enter.  Format requested (%d) %d ", 
+				(int)val,SNDRV_PCM_FORMAT_S16_LE);
+    print_audio_format( val );
+	
+    switch( val ){
+	case SNDRV_PCM_FORMAT_S8:
+		s->audio_format = SNDRV_PCM_FORMAT_S8;
+		s->audio_stream_bitwidth = 8;
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:		   
+		s->audio_format = SNDRV_PCM_FORMAT_U8;
+		s->audio_stream_bitwidth = 8;
+		break;
+			
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S16_BE:
+		s->audio_format = SNDRV_PCM_FORMAT_S16_LE;
+		s->audio_stream_bitwidth = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_U16_LE:
+	case SNDRV_PCM_FORMAT_U16_BE:
+		s->audio_format = SNDRV_PCM_FORMAT_U16_LE;
+		s->audio_stream_bitwidth = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FMTBIT_S24_BE:		
+		s->audio_format = SNDRV_PCM_FORMAT_S24_LE;
+		s->audio_stream_bitwidth = 24;
+		break;
+
+	case SNDRV_PCM_FORMAT_U24_LE:
+	case SNDRV_PCM_FMTBIT_U24_BE:		
+        default:
+		s->audio_format = SNDRV_PCM_FORMAT_U24_LE;
+		s->audio_stream_bitwidth = 24;
+		break;
+    }
+
+    DPRINTK( "ep93xx_i2s_audio_set_format EXIT format set to be (%d) ", (int)s->audio_format );
+    print_audio_format( (long)s->audio_format );
+}
+
+static __inline__ unsigned long copy_to_user_S24_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+			    
+    int total_to_count = to_count;
+    int *user_ptr = (int *)to;	/* 32 bit user buffer */
+    int count;
+    	
+    count = 8 * stream->dma_num_channels;
+	
+    while (to_count > 0){
+    
+	__put_user( (int)( *dma_buffer_0++ ), user_ptr++ );
+	__put_user( (int)( *dma_buffer_0++ ), user_ptr++ );
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (int)( *dma_buffer_1++ ), user_ptr++ );
+	    __put_user( (int)( *dma_buffer_1++ ), user_ptr++ );
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (int)( *dma_buffer_2++ ), user_ptr++ );
+	    __put_user( (int)( *dma_buffer_2++ ), user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U24_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+			
+    int total_to_count = to_count;
+    unsigned int * user_ptr = (unsigned int *)to;	/* 32 bit user buffer */
+    int count;
+	
+    count = 8 * stream->dma_num_channels;
+	
+    while (to_count > 0){ 
+	__put_user( ((unsigned int)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+	__put_user( ((unsigned int)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( ((unsigned int)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned int)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( ((unsigned int)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((unsigned int)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_S16_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int total_to_count = to_count;
+    short * user_ptr = (short *)to;	/* 16 bit user buffer */
+    int count;
+    	
+    count = 4 * stream->dma_num_channels;
+		
+    while (to_count > 0){
+
+	__put_user( (short)( *dma_buffer_0++ ), user_ptr++ );
+	__put_user( (short)( *dma_buffer_0++ ), user_ptr++ );
+
+        if( stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (short)( *dma_buffer_1++ ), user_ptr++ );
+	    __put_user( (short)( *dma_buffer_1++ ), user_ptr++ );
+	}
+
+        if( stream->audio_channels_flag  & CHANNEL_CENTER_LFE ){
+	    __put_user( (short)( *dma_buffer_2++ ), user_ptr++ );
+	    __put_user( (short)( *dma_buffer_2++ ), user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U16_LE
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    short * user_ptr = (short *)to;	/* 16 bit user buffer */
+
+    count = 4 * stream->dma_num_channels;
+		
+    while (to_count > 0){
+
+	__put_user( ((short)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+	__put_user( ((short)( *dma_buffer_0++ )) ^ 0x8000, user_ptr++ );
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( ((short)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((short)( *dma_buffer_1++ )) ^ 0x8000, user_ptr++ );
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( ((short)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	    __put_user( ((short)( *dma_buffer_2++ )) ^ 0x8000, user_ptr++ );
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_S8
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    char * user_ptr = (char *)to;  /*  8 bit user buffer */
+
+    count = 2 * stream->dma_num_channels;
+	
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+		
+    while (to_count > 0){
+
+	__put_user( (char)( *dma_buffer_0 ), user_ptr++ );
+	dma_buffer_0 += 4;
+	__put_user( (char)( *dma_buffer_0 ), user_ptr++ );
+	dma_buffer_0 += 4;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (char)( *dma_buffer_1 ), user_ptr++ );
+            dma_buffer_1 += 4;
+	    __put_user( (char)( *dma_buffer_1 ), user_ptr++ );
+	    dma_buffer_1 += 4;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (char)( *dma_buffer_2 ), user_ptr++ );
+	    dma_buffer_2 += 4;
+	    __put_user( (char)( *dma_buffer_2 ), user_ptr++ );
+	    dma_buffer_2 += 4;
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U8
+(
+    audio_stream_t *stream,
+    const char *to, 
+    unsigned long to_count
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    int total_to_count = to_count;
+    char * user_ptr = (char *)to;  /*  8 bit user buffer */
+
+    count = 2 * stream->dma_num_channels;
+		
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+	
+    while (to_count > 0){
+	
+	__put_user( (char)( *dma_buffer_0 ) ^ 0x80, user_ptr++ );
+	dma_buffer_0 += 4;
+	__put_user( (char)( *dma_buffer_0 ) ^ 0x80, user_ptr++ );
+	dma_buffer_0 += 4;
+				
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __put_user( (char)( *dma_buffer_1 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_1 += 4;
+	    __put_user( (char)( *dma_buffer_1 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_1 += 4;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __put_user( (char)( *dma_buffer_2 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_2 += 4;
+	    __put_user( (char)( *dma_buffer_2 ) ^ 0x80, user_ptr++ );
+	    dma_buffer_2 += 4;
+	}
+	to_count -= count;
+    }
+    return total_to_count;
+}
+
+static __inline__ int copy_to_user_with_conversion
+(
+    audio_stream_t *stream,
+    const char *to, 
+    int toCount
+)
+{
+    int ret = 0;
+	
+    if( toCount == 0 ){
+	DPRINTK("ep93xx_i2s_copy_to_user_with_conversion - nothing to copy!\n");
+    }
+
+    switch( stream->audio_format ){
+
+	case SNDRV_PCM_FORMAT_S8:
+		ret = copy_to_user_S8( stream, to, toCount );
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:
+		ret = copy_to_user_U8( stream, to, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		ret = copy_to_user_S16_LE( stream, to, toCount );
+		break;
+		
+	case SNDRV_PCM_FORMAT_U16_LE:
+		ret = copy_to_user_U16_LE( stream, to, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		ret = copy_to_user_S24_LE( stream, to, toCount );
+		break;
+		
+	case SNDRV_PCM_FORMAT_U24_LE:
+		ret = copy_to_user_U24_LE( stream, to, toCount );
+		break;
+        default:
+                DPRINTK( "ep93xx_i2s copy to user unsupported audio format\n" );
+		break;
+    }
+    return ret;
+}
+
+static __inline__ int copy_from_user_S24_LE
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+
+    unsigned int * user_buffer = (unsigned int *)from;
+    unsigned int data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = (unsigned int)data;
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = (unsigned int)data;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = (unsigned int)data;
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = (unsigned int)data;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = (unsigned int)data;
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = (unsigned int)data;
+        }
+	toCount -= count;
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_U24_LE
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    unsigned int * user_buffer = (unsigned int *)from;
+    unsigned int data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	}
+	toCount -= count;
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_S16_LE
+(
+	audio_stream_t *stream,
+	const char *from, 
+	int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    unsigned short *user_buffer = (unsigned short *)from;
+    unsigned short data;
+	
+    int toCount0 = toCount;
+    int count;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+    
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = data;
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = data;
+	
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+    	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = data;
+    	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = data;
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = data;
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = data;
+	}
+	toCount -= count;
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_U16_LE
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int *dma_buffer_0 = (int *)stream->hwbuf[0];
+    int *dma_buffer_1 = (int *)stream->hwbuf[1];
+    int *dma_buffer_2 = (int *)stream->hwbuf[2];
+    int count;
+    unsigned short * user_buffer = (unsigned short *)from;
+    unsigned short data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    while (toCount > 0){
+    
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+	__get_user(data, user_buffer++);
+	*dma_buffer_0++ = ((unsigned int)data ^ 0x8000);
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+    	    __get_user(data, user_buffer++);
+            *dma_buffer_1++ = ((unsigned int)data ^ 0x8000);
+	}
+
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2++ = ((unsigned int)data ^ 0x8000);
+	}
+	toCount -= count;
+    }
+    return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_S8
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    unsigned char * user_buffer = (unsigned char *)from;
+    unsigned char data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+
+    dma_buffer_0++;
+    dma_buffer_1++;
+    dma_buffer_2++;
+
+    while (toCount > 0){
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = data;
+	dma_buffer_0 += 4;
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = data;
+	dma_buffer_0 += 4;
+
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1 = data;
+            dma_buffer_1 += 4;
+	    __get_user(data, user_buffer++);
+            *dma_buffer_1 = data;
+	    dma_buffer_1 += 4;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2 = data;
+	    dma_buffer_2 += 4;
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2 = data;
+            dma_buffer_2 += 4;
+	}
+	toCount -= count;
+    }
+    return toCount0 / 4;
+}
+
+static __inline__ int copy_from_user_U8
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    char *dma_buffer_0 = (char *)stream->hwbuf[0];
+    char *dma_buffer_1 = (char *)stream->hwbuf[1];
+    char *dma_buffer_2 = (char *)stream->hwbuf[2];
+    int count;
+    unsigned char *user_buffer = (unsigned char *)from;
+    unsigned char data;
+	
+    int toCount0 = toCount;
+    count = 8 * stream->dma_num_channels;
+	
+    dma_buffer_0 ++;
+    dma_buffer_1 ++;
+    dma_buffer_2 ++;
+			
+    while (toCount > 0){
+
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = ((unsigned char)data ^ 0x80);
+	dma_buffer_0 += 4;
+	__get_user(data, user_buffer++);
+	*dma_buffer_0 = ((unsigned char)data ^ 0x80);
+	dma_buffer_0 += 4;
+        
+        if(stream->audio_channels_flag & CHANNEL_REAR ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_1 = ((unsigned char)data ^ 0x80);
+            dma_buffer_1 += 4;
+	    __get_user(data, user_buffer++);
+            *dma_buffer_1 = ((unsigned char)data ^ 0x80);
+            dma_buffer_1 += 4;
+	}
+	
+        if(stream->audio_channels_flag & CHANNEL_CENTER_LFE ){
+	    __get_user(data, user_buffer++);
+	    *dma_buffer_2 = ((unsigned char)data ^ 0x80);
+    	    dma_buffer_2 += 4;
+	    __get_user(data, user_buffer++);
+    	    *dma_buffer_2 = ((unsigned char)data ^ 0x80);
+            dma_buffer_2 += 4;
+	}
+	toCount -= count;
+    }
+    return toCount0 / 4;
+}
+
+/*
+ * Returns negative for error
+ * Returns # of bytes transferred out of the from buffer
+ * for success.
+ */
+static __inline__ int copy_from_user_with_conversion
+(
+    audio_stream_t *stream,
+    const char *from, 
+    int toCount 
+)
+{
+    int ret = 0;
+//    DPRINTK("copy_from_user_with_conversion\n");	
+    if( toCount == 0 ){
+    	DPRINTK("ep93xx_i2s_copy_from_user_with_conversion - nothing to copy!\n");
+    }
+
+    switch( stream->audio_format ){
+
+	case SNDRV_PCM_FORMAT_S8:
+		//DPRINTK("SNDRV_PCM_FORMAT_S8\n");
+		ret = copy_from_user_S8( stream, from, toCount );
+		break;
+			
+	case SNDRV_PCM_FORMAT_U8:
+		//DPRINTK("SNDRV_PCM_FORMAT_U8\n");
+		ret = copy_from_user_U8( stream, from, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		//DPRINTK("SNDRV_PCM_FORMAT_S16_LE\n");
+		ret = copy_from_user_S16_LE( stream, from, toCount );
+		break;
+				
+	case SNDRV_PCM_FORMAT_U16_LE:
+		//DPRINTK("SNDRV_PCM_FORMAT_U16_LE\n");
+		ret = copy_from_user_U16_LE( stream, from, toCount );
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		//DPRINTK("SNDRV_PCM_FORMAT_S24_LE\n");
+		ret = copy_from_user_S24_LE( stream, from, toCount );
+		break;
+		
+	case SNDRV_PCM_FORMAT_U24_LE:
+		//DPRINTK("SNDRV_PCM_FORMAT_U24_LE\n");
+		ret = copy_from_user_U24_LE( stream, from, toCount );
+		break;
+        default:
+                DPRINTK( "ep93xx_i2s copy from user unsupported audio format\n" );
+		break;			
+    }
+	
+    return ret;
+}
+
+/*
+ *  For audio playback, we convert samples of arbitrary format to be 32 bit 
+ *  for our hardware. We're scaling a user buffer to a dma buffer.  So when
+ *  report byte counts, we scale them acording to the ratio of DMA sample
+ *  size to user buffer sample size.  When we report # of DMA fragments,
+ *  we don't scale that.  So:
+ *
+ *  Also adjust the size and number of dma fragments if sample size changed.
+ *
+ *  Input format       Input sample     Output sample size    ratio (out:in)
+ *  bits   channels    size (bytes)       CM   non-CM          CM   non-CM
+ *   8      stereo         2		   4      8            2:1   4:1
+ *   16     stereo         4		   4      8            1:1   2:1
+ *   24     stereo         6		   4      8             X    8:6 not a real case
+ *
+ */
+static void snd_ep93xx_dma2usr_ratio( audio_stream_t * stream )
+{
+    unsigned int dma_sample_size, user_sample_size;
+	
+    dma_sample_size = 8;	/* each stereo sample is 2 * 32 bits */
+	
+    // If stereo 16 bit, user sample is 4 bytes.
+    // If stereo  8 bit, user sample is 2 bytes.
+
+    user_sample_size = stream->audio_stream_bitwidth / 4;
+
+    stream->dma2usr_ratio = dma_sample_size / user_sample_size;
+}
+
+/*---------------------------------------------------------------------------------------------*/
+
+static int snd_ep93xx_dma_free(struct snd_pcm_substream *substream ){
+
+    
+    audio_state_t *state = substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                              state->output_stream:state->input_stream;
+    int i;
+    DPRINTK("snd_ep93xx_dma_free - enter\n");
+
+    for( i = 0 ; i < stream->dma_num_channels ;i++ ){
+	ep93xx_dma_free( stream->dmahandles[i] );
+    }
+    DPRINTK("snd_ep93xx_dma_free - exit\n");
+    return 0;	       
+}
+
+static int snd_ep93xx_dma_config(struct snd_pcm_substream *substream ){
+
+    audio_state_t *state = substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                               state->output_stream:state->input_stream;
+    int i,err = 0;
+	
+    DPRINTK("snd_ep93xx_dma_config - enter\n");
+
+    for( i = 0 ; i < stream->dma_num_channels ;i++ ){
+    
+        err = ep93xx_dma_request(&stream->dmahandles[i],
+	                        stream->devicename,
+	                        (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+				state->output_dma[i]:state->input_dma[i] );
+        if (err){
+	    printk("snd_ep93xx_dma_config - exit ERROR dma request failed\n");
+	    return err;
+        }
+	err = ep93xx_dma_config( stream->dmahandles[i],
+    				IGNORE_CHANNEL_ERROR,
+				0,
+				(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? 
+				snd_ep93xx_dma_tx_callback:snd_ep93xx_dma_rx_callback,
+				(unsigned int)substream );
+        if (err){
+	    printk("snd_ep93xx_dma_config - exit ERROR dma request failed\n");
+	    return err;
+	}
+    }
+
+    DPRINTK("snd_ep93xx_dma_config - enter\n");
+    return err;
+}
+
+static void snd_ep93xx_dma_start( audio_state_t * state, audio_stream_t * stream )
+{
+    int err,i;
+
+    DPRINTK("snd_ep93xx_dma_start - enter\n");
+
+    for(i = 0 ;i < stream->dma_num_channels;i++)
+	err = ep93xx_dma_start( stream->dmahandles[i], 1,(unsigned int *) stream->dmahandles );
+	
+    stream->active = 1;
+    
+    DPRINTK("snd_ep93xx_dma_start - exit\n");
+}
+
+static void snd_ep93xx_dma_pause( audio_state_t * state, audio_stream_t * stream )
+{
+    int i;
+ 
+    DPRINTK("snd_ep93xx_dma_pause - enter\n");
+
+    for(i = 0 ;i < stream->dma_num_channels;i++)
+	ep93xx_dma_pause( stream->dmahandles[i], 1,(unsigned int *)stream->dmahandles );
+
+    stream->active = 0;
+    DPRINTK("snd_ep93xx_dma_pause - exit\n");
+
+}
+
+static void snd_ep93xx_dma_flush( audio_state_t * state, audio_stream_t * stream ){
+
+    int i;
+    
+    DPRINTK("snd_ep93xx_dma_flush - enter\n");
+	
+    for( i = 0 ; i < stream->dma_num_channels ; i++ )
+	ep93xx_dma_flush( stream->dmahandles[i] );
+	   
+    DPRINTK("snd_ep93xx_dma_flush - exit\n");
+}
+
+static void snd_ep93xx_deallocate_buffers(struct snd_pcm_substream *substream, audio_stream_t *stream )
+{
+    int i;
+    audio_channel_t *dma_chan;
+    
+    DPRINTK("snd_ep93xx_deallocate_buffers - enter\n");
+    
+    if( stream->dma_channels ){
+
+        for(i = 0;i < stream->dma_num_channels;i++){
+
+	    dma_chan = &stream->dma_channels[i];
+
+	    if( dma_chan->area ){
+	    	    
+		if( dma_chan->audio_buffers ){
+
+		    kfree(dma_chan->audio_buffers);
+		    dma_chan->audio_buffers = NULL;
+		    
+		}
+
+		//kfree(dma_chan->area);
+                dma_free_writecombine(0, dma_chan->bytes,
+                                      dma_chan->area, dma_chan->addr);
+		dma_chan->area = NULL;
+	    }    
+	}
+	kfree(stream->dma_channels);
+	stream->dma_channels = NULL;
+    }
+    DPRINTK("snd_ep93xx_deallocate_buffers - exit\n");
+}
+
+static int snd_ep93xx_allocate_buffers(struct snd_pcm_substream *substream, audio_stream_t *stream)
+{
+    audio_channel_t *channel;
+    unsigned int size,tmpsize,bufsize,bufextsize;
+    int i,j;
+    
+        
+    DPRINTK("snd_ep93xx_allocate_buffers - enter\n" );
+
+    if (stream->dma_channels){
+	printk("ep93xx_i2s  %s BUSY\n",__FUNCTION__);
+        return -EBUSY;
+    }
+							       
+    stream->dma_channels = (audio_channel_t *)kmalloc(sizeof(audio_channel_t) * stream->dma_num_channels , GFP_KERNEL);
+	    
+    if (!stream->dma_channels){
+	printk(AUDIO_NAME ": unable to allocate dma_channels memory\n");
+	return - ENOMEM;
+    }
+    
+    size = ( stream->dmasize / stream->dma_num_channels ) * stream->dma2usr_ratio; 
+
+    for( i = 0; i < stream->dma_num_channels;i++){
+	channel = &stream->dma_channels[i];
+
+	//channel->area = kmalloc( size, GFP_DMA );
+	channel->area = dma_alloc_writecombine(0, size,&channel->addr,GFP_KERNEL);		
+	if(!channel->area){
+	    printk(AUDIO_NAME ": unable to allocate audio memory\n");
+	    return -ENOMEM;
+	}	
+	channel->bytes = size;
+	//channel->addr = __virt_to_phys((int) channel->area);
+        memset( channel->area, 0, channel->bytes );
+
+	bufsize = ( stream->fragsize / stream->dma_num_channels ) * stream->dma2usr_ratio;
+	channel->audio_buff_count = size / bufsize;
+	bufextsize = size % bufsize;
+
+	if( bufextsize > 0 ){
+	    channel->audio_buff_count++;
+	}
+	
+	channel->audio_buffers = (audio_buf_t *)kmalloc(sizeof(audio_buf_t) * channel->audio_buff_count , GFP_KERNEL);
+		    
+	if (!channel->audio_buffers){
+	    printk(AUDIO_NAME ": unable to allocate audio memory\n ");
+	    return -ENOMEM;
+	}
+
+	tmpsize = size;
+
+	for( j = 0; j < channel->audio_buff_count; j++){
+
+	    channel->audio_buffers[j].dma_addr = channel->addr + j * bufsize;		
+
+	    if( tmpsize >= bufsize ){
+		tmpsize -= bufsize;
+		channel->audio_buffers[j].bytes = bufsize;
+		channel->audio_buffers[j].reportedbytes = bufsize / stream->dma2usr_ratio; 
+	    }
+	    else{
+                channel->audio_buffers[j].bytes = bufextsize;
+                channel->audio_buffers[j].reportedbytes = bufextsize / stream->dma2usr_ratio;
+	    }
+	}								
+    }
+
+    DPRINTK("snd_ep93xx_allocate_buffers -- exit SUCCESS\n" );
+    return 0;
+}
+
+/*
+ * DMA callback functions
+ */
+ 
+static void snd_ep93xx_dma_tx_callback
+( 
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+    int handle;
+    int i,chan;
+    unsigned int buf_id;
+	    		
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)user_data;
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    audio_stream_t *stream = state->output_stream;
+    audio_buf_t *buf;
+
+    switch( device )              
+    {
+	case DMATx_I2S3:
+//	    DPRINTK( "snd_ep93xx_dma_tx_callback - DMATx_I2S3\n");
+	    i = 2;
+	    break;
+    	case DMATx_I2S2:
+//	    DPRINTK( "snd_ep93xx_dma_tx_callback - DMATx_I2S2\n");
+       	    i = 1;
+	    break;
+	case DMATx_I2S1:
+	    default:
+//	    DPRINTK( "snd_ep93xx_dma_tx_callback - DMATx_I2S1\n");
+       	    i = 0;
+	    break;
+    }
+
+    chan = stream->audio_num_channels / 2 - 1;
+    handle = stream->dmahandles[i];
+
+    if(stream->stopped == 0){
+
+	if( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0 ){
+
+	    buf = (audio_buf_t *)buf_id;
+            stream->bytecount += buf->reportedbytes;
+	    ep93xx_dma_add_buffer( stream->dmahandles[i],
+				    (unsigned int)buf->dma_addr,
+				    0,
+				    buf->bytes,
+				    0,
+				    (unsigned int) buf );
+
+            if(chan == i)
+	        snd_pcm_period_elapsed(substream);
+	}
+    }
+}
+
+static void snd_ep93xx_dma_rx_callback
+(
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+    int handle,i,chan;
+    unsigned int buf_id;
+    audio_buf_t *buf;
+		
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)user_data;
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    audio_stream_t *stream = state->input_stream;
+
+    switch( device ){
+		
+	case DMARx_I2S3:
+//    	    DPRINTK( "snd_ep93xx_dma_rx_callback - DMARx_I2S3\n");
+	    i = 2;
+	    break;
+    	case DMARx_I2S2:
+//          DPRINTK( "snd_ep93xx_dma_rx_callback - DMARx_I2S2\n");
+	    i = 1;
+	    break;
+	case DMARx_I2S1:
+	    default:
+//	    DPRINTK( "snd_ep93xx_dma_rx_callback - DMARx_I2S1\n");
+	    i = 0;
+	    break;
+    }
+    chan = stream->audio_num_channels / 2 - 1;
+    handle = stream->dmahandles[i];
+    
+    if( stream->stopped == 0 ){
+	
+        if( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0 ){
+
+    	    buf = (audio_buf_t *)buf_id;
+	    stream->bytecount += buf->reportedbytes;
+	    ep93xx_dma_add_buffer( stream->dmahandles[i],
+				    (unsigned int)buf->dma_addr,
+				    0, 
+				    buf->bytes,
+				    0,
+				    (unsigned int) buf );
+
+            if( i == chan )
+                snd_pcm_period_elapsed(substream);
+	}
+    } 
+}
+
+static int snd_ep93xx_release(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                             state->output_stream : state->input_stream;
+    
+    DPRINTK("snd_ep93xx_release - enter\n");
+
+    down(&state->sem);
+    stream->active = 0;
+    stream->stopped = 0;
+    snd_ep93xx_deallocate_buffers(substream, stream);
+    up(&state->sem);
+
+    DPRINTK("snd_ep93xx_release - exit\n");
+
+    return 0;
+}
+
+static int snd_ep93xx_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+        DPRINTK("snd_ep93xx_pcm_hw_params - enter\n");
+	return snd_pcm_lib_malloc_pages(substream,params_buffer_bytes(params));
+}
+
+static int snd_ep93xx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+
+	DPRINTK("snd_ep93xx_pcm_hw_free - enter\n");
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/*
+ *snd_ep93xx_pcm_prepare: need to finish these functions as lower
+ *chip_set_sample_format
+ *chip_set_sample_rate
+ *chip_set_channels
+ *chip_set_dma_setup
+ */
+
+static int snd_ep93xx_pcm_prepare_playback(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *) substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->output_stream;
+
+    DPRINTK("snd_ep93xx_pcm_prepare_playback - enter\n");
+    
+    snd_ep93xx_i2s_disable_transmit();
+	        
+    snd_ep93xx_deallocate_buffers(substream,stream);
+			
+    if(runtime->channels % 2 != 0)
+	return -1;
+		   	
+//    printk("The runtime item : \n");
+//    printk("runtime->dma_addr    = 0x%x\n", runtime->dma_addr);
+//    printk("runtime->dma_area    = 0x%x\n", runtime->dma_area);
+//    printk("runtime->dma_bytes   = %d\n",   runtime->dma_bytes);
+//    printk("runtime->frame_bits  = %d\n",   runtime->frame_bits);
+//    printk("runtime->buffer_size = %d\n",   runtime->buffer_size);
+//    printk("runtime->period_size = %d\n",   runtime->period_size);
+//    printk("runtime->periods     = %d\n",   runtime->periods);
+//    printk("runtime->rate        = %d\n",   runtime->rate);
+//    printk("runtime->format      = %d\n",   runtime->format);
+//    printk("runtime->channels    = %d\n",   runtime->channels);
+	
+    /* set requestd format when available */
+    stream->audio_num_channels = runtime->channels;
+    stream->dma_num_channels = runtime->channels / 2;
+
+
+    stream->audio_channels_flag = CHANNEL_FRONT;
+    if(stream->dma_num_channels == 2)
+        stream->audio_channels_flag |= CHANNEL_REAR;
+    if(stream->dma_num_channels == 3)
+        stream->audio_channels_flag |= CHANNEL_REAR | CHANNEL_CENTER_LFE;
+			    
+    stream->dmasize = runtime->dma_bytes;
+    stream->nbfrags = runtime->periods;
+    stream->fragsize = frames_to_bytes (runtime, runtime->period_size);
+    stream->bytecount = 0;
+
+    if( !state->codec_set_by_capture ){
+	state->codec_set_by_playback = 1;
+	
+	if( stream->audio_rate != runtime->rate ){
+	    ep93xx_set_samplerate( runtime->rate );
+	}    
+	if( stream->audio_format != runtime->format ){
+    	    snd_ep93xx_i2s_init((stream->audio_stream_bitwidth == 24));
+	}
+    }
+    else{
+        audio_stream_t *s = state->input_stream;
+        if( runtime->format != s->audio_format)
+    	    return -1;
+	if( runtime->rate != s->audio_rate )
+	    return -1;
+    }
+
+    stream->audio_rate = runtime->rate;
+    audio_set_format( stream, runtime->format );
+    snd_ep93xx_dma2usr_ratio( stream );
+	
+    if( snd_ep93xx_allocate_buffers( substream, stream ) != 0 ){
+        snd_ep93xx_deallocate_buffers( substream, stream );
+        return -1;
+    }
+    
+    snd_ep93xx_i2s_enable_transmit();
+												 
+    DPRINTK("snd_ep93xx_pcm_prepare_playback - exit\n");
+    return 0;	
+}
+
+static int snd_ep93xx_pcm_prepare_capture(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *) substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->input_stream;
+    
+    snd_ep93xx_i2s_disable_receive();
+	
+    snd_ep93xx_deallocate_buffers(substream,stream);
+
+    if(runtime->channels % 2 != 0)
+	return -1;
+		   		       
+    DPRINTK("snd_ep93xx_pcm_prepare_capture - enter\n");
+			
+//    printk("The runtime item : \n");
+//    printk("runtime->dma_addr    = 0x%x\n", runtime->dma_addr);
+//    printk("runtime->dma_area    = 0x%x\n", runtime->dma_area);
+//    printk("runtime->dma_bytes   = %d\n",   runtime->dma_bytes);
+//    printk("runtime->frame_bits  = %d\n",   runtime->frame_bits);
+//    printk("runtime->buffer_size = %d\n",   runtime->buffer_size);
+//    printk("runtime->period_size = %d\n",   runtime->period_size);
+//    printk("runtime->periods     = %d\n",   runtime->periods);
+//    printk("runtime->rate        = %d\n",   runtime->rate);
+//    printk("runtime->format      = %d\n",   runtime->format);
+//    printk("runtime->channels    = %d\n",   runtime->channels);
+	
+    /* set requestd format when available */
+    stream->audio_num_channels = runtime->channels;
+    stream->dma_num_channels = runtime->channels / 2;
+
+    stream->audio_channels_flag = CHANNEL_FRONT;
+    if(stream->dma_num_channels == 2)
+	stream->audio_channels_flag |= CHANNEL_REAR;
+    if(stream->dma_num_channels == 3)
+	stream->audio_channels_flag |= CHANNEL_REAR | CHANNEL_CENTER_LFE;
+			    
+    stream->dmasize = runtime->dma_bytes;
+    stream->nbfrags = runtime->periods;
+    stream->fragsize = frames_to_bytes (runtime, runtime->period_size);
+    stream->bytecount = 0;
+
+    if( !state->codec_set_by_playback ){
+	state->codec_set_by_capture = 1;
+
+	if( stream->audio_rate != runtime->rate ){
+    	    ep93xx_set_samplerate( runtime->rate );
+	}
+        if( stream->audio_format != runtime->format ){
+    	    snd_ep93xx_i2s_init((stream->audio_stream_bitwidth == 24));
+	}
+    }
+    else{
+        audio_stream_t *s = state->output_stream;
+        if( runtime->format != s->audio_format)
+    	    return -1;
+	if( runtime->rate != s->audio_rate )
+    	    return -1;
+    }
+
+    stream->audio_rate = runtime->rate;
+    audio_set_format( stream, runtime->format );
+    snd_ep93xx_dma2usr_ratio( stream );
+
+    if( snd_ep93xx_allocate_buffers( substream, stream ) != 0 ){
+        snd_ep93xx_deallocate_buffers( substream, stream );
+	return -1;
+    }
+    
+    snd_ep93xx_i2s_enable_receive();
+												 
+    DPRINTK("snd_ep93xx_pcm_prepare_capture - exit\n");
+    return 0;	
+}
+/*
+ *start/stop/pause dma translate
+ */
+static int snd_ep93xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{	
+    audio_state_t  *state = (audio_state_t *)substream->private_data;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+				state->output_stream:state->input_stream;
+    audio_buf_t *buf; 
+    audio_channel_t *dma_channel;
+    int i,count,ret = 0;
+    unsigned long flags;
+
+    DPRINTK("snd_ep93xx_pcm_triger %d - enter \n",cmd);
+					
+    switch (cmd){
+    
+	case SNDRV_PCM_TRIGGER_START:
+				
+	    snd_ep93xx_dma_config( substream );
+
+            stream->stopped = 0;
+		
+            if( !stream->active && !stream->stopped ){
+	        stream->active = 1;
+    		snd_ep93xx_dma_start( state, stream );
+            }
+
+            local_irq_save(flags);
+    
+	    for (i = 0; i < stream->dma_num_channels; i++){
+		dma_channel = &stream->dma_channels[i];
+		
+		memset(dma_channel->area,0,dma_channel->bytes);
+		
+		for(count = 0 ;count < dma_channel->audio_buff_count; count++){
+		
+		    buf = &dma_channel->audio_buffers[count];																	
+    		    ep93xx_dma_add_buffer( stream->dmahandles[i],
+					    (unsigned int)buf->dma_addr,
+		            		    0,
+		                	    buf->bytes,
+					    0,
+					    (unsigned int) buf );
+		}
+	    }	
+						
+	    local_irq_restore(flags);
+	    break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	    stream->stopped = 1;
+	    snd_ep93xx_dma_pause( state, stream );
+	    snd_ep93xx_dma_flush( state, stream );
+	    snd_ep93xx_dma_free( substream );
+	    break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	    break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	    break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	    break;
+
+	    default:
+	    ret = -EINVAL;
+    }
+    DPRINTK("snd_ep93xx_pcm_triger %d - exit \n",cmd);
+    return ret;
+}
+
+static snd_pcm_uframes_t snd_ep93xx_pcm_pointer_playback(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->output_stream;
+    snd_pcm_uframes_t pointer = 0;
+
+    pointer = bytes_to_frames( runtime,stream->bytecount );
+
+    if (pointer >= runtime->buffer_size){
+	pointer = 0;
+	stream->bytecount = 0;
+    }
+			    
+    DPRINTK("snd_ep93xx_pcm_pointer_playback - exit\n");
+    return pointer;
+}
+
+static snd_pcm_uframes_t snd_ep93xx_pcm_pointer_capture(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->input_stream;
+    snd_pcm_uframes_t pointer = 0;
+	
+    pointer = bytes_to_frames( runtime,stream->bytecount );
+	
+    if (pointer >= runtime->buffer_size){
+	pointer = 0;
+	stream->bytecount = 0;
+    }
+	
+    DPRINTK("snd_ep93xx_pcm_pointer_capture - exit\n");
+    return pointer;
+}
+
+static int snd_ep93xx_pcm_open(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                                state->output_stream:state->input_stream;
+
+    DPRINTK("snd_ep93xx_pcm_open - enter\n");
+
+    down(&state->sem);
+            
+    runtime->hw = ep93xx_i2s_pcm_hardware;
+
+    stream->dma_num_channels = AUDIO_DEFAULT_DMACHANNELS;
+    stream->dma_channels = NULL;
+    stream->audio_rate = 0;
+    stream->audio_stream_bitwidth = 0;
+    	    
+    up(&state->sem);
+	
+    DPRINTK("snd_ep93xx_pcm_open - exit\n");
+    return 0;		
+}
+
+/*
+ *free the HW dma channel
+ *free the HW dma buffer
+ *free the Hw dma decrotion using function :kfree
+ */
+static int snd_ep93xx_pcm_close(struct snd_pcm_substream *substream)
+{
+    audio_state_t *state = (audio_state_t *)(substream->private_data);
+
+    DPRINTK("snd_ep93xx_pcm_close - enter\n");
+
+    snd_ep93xx_release(substream);
+
+    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	state->codec_set_by_playback = 0;
+    else
+	state->codec_set_by_capture = 0;
+
+    DPRINTK("snd_ep93xx_pcm_close - exit\n");
+    return 0;
+}
+
+static int snd_ep93xx_pcm_copy_playback(struct snd_pcm_substream * substream,int channel, 
+				snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+
+    audio_state_t *state = (audio_state_t *)substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->output_stream ;
+    audio_channel_t *dma_channel;
+    int i;
+    int tocount = frames_to_bytes(runtime,count);
+    
+    for( i = 0; i < stream->dma_num_channels; i++ ){
+
+	dma_channel = &stream->dma_channels[i];	
+	stream->hwbuf[i] = dma_channel->area + ( frames_to_bytes(runtime,pos) * stream->dma2usr_ratio / stream->dma_num_channels );
+    
+    }
+
+    if(copy_from_user_with_conversion(stream ,(const char*)src,(tocount * stream->dma2usr_ratio)) <=0 ){
+	DPRINTK(KERN_ERR "copy_from_user_with_conversion() failed\n");
+	return -EFAULT;
+    }
+
+//printk("snd_ep93xx_pcm_copy_playback %x %x %x- exit\n",stream->dma_num_channels,stream->dma2usr_ratio,frames_to_bytes(runtime,pos));
+					
+    DPRINTK("snd_ep93xx_pcm_copy_playback - exit\n");
+    return 0;
+}
+
+
+static int snd_ep93xx_pcm_copy_capture(struct snd_pcm_substream * substream,int channel, 
+				snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+    audio_state_t *state = (audio_state_t *)substream->private_data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    audio_stream_t *stream = state->input_stream ;
+    audio_channel_t *dma_channel;
+    int i;
+		       
+    int tocount = frames_to_bytes(runtime,count);
+			   
+    for( i = 0; i < stream->dma_num_channels; i++ ){
+  
+	dma_channel = &stream->dma_channels[i];
+	stream->hwbuf[i] = dma_channel->area + ( frames_to_bytes(runtime,pos) * stream->dma2usr_ratio / stream->dma_num_channels );
+
+    }
+
+    if(copy_to_user_with_conversion(stream,(const char*)src,tocount) <=0 ){
+
+	DPRINTK(KERN_ERR "copy_to_user_with_conversion() failed\n");
+	return -EFAULT;
+    }
+										       
+    DPRINTK("snd_ep93xx_pcm_copy_capture - exit\n");
+    return 0;
+}
+																					     
+static struct snd_pcm_ops snd_ep93xx_pcm_playback_ops = {
+	.open		= snd_ep93xx_pcm_open,
+	.close		= snd_ep93xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_ep93xx_pcm_hw_params,
+	.hw_free	= snd_ep93xx_pcm_hw_free,
+	.prepare	= snd_ep93xx_pcm_prepare_playback,
+	.trigger	= snd_ep93xx_pcm_trigger,
+	.pointer	= snd_ep93xx_pcm_pointer_playback,
+	.copy		= snd_ep93xx_pcm_copy_playback,
+	
+};
+
+static struct snd_pcm_ops snd_ep93xx_pcm_capture_ops = {
+	.open		= snd_ep93xx_pcm_open,
+	.close		= snd_ep93xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_ep93xx_pcm_hw_params,
+	.hw_free	= snd_ep93xx_pcm_hw_free,
+	.prepare	= snd_ep93xx_pcm_prepare_capture,
+	.trigger	= snd_ep93xx_pcm_trigger,
+	.pointer	= snd_ep93xx_pcm_pointer_capture,
+	.copy 		= snd_ep93xx_pcm_copy_capture,
+};
+
+static int snd_ep93xx_pcm_new(struct snd_card *card, audio_state_t *state, struct snd_pcm **rpcm)
+{
+    struct snd_pcm *pcm;
+    int play = state->output_stream? 1 : 0;/*SNDRV_PCM_STREAM_PLAYBACK*/
+    int capt = state->input_stream ? 1 : 0;/*SNDRV_PCM_STREAM_CAPTURE*/
+    int ret = 0;
+
+    DPRINTK("snd_ep93xx_pcm_new - enter\n");
+	
+    /* Register the new pcm device interface */
+    ret = snd_pcm_new(card, "EP93XX", 0, play, capt, &pcm);
+
+    if (ret){
+	DPRINTK("%s--%x:card=%x,play=%x,capt=%x,&pcm=%x\n",__FUNCTION__,ret,(int)card,play,capt,(int)pcm);
+	goto out;
+    }
+
+    /* allocate the pcm(DMA) memory */
+    ret = snd_pcm_lib_preallocate_pages_for_all(pcm, /*SNDRV_DMA_TYPE_DEV,0,*/SNDRV_DMA_TYPE_CONTINUOUS,snd_dma_continuous_data(GFP_KERNEL),128*1024,128*1024);
+
+    DPRINTK("The substream item : \n");
+    DPRINTK("pcm->streams[0].substream->dma_buffer.addr  = 0x%x\n", pcm->streams[0].substream->dma_buffer.addr);
+    DPRINTK("pcm->streams[0].substream->dma_buffer.area  = 0x%x\n", pcm->streams[0].substream->dma_buffer.area);
+    DPRINTK("pcm->streams[0].substream->dma_buffer.bytes = 0x%x\n", pcm->streams[0].substream->dma_buffer.bytes);
+    DPRINTK("pcm->streams[1].substream->dma_buffer.addr  = 0x%x\n", pcm->streams[1].substream->dma_buffer.addr);
+    DPRINTK("pcm->streams[1].substream->dma_buffer.area  = 0x%x\n", pcm->streams[1].substream->dma_buffer.area);
+    DPRINTK("pcm->streams[1].substream->dma_buffer.bytes = 0x%x\n", pcm->streams[1].substream->dma_buffer.bytes);	
+
+    pcm->private_data = state;
+	
+    /* seem to free the pcm data struct-->self dma buffer */
+    pcm->private_free = (void*) snd_pcm_lib_preallocate_free_for_all;
+
+    /* alsa pcm ops setting for SNDRV_PCM_STREAM_PLAYBACK */
+    if (play) {
+	int stream = SNDRV_PCM_STREAM_PLAYBACK;
+	snd_pcm_set_ops(pcm, stream, &snd_ep93xx_pcm_playback_ops);
+    }
+
+    /* alsa pcm ops setting for SNDRV_PCM_STREAM_CAPTURE */	
+    if (capt) {
+	int stream = SNDRV_PCM_STREAM_CAPTURE;
+	snd_pcm_set_ops(pcm, stream, &snd_ep93xx_pcm_capture_ops);
+    }
+
+    if (rpcm)
+	*rpcm = pcm;
+    DPRINTK("snd_ep93xx_pcm_new - exit\n");
+out:
+    return ret;
+}
+
+/* mixer */
+
+
+#ifdef CONFIG_CODEC_CS4228A
+
+static int ep93xx_i2s_volume_info(struct snd_kcontrol *kcontrol,
+                                        struct snd_ctl_elem_info * uinfo)
+{
+    int mask = 181;
+    
+    DPRINTK("%s \n",__FUNCTION__);
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 2;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = mask;
+    uinfo->value.integer.step = 2;	       
+    return 0;
+}
+
+static int ep93xx_i2s_volume_get(struct snd_kcontrol *kcontrol,
+                            	    struct snd_ctl_elem_value * ucontrol)
+{
+    audio_state_t * state = (audio_state_t *)kcontrol->private_data;
+    int max = 181;
+ 
+    DPRINTK("%s ucontrol->value.integer.value[0]=%x ucontrol->value.integer.value[1]=%x\n",__FUNCTION__,state->playback_volume[0][0],state->playback_volume[0][1]);
+ 
+    ucontrol->value.integer.value[0] = state->playback_volume[0][0] % (max + 1);/*state->playback_volume[0][0];*/
+    ucontrol->value.integer.value[1] = state->playback_volume[0][1] % (max + 1);/*state->playback_volume[0][1];*/
+    ucontrol->value.integer.value[2] = state->playback_volume[1][0] % (max + 1);/*state->playback_volume[0][0];*/
+    ucontrol->value.integer.value[3] = state->playback_volume[1][1] % (max + 1);/*state->playback_volume[0][1];*/
+    ucontrol->value.integer.value[4] = state->playback_volume[2][0] % (max + 1);
+    ucontrol->value.integer.value[5] = state->playback_volume[2][1] % (max + 1);
+
+    return 0;
+}
+
+static int ep93xx_i2s_volume_put(struct snd_kcontrol *kcontrol,
+                                   struct snd_ctl_elem_value * ucontrol)
+{
+    int i;
+    audio_state_t *state = (audio_state_t *) kcontrol->private_data;
+    int valL,valR;
+    int reg = 0x07;
+    int max = 181;
+    
+    DPRINTK("%s \n",__FUNCTION__);
+		
+    state->playback_volume[0][0] = ucontrol->value.integer.value[0];
+    state->playback_volume[0][1] = ucontrol->value.integer.value[1];
+    state->playback_volume[1][0] = ucontrol->value.integer.value[2];
+    state->playback_volume[1][1] = ucontrol->value.integer.value[3];
+    state->playback_volume[2][0] = ucontrol->value.integer.value[4];
+    state->playback_volume[2][1] = ucontrol->value.integer.value[5];
+
+    for( i = 0; i < 3; i++ ){
+    	if(state->playback_volume[i][0]>=max){
+        	valL = 0;
+		state->playback_volume[i][0] = max;
+    	}
+    	else{
+        	valL = max - state->playback_volume[i][0];
+    	}
+
+    	if(state->playback_volume[i][1]>=max){
+        	valR = 0;
+        	state->playback_volume[i][1] = max;
+    	}
+    	else{
+        	valR = max - state->playback_volume[i][1];
+    	}
+
+
+    	DPRINTK("%x  channle :L=%x,R=%x reg=%x\n",i,valL,valR,reg);
+    	SSPDriver->Write( SSP_Handle, reg++, valL );
+    	DPRINTK("reg=%x\n",reg);
+    	SSPDriver->Write( SSP_Handle, reg++, valR );
+    }
+	    
+    return 0;
+}
+
+#endif
+
+
+					
+static int ep93xx_i2s_volume_info_double(struct snd_kcontrol *kcontrol, 
+					struct snd_ctl_elem_info * uinfo)
+{
+
+#ifdef CONFIG_CODEC_CS4271
+    int mask = (kcontrol->private_value >> 16) & 0x7f;
+    
+    DPRINTK("%s %x\n",__FUNCTION__,mask);
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = mask;
+    uinfo->value.integer.step = 1;
+#else // CONFIG_ARCH_CS4228A
+    int mask = (kcontrol->private_value >> 16);
+
+    DPRINTK("%s max=%x\n",__FUNCTION__,mask); 
+
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 2;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = mask;
+    uinfo->value.integer.step = 2;
+#endif    
+    return 0;
+}
+
+static int ep93xx_i2s_volume_get_double(struct snd_kcontrol * kcontrol,
+                                       struct snd_ctl_elem_value * ucontrol)
+{
+
+    audio_state_t * state = (audio_state_t *)kcontrol->private_data;
+#ifdef CONFIG_CODEC_CS4271
+    int mask = (kcontrol->private_value >> 16) & 0x7f;
+    int val = 0;
+
+    DPRINTK("%s %x\n",__FUNCTION__,mask);	
+    val = state->playback_volume[0][0];
+    ucontrol->value.integer.value[0] = val & mask;
+
+#else // CONFIG_ARCH_CS4228A
+    unsigned int idx = ucontrol->id.numid -2;
+    int max = (kcontrol->private_value >> 16);
+
+    DPRINTK("%s max=%x idex=%x %x %x\n",__FUNCTION__,max,idx,state->playback_volume[idx][0],state->playback_volume[idx][1]);
+    
+    ucontrol->value.integer.value[0] = state->playback_volume[idx][0] % (max + 1);
+    ucontrol->value.integer.value[1] = state->playback_volume[idx][1] % (max + 1);
+#endif
+    
+    return 0;
+}
+
+static int ep93xx_i2s_volume_put_double(struct snd_kcontrol * kcontrol,
+                                       struct snd_ctl_elem_value * ucontrol)
+{
+    int reg1 = (kcontrol->private_value) & 0xf;
+    int reg2 = (kcontrol->private_value >> 4) & 0xf;
+    audio_state_t *state = (audio_state_t *) kcontrol->private_data;	
+#ifdef CONFIG_CODEC_CS4271
+	int mask = (kcontrol->private_value >> 16) & 0x7f;
+	int val = 0;
+	val = mask - (ucontrol->value.integer.value[0] & mask);
+	state->playback_volume[0][0] = ucontrol->value.integer.value[0] & mask;
+	
+	DPRINTK("%s %x\n",__FUNCTION__,mask);
+	DPRINTK("reg1 = 0x%x\n", reg1);
+	DPRINTK("reg2 = 0x%x\n", reg2);
+	DPRINTK("mask = %d\n", mask);
+	DPRINTK("val = %d\n", val);
+	DPRINTK("volume = %d\n", state->playback_volume[0][0]);
+	
+	
+	SSPDriver->Write( SSP_Handle, reg1, val );
+	SSPDriver->Write( SSP_Handle, reg2, val );
+
+#else // CONFIG_ARCH_CS4228A
+    //audio_state_t *state = (audio_state_t *) kcontrol->private_data;
+    unsigned int idx = ucontrol->id.numid -2;
+    int max = (kcontrol->private_value >> 16);
+    int valL=0,valR=0;
+
+    state->playback_volume[idx][0] = ucontrol->value.integer.value[0];
+    state->playback_volume[idx][1] = ucontrol->value.integer.value[1];
+
+	DPRINTK("%s max=%x idex=%x\n",__FUNCTION__,max,idx);
+        DPRINTK("reg1 = 0x%x\n", reg1);
+        DPRINTK("reg2 = 0x%x\n", reg2);
+
+        if(state->playback_volume[idx][0]>=max){
+                valL = 0;
+                state->playback_volume[idx][0] = max;
+        }
+        else{
+                valL = max - state->playback_volume[idx][0];
+        }
+
+        if(state->playback_volume[idx][1]>=max){
+                valR = 0;
+                state->playback_volume[idx][1] = max;
+        }
+        else{
+                valR = max - state->playback_volume[idx][1];
+        }
+
+        SSPDriver->Write( SSP_Handle, reg1, valL );
+        SSPDriver->Write( SSP_Handle, reg2, valR );
+#endif
+
+    return 0;
+}
+
+#ifdef CONFIG_CODEC_CS4228A
+
+static int ep93xx_i2s_volume_info_single(struct snd_kcontrol *kcontrol,
+                                        struct snd_ctl_elem_info * uinfo)
+{
+    int mask = (kcontrol->private_value >> 16);
+    DPRINTK("%s \n",__FUNCTION__);				
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = mask;
+    uinfo->value.integer.step = 1;
+    return 0;
+}
+								
+static int ep93xx_i2s_volume_get_single(struct snd_kcontrol * kcontrol,
+                                       struct snd_ctl_elem_value * ucontrol)
+{
+    audio_state_t *state = (audio_state_t *) kcontrol->private_data;
+    int idx = (kcontrol->private_value >> 4) & 0xf;
+    int max = (kcontrol->private_value >> 16);
+
+    DPRINTK("%s idex=%x\n",__FUNCTION__,idx);
+    ucontrol->value.integer.value[0] = state->playback_volume[2][idx] % (max + 1);
+    	   
+    return 0;
+}				       
+				       
+static int ep93xx_i2s_volume_put_single(struct snd_kcontrol * kcontrol,
+                                       struct snd_ctl_elem_value * ucontrol)
+{
+    audio_state_t *state = (audio_state_t *) kcontrol->private_data;
+    int reg = (kcontrol->private_value) & 0xf;
+    int idx = (kcontrol->private_value >> 4) & 0xf;
+    int max = (kcontrol->private_value >> 16);
+    int valL=0;
+    
+    DPRINTK("%s \n",__FUNCTION__);
+
+    state->playback_volume[2][idx] = ucontrol->value.integer.value[0];
+
+        if(state->playback_volume[2][idx]>=max){
+                valL = 0;
+                state->playback_volume[2][idx] = max;
+        }
+        else{
+                valL = max - state->playback_volume[2][idx];
+        }
+
+        SSPDriver->Write( SSP_Handle, reg, valL );
+		   		
+    return 0;
+}				       
+#endif
+
+
+static struct snd_kcontrol_new snd_ep93xx_i2s_controls[]  = {
+	
+#ifdef CONFIG_CODEC_CS4271
+    {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Master",
+	.info = ep93xx_i2s_volume_info_double,
+        .get = ep93xx_i2s_volume_get_double,
+        .put = ep93xx_i2s_volume_put_double,
+        .private_value = ( 0x04 ) | ( 0x05 << 4 )| (0x7f << 16)
+    }
+#else // CONFIG_ARCH_CS4228A      
+    {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Master",
+	.info = ep93xx_i2s_volume_info,
+        .get = ep93xx_i2s_volume_get,
+        .put = ep93xx_i2s_volume_put,
+    },
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name = "PCM",
+        .info = ep93xx_i2s_volume_info_double,
+        .get = ep93xx_i2s_volume_get_double,
+        .put = ep93xx_i2s_volume_put_double,
+        .private_value = ( 0x07 ) | ( 0x08 << 4 ) | (0xb5 << 16)
+    },
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name = "Surround",
+        .info = ep93xx_i2s_volume_info_double,
+        .get = ep93xx_i2s_volume_get_double,
+        .put = ep93xx_i2s_volume_put_double,
+        .private_value = ( 0x09 ) | ( 0x0A << 4 ) | (0xb5 << 16)
+    },
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name = "Center",
+        .info = ep93xx_i2s_volume_info_single,
+        .get = ep93xx_i2s_volume_get_single,
+        .put = ep93xx_i2s_volume_put_single,
+        .private_value =  0x0B  | (0xb5 <<16)
+    },
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name = "LFE",
+        .info = ep93xx_i2s_volume_info_single,
+        .get = ep93xx_i2s_volume_get_single,
+        .put = ep93xx_i2s_volume_put_single,
+        .private_value = 0x0C | ( 1 << 4 ) | (0xb5 <<16)
+    }
+#endif							    
+};
+
+static int __init snd_ep93xx_mixer_new(struct snd_card *card, audio_state_t *state)
+{
+    int idx, err;
+    
+    if (card == NULL)
+	    return -EINVAL;
+    
+    strcpy(card->mixername, "Cirrus Logic Mixer");
+    
+    for (idx = 0; idx < ARRAY_SIZE(snd_ep93xx_i2s_controls); idx++) {
+	if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_ep93xx_i2s_controls[idx], state))) < 0)
+	    return err;
+    }
+
+    return 0;
+}
+
+/* module init & exit */
+static int snd_ep93xx_probe(struct platform_device *dev)
+{
+    struct snd_card *card;
+    int err = -ENOMEM;
+    struct resource *res = NULL;
+            
+    printk("snd_ep93xx_probe - enter\n");
+	
+    /* Open an instance of the SSP driver for I2S codec. */
+    SSP_Handle = SSPDriver->Open(I2S_CODEC,0);
+
+    if( SSP_Handle < 1 ){
+	printk( KERN_ERR "Couldn't open SSP driver!\n");
+	return -ENODEV;
+    }
+    /* Enable audio early on, give the DAC time to come up. */ 
+    res = platform_get_resource( dev, IORESOURCE_MEM, 0);
+
+    if(!res) {
+	printk("error : platform_get_resource \n");
+        return -ENODEV;
+    }
+
+    if (!request_mem_region(res->start,res->end - res->start + 1, "snd-cs4228a" ))
+        return -EBUSY;
+									    
+    
+    snd_ep93xx_audio_init(&audio_state);
+			    
+    /* register the soundcard */
+    card = snd_card_new(index, id, THIS_MODULE, 0);
+    
+    card->dev = &dev->dev;
+
+    if (card == NULL) {
+	DPRINTK(KERN_ERR "snd_card_new() failed\n");
+	goto error;
+    }
+
+#ifdef CONFIG_CODEC_CS4271
+    strcpy(card->driver, "CS4271");
+    strcpy(card->shortname, "Cirrus Logic I2S Audio ");
+    strcpy(card->longname, "Cirrus Logic I2S Audio with CS4271");
+#else
+    strcpy(card->driver, "CS4228A");
+    strcpy(card->shortname, "Cirrus Logic I2S Audio ");
+    strcpy(card->longname, "Cirrus Logic I2S Audio with CS4228A");
+#endif
+
+    /* pcm */
+    if (snd_ep93xx_pcm_new(card, &audio_state, &ep93xx_i2s_pcm) < 0)
+	goto error;
+
+    /* mixer */
+    if (snd_ep93xx_mixer_new(card, &audio_state) < 0)
+	goto error;
+
+    if ((err = snd_card_register(card)) == 0) {
+	printk( KERN_INFO "Cirrus Logic ep93xx i2s audio initialized\n" );
+	platform_set_drvdata(dev,card);
+	DPRINTK("snd_ep93xx_probe - exit\n");
+    	return 0;
+    }
+
+error:
+    snd_card_free(card);
+    printk("snd_ep93xx_probe - error\n");
+    return err;
+
+return 0;
+}
+
+static int snd_ep93xx_remove(struct platform_device *dev)
+{
+    struct resource *res;
+    struct snd_card *card = platform_get_drvdata(dev);
+
+    res = platform_get_resource( dev, IORESOURCE_MEM, 0);
+    release_mem_region(res->start, res->end - res->start + 1);
+	
+    DPRINTK("snd_ep93xx_remove - enter\n");
+    SSPDriver->Close(SSP_Handle);
+    
+    if (card) {
+	snd_card_free(card);
+	platform_set_drvdata(dev, NULL);
+    }
+    DPRINTK("snd_ep93xx_remove - exit\n");
+
+return 0;
+}
+
+
+static struct resource ep93xx_i2s_resources = {
+    .start          = I2S_PHYS_BASE,
+    .end            = I2S_PHYS_BASE + 0x6C,
+    .flags          = IORESOURCE_MEM,
+};
+
+static struct platform_driver snd_ep93xx_driver = {
+    .probe      = snd_ep93xx_probe,
+    .remove     = snd_ep93xx_remove,
+    .driver	= {
+		    .name = AUDIO_NAME,
+		    .bus  = &platform_bus_type,
+		  },
+};
+
+static void snd_ep93xx_platform_release(struct device *device)
+{
+        // This is called when the reference count goes to zero.
+}
+	
+static struct platform_device snd_ep93xx_device = {
+    .name   	= AUDIO_NAME,
+    .id     	= -1,
+    .dev    	= {
+    		     .release = snd_ep93xx_platform_release,
+		  },
+    .num_resources  = 1,
+    .resource 	= &ep93xx_i2s_resources,
+        		    
+};						
+						
+
+static int __init snd_ep93xx_init(void)
+{
+    int ret;
+
+    DPRINTK("snd_ep93xx_init - enter\n");	
+    ret = platform_driver_register(&snd_ep93xx_driver);
+    if (!ret) {
+	ret = platform_device_register(&snd_ep93xx_device);
+	if (ret)
+	    platform_driver_unregister(&snd_ep93xx_driver);
+    }
+    DPRINTK("snd_ep93xx_init - exit\n");
+    return ret;										
+}
+
+static void __exit snd_ep93xx_exit(void)
+{
+    DPRINTK("snd_ep93xx_exit - enter\n");
+    platform_device_unregister(&snd_ep93xx_device);
+    platform_driver_unregister(&snd_ep93xx_driver);
+    DPRINTK("snd_ep93xx_exit - exit\n");
+    
+}
+
+module_init(snd_ep93xx_init);
+module_exit(snd_ep93xx_exit);
+
+MODULE_DESCRIPTION("Cirrus Logic audio module");
+MODULE_LICENSE("GPL");
diff --exclude=Makefile.fwinst -urN linux-2.6.29.2/sound/arm/ep93xx-i2s.h linux-2.6.29.2.new/sound/arm/ep93xx-i2s.h
--- linux-2.6.29.2/sound/arm/ep93xx-i2s.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.2.new/sound/arm/ep93xx-i2s.h	2009-05-06 06:52:19.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+ * linux/sound/arm/ep93xx-i2s.c -- ALSA PCM interface for the edb93xx i2s audio
+ *
+ * Author:      Fred Wei
+ * Created:     July 19, 2005
+ * Copyright:   Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define EP93XX_DEFAULT_NUM_CHANNELS     2
+#define EP93XX_DEFAULT_FORMAT           SNDRV_PCM_FORMAT_S16_LE
+#define EP93XX_DEFAULT_BIT_WIDTH        16
+#define MAX_DEVICE_NAME 		20
+
+/*
+ * Buffer Management
+ */
+				
+typedef struct {
+
+    unsigned char	*area;    	/* virtual pointer */
+    dma_addr_t 		dma_addr;       /* physical address */
+    size_t 		bytes;      
+    size_t 		reportedbytes;	/* buffer size */
+    int 		sent;		/* indicates that dma has the buf */
+    char		*start;		/* points to actual buffer */
+
+} audio_buf_t;
+
+
+typedef struct {
+
+    unsigned char	*area;  		/* virtual pointer */
+    dma_addr_t 		addr;        		/* physical address */
+    size_t 		bytes;          	/* buffer size in bytes */
+    unsigned char      	*buff_pos;              /* virtual pointer */
+    audio_buf_t        	*audio_buffers; 	/* array of audio buffer structures */
+    int 		audio_buff_count;
+		
+
+} audio_channel_t;
+
+typedef struct audio_stream_s {
+
+    /* dma stuff */
+    int			dmahandles[3];		/* handles for dma driver instances */
+    char		devicename[MAX_DEVICE_NAME]; /* string - name of device */
+    int			dma_num_channels;		/* 1, 2, or 3 DMA channels */
+    audio_channel_t	*dma_channels;
+    u_int 		nbfrags;		/* nbr of fragments i.e. buffers */
+    u_int		fragsize;		/* fragment i.e. buffer size */
+    u_int		dmasize;
+    int 		bytecount;		/* nbr of processed bytes */
+    int 		externedbytecount;	/* nbr of processed bytes */
+    volatile int        active;                 /* actually in progress                 */
+    volatile int        stopped;                /* might be active but stopped          */
+    char 		*hwbuf[3];
+    long		audio_rate;
+    long 		audio_num_channels;		/* Range: 1 to 6 */
+    int			audio_channels_flag;
+    long 		audio_format;
+    long 		audio_stream_bitwidth;		/* Range: 8, 16, 24 */
+    int			dma2usr_ratio;
+
+} audio_stream_t;
+
+
+/*
+ * State structure for one instance
+ */
+typedef struct {
+	    
+    audio_stream_t 	*output_stream;
+    audio_stream_t 	*input_stream;
+    ep93xx_dma_dev_t	output_dma[3];
+    ep93xx_dma_dev_t	input_dma[3];
+    char 		*output_id[3];
+    char 		*input_id[3];
+    struct              semaphore sem;          /* to protect against races in attach() */
+    int			codec_set_by_playback;
+    int                 codec_set_by_capture;
+    unsigned char   	playback_volume[5][2];    		
+} audio_state_t;
+
